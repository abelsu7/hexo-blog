<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?c61262c25ca5d4ed66df331a31b5bf49"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="cc3c_UncRv21aEZwqejVxKpUMR7h9ldNUTeYjawUS-g">
    
    
    <meta name="baidu-site-verification" content="HnoV7q61W5">
    
    
    
    <title>Go Web 编程笔记 | Keep Coding | 苏易北</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Go,Web 开发">
    <meta name="description" content="Go Web Programming Notes. To Be Updated…">
<meta name="keywords" content="Go,Web 开发">
<meta property="og:type" content="article">
<meta property="og:title" content="Go Web 编程笔记">
<meta property="og:url" content="https://abelsu7.top/2019/08/15/go-web-programming/index.html">
<meta property="og:site_name" content="Keep Coding">
<meta property="og:description" content="Go Web Programming Notes. To Be Updated…">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://abelsu7.top/2019/08/15/go-web-programming/cover.png">
<meta property="og:image" content="https://abelsu7.top/2019/08/15/go-web-programming/3.3.http.png">
<meta property="og:image" content="https://abelsu7.top/2019/08/15/go-web-programming/3.3.illustrator.png">
<meta property="og:updated_time" content="2019-10-24T15:20:01.010Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go Web 编程笔记">
<meta name="twitter:description" content="Go Web Programming Notes. To Be Updated…">
<meta name="twitter:image" content="https://abelsu7.top/2019/08/15/go-web-programming/cover.png">
    
        <link rel="alternate" type="application/atom+xml" title="Keep Coding" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/back_blue.png)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/fong.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Abel Su</h5>
          <a href="mailto:abelsu7@gmail.com" title="abelsu7@gmail.com" class="mail">abelsu7@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://notes.abelsu7.top"  >
                <i class="icon icon-lg icon-sticky-note"></i>
                笔记
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/abelsu7"  >
                <i class="icon icon-lg icon-github"></i>
                代码
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends/"  >
                <i class="icon icon-lg icon-user"></i>
                友链
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/bookmarks/"  >
                <i class="icon icon-lg icon-bookmark"></i>
                收藏
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/books/"  >
                <i class="icon icon-lg icon-book"></i>
                读书
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/movies/"  >
                <i class="icon icon-lg icon-film"></i>
                影视
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/games/"  >
                <i class="icon icon-lg icon-gamepad"></i>
                游戏
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://notes.abelsu7.top/#/links/wechat"  >
                <i class="icon icon-lg icon-wechat"></i>
                微信
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/2018/09/21/how-to-learn-coding/"  >
                <i class="icon icon-lg icon-code"></i>
                学习
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/wiki/"  >
                <i class="icon icon-lg icon-sort-alpha-asc"></i>
                速查
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about/"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Go Web 编程笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Go Web 编程笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-08-15T07:16:25.000Z" itemprop="datePublished" class="page-time">
  2019-08-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-快速开始"><span class="post-toc-text">1. 快速开始</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-HttpRouter"><span class="post-toc-text">2. HttpRouter</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-http-包建立-Web-服务器"><span class="post-toc-text">3. http 包建立 Web 服务器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-Go-如何使得-Web-工作"><span class="post-toc-text">4. Go 如何使得 Web 工作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-基本概念"><span class="post-toc-text">4.1 基本概念</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-2-HTTP-包的执行流程"><span class="post-toc-text">4.2 HTTP 包的执行流程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-3-如何监听端口？"><span class="post-toc-text">4.3 如何监听端口？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-4-如何接收客户端请求？"><span class="post-toc-text">4.4 如何接收客户端请求？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-5-如何分配-handler？"><span class="post-toc-text">4.5 如何分配 handler？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-6-HTTP-连接的处理流程"><span class="post-toc-text">4.6 HTTP 连接的处理流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-Go-的-http-包详解"><span class="post-toc-text">5. Go 的 http 包详解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-1-Conn-的-goroutine"><span class="post-toc-text">5.1 Conn 的 goroutine</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-2-ServeMux-的自定义"><span class="post-toc-text">5.2 ServeMux 的自定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-3-外部实现自定义路由"><span class="post-toc-text">5.3 外部实现自定义路由</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-4-Go-代码的执行流程"><span class="post-toc-text">5.4 Go 代码的执行流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-表单"><span class="post-toc-text">6. 表单</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-1-处理表单的输入"><span class="post-toc-text">6.1 处理表单的输入</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-访问数据库"><span class="post-toc-text">7. 访问数据库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-Session-和数据存储"><span class="post-toc-text">8. Session 和数据存储</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-文本文件处理"><span class="post-toc-text">9. 文本文件处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#9-1-XML-处理"><span class="post-toc-text">9.1 XML 处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#参考资料"><span class="post-toc-text">参考资料</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文章教程"><span class="post-toc-text">文章教程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RESTful"><span class="post-toc-text">RESTful</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Mock-API"><span class="post-toc-text">Mock API</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RPC"><span class="post-toc-text">RPC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#数据加密"><span class="post-toc-text">数据加密</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Go-Web-框架"><span class="post-toc-text">Go Web 框架</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Vue-Element"><span class="post-toc-text">Vue + Element</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Go-Vue"><span class="post-toc-text">Go + Vue</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Electron"><span class="post-toc-text">Electron</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Koa"><span class="post-toc-text">Koa</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Express"><span class="post-toc-text">Express</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#其他"><span class="post-toc-text">其他</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-go-web-programming"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Go Web 编程笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-08-15 15:16:25" datetime="2019-08-15T07:16:25.000Z"  itemprop="datePublished">2019-08-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p><strong><em>Go Web Programming Notes. To Be Updated…</em></strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/08/15/go-web-programming/cover.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<a id="more"></a>
<h3 id="1-快速开始"><a href="#1-快速开始" class="headerlink" title="1. 快速开始"></a>1. 快速开始</h3><pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func handler(writer http.ResponseWriter, request *http.Request) {
    fmt.Fprintf(writer, &quot;Hello Web, %s!&quot;, request.URL.Path[1:])
}

func main() {
    http.HandleFunc(&quot;/&quot;, handler)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>
<p>HTTP 请求的 URL 格式：</p>
<pre><code class="lang-bash">http://&lt;servername&gt;/&lt;handlername&gt;?&lt;parameters&gt;
</code></pre>
<h3 id="2-HttpRouter"><a href="#2-HttpRouter" class="headerlink" title="2. HttpRouter"></a>2. HttpRouter</h3><p>相关参考：</p>
<ul>
<li><a href="https://learnku.com/docs/build-web-application-with-golang/083-rest/3205" target="_blank" rel="noopener">08.3. REST - Go Web 编程 | Learnku</a></li>
<li><a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter - julienschmidt | Github</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md" target="_blank" rel="noopener">build-web-application-with-golang - astaxie | Github</a></li>
</ul>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;

    &quot;github.com/julienschmidt/httprouter&quot;
)

func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
    fmt.Fprint(w, &quot;Welcome!\n&quot;)
}

func Hello(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    fmt.Fprintf(w, &quot;hello %s!\n&quot;, ps.ByName(&quot;name&quot;))

}

func getUser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    uid := ps.ByName(&quot;uid&quot;)

    fmt.Fprintf(w, &quot;you are get user %s&quot;, uid)
}

func modifyUser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    uid := ps.ByName(&quot;uid&quot;)
    fmt.Fprintf(w, &quot;you are modify user %s&quot;, uid)
}

func deleteUser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    uid := ps.ByName(&quot;uid&quot;)
    fmt.Fprintf(w, &quot;you are delete user %s&quot;, uid)
}

func addUser(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    uid := ps.ByName(&quot;uid&quot;)
    fmt.Fprintf(w, &quot;you are add user %s&quot;, uid)
}

func main() {
    router := httprouter.New()
    router.GET(&quot;/&quot;, Index)
    router.GET(&quot;/hello/:name&quot;, Hello)

    router.GET(&quot;/user/:uid&quot;, getUser)
    router.POST(&quot;/adduser/:uid&quot;, addUser)
    router.DELETE(&quot;/deluser/:uid&quot;, deleteUser)
    router.PUT(&quot;/moduser/:uid&quot;, modifyUser)

    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, router))
}
</code></pre>
<h3 id="3-http-包建立-Web-服务器"><a href="#3-http-包建立-Web-服务器" class="headerlink" title="3. http 包建立 Web 服务器"></a>3. http 包建立 Web 服务器</h3><blockquote>
<p>参见 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.2.md" target="_blank" rel="noopener">3.2 Go 搭建一个 Web 服务器 - build-web-application-with-golang | Github</a></p>
</blockquote>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
)

func sayHelloName(w http.ResponseWriter, r *http.Request) {
    r.ParseForm()

    fmt.Println(r.Form)             // 解析参数，默认是不会解析的
    fmt.Println(&quot;path&quot;, r.URL.Path) // 在服务器端打印
    fmt.Println(&quot;scheme&quot;, r.URL.Scheme)
    fmt.Println(r.Form[&quot;url_long&quot;])

    for k, v := range r.Form {
        fmt.Println(&quot;key:&quot;, k)
        fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))
    }

    fmt.Fprintf(w, &quot;Hello Abel!&quot;) // 写入到 Response 中
}

func main() {
    http.HandleFunc(&quot;/&quot;, sayHelloName)           // 设置访问的路由
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil)) // 设置监听的端口
}
</code></pre>
<p><code>GET</code>请求：</p>
<pre><code class="lang-http">GET http://localhost:8080?url_long=111&amp;url_long=222 HTTP/1.1
</code></pre>
<p>响应：</p>
<pre><code class="lang-http">HTTP/1.1 200 OK
Date: Mon, 02 Sep 2019 10:24:36 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
Connection: close

Hello Abel!
</code></pre>
<p>服务端输出：</p>
<pre><code class="lang-bash">&gt; go run main.go

map[url_long:[111 222]]
path /
scheme
[111 222]
key: url_long
val: 111222
</code></pre>
<h3 id="4-Go-如何使得-Web-工作"><a href="#4-Go-如何使得-Web-工作" class="headerlink" title="4. Go 如何使得 Web 工作"></a>4. Go 如何使得 Web 工作</h3><h4 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h4><p>先理清几个基本概念：</p>
<ul>
<li><strong>Request</strong>：用户请求的信息，用来<strong>解析用户的请求信息</strong>，包括<code>POST</code>、<code>GET</code>、<code>Cookie</code>、<code>URL</code>等信息 </li>
<li><strong>Response</strong>：服务器需要<strong>反馈给客户端的信息</strong></li>
<li><strong>Conn</strong>：用户每次的<strong>请求连接</strong></li>
<li><strong>Handler</strong>：处理请求和生成返回信息的<strong>处理逻辑</strong></li>
</ul>
<p>下图是 Go 实现 Web 服务的工作模式流程图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="3.3.http.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="4-2-HTTP-包的执行流程"><a href="#4-2-HTTP-包的执行流程" class="headerlink" title="4.2 HTTP 包的执行流程"></a>4.2 HTTP 包的执行流程</h4><p>HTTP 包的执行流程：</p>
<ol>
<li>创建<code>Listen Socket</code>，<strong>监听指定端口</strong>，等待客户端请求的到来</li>
<li><code>Listen Socket</code>接收客户端的请求，得到<code>Client Socket</code>，接下来<strong>通过</strong><code>Client Socket</code><strong>与客户端通信</strong></li>
<li>处理客户端的请求，首先从<code>Client Socket</code><strong>读取 HTTP 请求的协议头</strong>，如果是<code>POST</code>方法，还可能要<strong>读取客户端提交的数据</strong>，然后交给相应的<code>handler</code><strong>处理请求</strong>。处理完毕后，<code>handler</code>会<strong>准备好客户端需要的数据</strong>，通过<code>Client Socket</code>写给客户端</li>
</ol>
<p>对于上述过程，要想了解 Go 是如何让 Web 运行起来的，需要搞清楚以下三点：</p>
<ul>
<li>如何<strong>监听端口</strong>？</li>
<li>如何<strong>接收客户端请求</strong>？</li>
<li>如何<strong>分配 handler</strong>？</li>
</ul>
<h4 id="4-3-如何监听端口？"><a href="#4-3-如何监听端口？" class="headerlink" title="4.3 如何监听端口？"></a>4.3 如何监听端口？</h4><blockquote>
<p><strong>Go Version</strong>: <code>1.12.6</code></p>
</blockquote>
<p>在之前的代码中可以看到，监听端口的实现是在<code>http.ListenAndServe()</code>函数中：</p>
<pre><code class="lang-go">http.ListenAndServe(&quot;:8080&quot;, nil)
</code></pre>
<p>该函数首先会初始化一个<code>Server</code>对象，之后调用该对象的同名方法：</p>
<pre><code class="lang-go">// ListenAndServe listens on the TCP network address addr and then calls
// Serve with handler to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
//
// The handler is typically nil, in which case the DefaultServeMux is used.
//
// ListenAndServe always returns a non-nil error.
func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
</code></pre>
<p><code>Server</code>结构体的<code>ListenAndServe()</code>方法又调用了<code>net.Listen(&quot;tcp&quot;, addr)</code>，也就是底层用 <strong>TCP 协议</strong>搭建了一个服务，开始监听指定的端口：</p>
<pre><code class="lang-go">// ListenAndServe listens on the TCP network address srv.Addr and then
// calls Serve to handle requests on incoming connections.
// Accepted connections are configured to enable TCP keep-alives.
//
// If srv.Addr is blank, &quot;:http&quot; is used.
//
// ListenAndServe always returns a non-nil error. After Shutdown or Close,
// the returned error is ErrServerClosed.
func (srv *Server) ListenAndServe() error {
    if srv.shuttingDown() {
        return ErrServerClosed
    }
    addr := srv.Addr
    if addr == &quot;&quot; {
        addr = &quot;:http&quot;
    }
    ln, err := net.Listen(&quot;tcp&quot;, addr) // 监听指定的端口
    if err != nil {
        return err
    }
    // 接收并处理客户端的请求
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
</code></pre>
<h4 id="4-4-如何接收客户端请求？"><a href="#4-4-如何接收客户端请求？" class="headerlink" title="4.4 如何接收客户端请求？"></a>4.4 如何接收客户端请求？</h4><p>监听端口之后，上述代码最后又调用了<code>srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})</code>作为返回值，该函数的作用就是<strong>接收并处理客户端的请求信息</strong>。该函数的具体实现如下：</p>
<pre><code class="lang-go">// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
//
// HTTP/2 support is only enabled if the Listener returns *tls.Conn
// connections and they were configured with &quot;h2&quot; in the TLS
// Config.NextProtos.
//
// Serve always returns a non-nil error and closes l.
// After Shutdown or Close, the returned error is ErrServerClosed.
func (srv *Server) Serve(l net.Listener) error {
    // 省略部分代码
    for {
        rw, e := l.Accept() // 1. 接收客户端请求
        if e != nil {
            select {
            case &lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    tempDelay *= 2
                }
                if max := 1 * time.Second; tempDelay &gt; max {
                    tempDelay = max
                }
                srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
                time.Sleep(tempDelay)
                continue
            }
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw) // 2. 创建一个新的 Conn
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)      // 3. 为每个连接单独开一个 goroutine
    }
}
</code></pre>
<p>省略部分代码，重点关注其中的<code>for{}</code>循环：</p>
<ol>
<li><code>l.Accept()</code>：<strong>接收请求</strong>，并处理可能出现的错误</li>
<li><code>srv.newConn(rw)</code>：<strong>创建一个新的连接</strong><code>Conn</code></li>
<li><code>go c.serve(ctx)</code>：<strong>为新连接单独开一个</strong><code>goroutine</code>，把请求的数据当作参数扔给这个<code>Conn</code>去服务</li>
</ol>
<h4 id="4-5-如何分配-handler？"><a href="#4-5-如何分配-handler？" class="headerlink" title="4.5 如何分配 handler？"></a>4.5 如何分配 handler？</h4><p>那么如何具体分配到相应的函数来处理请求呢？可以看到，在上面的代码中，<strong>最后实际调用</strong><code>go c.serve(ctx)</code><strong>处理请求</strong>，该函数的实现代码较长，仅截取重要语句如下：</p>
<pre><code class="lang-go">// Serve a new connection.
func (c *conn) serve(ctx context.Context) {
    // 省略部分代码
    for {
        // 1. 解析请求，获取 ResponseWriter 及 Request
        w, err := c.readRequest(ctx) 

        // 省略部分代码

        // HTTP cannot have multiple simultaneous active requests.[*]
        // Until the server replies to this request, it can&#39;t read another,
        // so we might as well run the handler in this goroutine.
        // [*] Not strictly true: HTTP pipelining. We could let them all process
        // in parallel even if their responses need to be serialized.
        // But we&#39;re not going to implement HTTP pipelining because it
        // was never deployed in the wild and the answer is HTTP/2.

        // 2. 进一步处理请求
        serverHandler{c.server}.ServeHTTP(w, w.req) 
    }
    // 省略部分代码
}
</code></pre>
<ol>
<li><code>c.readRequest(ctx)</code>：<strong>解析请求</strong>，获取对应的<code>ResponseWriter</code>及<code>Request</code></li>
<li><code>serverHandler.ServeHTTP(w, w.req)</code>：进一步<strong>处理请求</strong></li>
</ol>
<p>结构体<code>serverHandler</code>的<code>ServeHTTP()</code>方法具体实现如下：</p>
<pre><code class="lang-go">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
    // 1. 获取 Server 对应的 Handler
    handler := sh.srv.Handler

    // 2. 若对应的 Handler 为 nil，则使用 DefaultServeMux
    if handler == nil {
        handler = DefaultServeMux
    }
    if req.RequestURI == &quot;*&quot; &amp;&amp; req.Method == &quot;OPTIONS&quot; {
        handler = globalOptionsHandler{}
    }

    // 3. 调用相应的函数处理请求
    handler.ServeHTTP(rw, req)
}
</code></pre>
<p>首先<strong>通过</strong><code>handler := sh.srv.Handler</code><strong>获取对应的</strong><code>Handler</code>，也就是最开始调用<code>ListenAndServe()</code>时传入的第二个参数。实际上<code>Handler</code>是一个<strong>接口类型</strong>，只定义了一个方法<code>ServeHTTP()</code>：</p>
<pre><code class="lang-go">type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</code></pre>
<p>例如之前传入的参数是<code>nil</code>，就会使用默认的<code>DefaultServeMux</code>。该变量是一个<strong>路由器</strong>（或者说，<strong>HTTP 请求多路复用器</strong>），用来<strong>匹配 URL 并跳转到其相应的 handle 函数</strong>，它在 Go 源码的<code>server.go</code>中定义：</p>
<pre><code class="lang-go">// ServeMux is an HTTP request multiplexer.
// It matches the URL of each incoming request against a list of registered
// patterns and calls the handler for the pattern that
// most closely matches the URL.
//
// Patterns name fixed, rooted paths, like &quot;/favicon.ico&quot;,
// or rooted subtrees, like &quot;/images/&quot; (note the trailing slash).
// Longer patterns take precedence over shorter ones, so that
// if there are handlers registered for both &quot;/images/&quot;
// and &quot;/images/thumbnails/&quot;, the latter handler will be
// called for paths beginning &quot;/images/thumbnails/&quot; and the
// former will receive requests for any other paths in the
// &quot;/images/&quot; subtree.
//
// Note that since a pattern ending in a slash names a rooted subtree,
// the pattern &quot;/&quot; matches all paths not matched by other registered
// patterns, not just the URL with Path == &quot;/&quot;.
//
// If a subtree has been registered and a request is received naming the
// subtree root without its trailing slash, ServeMux redirects that
// request to the subtree root (adding the trailing slash). This behavior can
// be overridden with a separate registration for the path without
// the trailing slash. For example, registering &quot;/images/&quot; causes ServeMux
// to redirect a request for &quot;/images&quot; to &quot;/images/&quot;, unless &quot;/images&quot; has
// been registered separately.
//
// Patterns may optionally begin with a host name, restricting matches to
// URLs on that host only. Host-specific patterns take precedence over
// general patterns, so that a handler might register for the two patterns
// &quot;/codesearch&quot; and &quot;codesearch.google.com/&quot; without also taking over
// requests for &quot;http://www.google.com/&quot;.
//
// ServeMux also takes care of sanitizing the URL request path and the Host
// header, stripping the port number and redirecting any request containing . or
// .. elements or repeated slashes to an equivalent, cleaner URL.
type ServeMux struct {
    mu    sync.RWMutex
    m     map[string]muxEntry
    es    []muxEntry // slice of entries sorted from longest to shortest.
    hosts bool       // whether any patterns contain hostnames
}

type muxEntry struct {
    h       Handler
    pattern string
}

// NewServeMux allocates and returns a new ServeMux.
func NewServeMux() *ServeMux { return new(ServeMux) }

// DefaultServeMux is the default ServeMux used by Serve.
var DefaultServeMux = &amp;defaultServeMux

var defaultServeMux ServeMux
</code></pre>
<p>最开始在<code>main()</code>函数中调用<code>http.HandleFunc(&quot;/&quot;, sayHelloName)</code>时，就<strong>注册了请求</strong><code>/</code><strong>的路由规则</strong>：</p>
<pre><code class="lang-go">func main() {
    http.HandleFunc(&quot;/&quot;, sayHelloName)           // 设置访问的路由
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil)) // 设置监听的端口
}

// HandleFunc registers the handler function for the given pattern
// in the DefaultServeMux.
// The documentation for ServeMux explains how patterns are matched.
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
</code></pre>
<p>这样一来当请求的 URI 为<code>/</code>时，路由就会跳转到<code>/</code>对应的<code>Handler</code>，也就是<code>sayHelloName()</code>本身，最后<strong>把结果写入 Response 并反馈给客户端</strong>。</p>
<h4 id="4-6-HTTP-连接的处理流程"><a href="#4-6-HTTP-连接的处理流程" class="headerlink" title="4.6 HTTP 连接的处理流程"></a>4.6 HTTP 连接的处理流程</h4><p>一个 HTTP 连接的处理流程示意图如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/08/15/go-web-programming/3.3.illustrator.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="5-Go-的-http-包详解"><a href="#5-Go-的-http-包详解" class="headerlink" title="5. Go 的 http 包详解"></a>5. Go 的 http 包详解</h3><blockquote>
<p>参见 <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.4.md" target="_blank" rel="noopener">3.4 Go 的 http 包详解 - build-web-application-with-golang | Github</a></p>
</blockquote>
<p>Go 的<code>http</code>包有两个核心功能：<strong>Conn</strong>、<strong>ServeMux</strong>。</p>
<h4 id="5-1-Conn-的-goroutine"><a href="#5-1-Conn-的-goroutine" class="headerlink" title="5.1 Conn 的 goroutine"></a>5.1 Conn 的 goroutine</h4><p>与其他一些语言编写的 HTTP 服务器不同，Go 为了实现高并发和高性能，<strong>使用了</strong><code>goroutine</code><strong>来处理</strong><code>Conn</code><strong>的读写事件</strong>，这样<strong>每个请求都能保持独立，相互不会阻塞</strong>，可以高效的响应网络事件，这是 Go 高效的保证。</p>
<p>Go 在等待客户端请求的<code>Serve()</code>函数里是这样写的：</p>
<pre><code class="lang-go">func (srv *Server) Serve(l net.Listener) error {
    // 省略部分代码
    for {
        rw, e := l.Accept()

        // 省略错误处理

        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)
    }
}
</code></pre>
<p>可以看到客户端的每次请求都会创建一个<code>Conn</code>，函数<code>newConn()</code>在<code>server.go</code>中的实现如下：</p>
<pre><code class="lang-go">// Create new connection from rwc.
func (srv *Server) newConn(rwc net.Conn) *conn {
    c := &amp;conn{
        server: srv,
        rwc:    rwc,
    }
    if debugServerConnections {
        c.rwc = newLoggingConn(&quot;server&quot;, c.rwc)
    }
    return c
}
</code></pre>
<p>可以看到<code>Conn</code>实际上在<code>net</code>包中定义，是一个接口类型，在<code>net.go</code>中的定义如下：</p>
<pre><code class="lang-go">// Conn is a generic stream-oriented network connection.
//
// Multiple goroutines may invoke methods on a Conn simultaneously.
type Conn interface {
    Read(b []byte) (n int, err error)
    Write(b []byte) (n int, err error)
    Close() error

    LocalAddr() Addr
    RemoteAddr() Addr

    SetDeadline(t time.Time) error
    SetReadDeadline(t time.Time) error
    SetWriteDeadline(t time.Time) error
}
</code></pre>
<blockquote>
<p><strong>客户端的每次请求都会创建一个</strong><code>Conn</code>，这个<code>Conn</code>里面保存了该次请求的信息，然后再传递到对应的<code>handler</code>，该<code>handler</code>中便可以读取到相应的 Header 信息，这样就<strong>保证了每个请求的独立性</strong></p>
</blockquote>
<h4 id="5-2-ServeMux-的自定义"><a href="#5-2-ServeMux-的自定义" class="headerlink" title="5.2 ServeMux 的自定义"></a>5.2 ServeMux 的自定义</h4><p>之前调用<code>http.ListenAndServe(&quot;:8080&quot;, nil)</code>时，实际上内部时调用了<code>http</code>包默认的路由器<code>DefaultServeMux</code>，通过路由器把本次请求的信息传递到了后端的处理函数，它是一个<code>ServeMux</code>类型的变量：</p>
<pre><code class="lang-go">// DefaultServeMux is the default ServeMux used by Serve.
var DefaultServeMux = &amp;defaultServeMux

var defaultServeMux ServeMux
</code></pre>
<p>结构体<code>ServeMux</code>就是 Go 中的路由器，它在<code>server.go</code>中的定义如下：</p>
<pre><code class="lang-go">type ServeMux struct {
    // 锁，由于请求涉及到并发处理，因此这里需要一个锁机制
    mu    sync.RWMutex
    // 路由规则，一个路由表达式 string 对应一个 muxEntry 实体
    m     map[string]muxEntry
    es    []muxEntry // slice of entries sorted from longest to shortest.
    // 是否在任意的规则中带有 host 信息
    hosts bool       // whether any patterns contain hostnames
}

type muxEntry struct {
    h       Handler // 路由表达式对应哪个 handler
    pattern string  // 路径匹配字符串
}

type Handler interface {
    ServeHTTP(ResponseWriter, *Request) // 路由实现器
}
</code></pre>
<p><code>Handler</code>是一个接口，但是之前示例代码中的<code>sayHelloName()</code>函数并没有实现<code>ServeHTTP()</code>这个方法，为什么能作为 Handler 添加到路由器中呢？</p>
<p>这是因为在<code>http</code>包中还定义了一个类型<code>HandlerFunc</code>，回顾一下之前设置访问路由的语句：</p>
<pre><code class="lang-go">http.HandleFunc(&quot;/&quot;, sayHelloName)
</code></pre>
<p>这里我们调用了<code>HandleFunc()</code>将<code>sayHelloName()</code>设置为<code>&quot;/&quot;</code>路由对应的<code>Handler</code>，而<code>HandleFunc()</code>实际进行的操作如下：</p>
<pre><code class="lang-go">// HandleFunc registers the handler function for the given pattern.
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    if handler == nil {
        panic(&quot;http: nil handler&quot;)
    }
    mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre>
<p>可以看到这里将<code>handler</code>转换为了<code>HandlerFunc</code>，而它默认实现了<code>ServeHTTP()</code>方法，即我们调用了<code>HandlerFunc(f)</code>，将<code>f</code>强制类型转换为<code>HandlerFunc</code>类型，这样<code>f</code>就拥有了<code>ServeHTTP()</code>方法：</p>
<blockquote>
<p>这也是<strong>适配器模式</strong>在 Go 中的应用</p>
</blockquote>
<pre><code class="lang-go">// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
</code></pre>
<p>路由器里存储好了相应的路由规则，那么具体的请求又是怎样分发的呢？实际上，默认的路由器<code>ServeMux</code>实现了<code>ServeHTTP()</code>方法：</p>
<pre><code class="lang-go">// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
    if r.RequestURI == &quot;*&quot; {
        if r.ProtoAtLeast(1, 1) {
            w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
        }
        w.WriteHeader(StatusBadRequest)
        return
    }
    h, _ := mux.Handler(r)
    h.ServeHTTP(w, r)
}
</code></pre>
<p>如上所示，路由器接收到请求之后，如果是<code>*</code>则关闭连接，否则会调用<code>mux.Handler(r)</code>返回对应设置路由的处理 handler，然后执行<code>h.ServeHTTP(w, r)</code>，也就是调用对应路由的 handler 的<code>ServeHTTP</code>接口。</p>
<p>继续来看<code>mux.Handler(r)</code>是如何处理的：</p>
<pre><code class="lang-go">func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {

    // CONNECT requests are not canonicalized.
    if r.Method == &quot;CONNECT&quot; {
        // If r.URL.Path is /tree and its handler is not registered,
        // the /tree -&gt; /tree/ redirect applies to CONNECT requests
        // but the path canonicalization does not.
        if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {
            return RedirectHandler(u.String(), StatusMovedPermanently), u.Path
        }

        return mux.handler(r.Host, r.URL.Path)
    }

    // 省略部分代码

    return mux.handler(host, r.URL.Path)
}

// handler is the main implementation of Handler.
// The path is known to be in canonical form, except for CONNECT methods.
func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()

    // Host-specific pattern takes precedence over generic ones
    if mux.hosts {
        h, pattern = mux.match(host + path)
    }
    if h == nil {
        h, pattern = mux.match(path)
    }
    if h == nil {
        h, pattern = NotFoundHandler(), &quot;&quot;
    }
    return
}
</code></pre>
<p>可以看到在<code>mux.handler()</code>中是调用<code>mux.match()</code>进行匹配的，函数定义如下：</p>
<pre><code class="lang-go">// Find a handler on a handler map given a path string.
// Most-specific (longest) pattern wins.
func (mux *ServeMux) match(path string) (h Handler, pattern string) {
    // Check for exact match first.
    v, ok := mux.m[path]
    if ok {
        return v.h, v.pattern
    }

    // Check for longest valid match.  mux.es contains all patterns
    // that end in / sorted from longest to shortest.
    for _, e := range mux.es {
        if strings.HasPrefix(path, e.pattern) {
            return e.h, e.pattern
        }
    }
    return nil, &quot;&quot;
}
</code></pre>
<p>这样一来就清楚了，在<code>match()</code>方法中，会根据<code>mux.m[path]</code>获取请求路径对应的<code>muxEntry</code>，返回<code>muxEntry</code>中保存的<code>Handler</code>以及<code>pattern</code>字符串，最后调用<code>Handler</code>的<code>ServeHTTP()</code>方法就可以执行相应的函数了。</p>
<h4 id="5-3-外部实现自定义路由"><a href="#5-3-外部实现自定义路由" class="headerlink" title="5.3 外部实现自定义路由"></a>5.3 外部实现自定义路由</h4><p>通过上面的介绍，我们大致了解了 Go 的整个路由过程。除了<strong>默认路由器</strong><code>DefaultServeMux</code>，Go 同时也支持<strong>外部实现的路由器</strong>。</p>
<p><code>http.ListenAndServe()</code>方法的第二个参数就是用来<strong>配置外部路由器</strong>的，它是一个<code>Handler</code>接口，即<strong>外部路由器只要实现了</strong><code>Handler</code><strong>接口的</strong><code>ServeHTTP()</code><strong>方法</strong>，就可以在自己实现的路由器的<code>ServeHTTP()</code>中<strong>实现自定义路由功能</strong>。</p>
<p>如下所示，实现一个简单的<strong>外部路由器</strong><code>MyMux</code>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

type MyMux struct {
}

func (p *MyMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path == &quot;/&quot; {
        sayHelloName(w, r)
        return
    }
    http.NotFound(w, r)
    return
}

func sayHelloName(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hello My Router!&quot;)
}

func main() {
    mux := &amp;MyMux{}
    http.ListenAndServe(&quot;:8080&quot;, mux)
}
</code></pre>
<p>请求报文：</p>
<pre><code class="lang-http">GET http://localhost:8080 HTTP/1.1
</code></pre>
<p>响应报文：</p>
<pre><code class="lang-http">HTTP/1.1 200 OK
Date: Tue, 03 Sep 2019 02:57:42 GMT
Content-Length: 16
Content-Type: text/plain; charset=utf-8
Connection: close

Hello My Router!
</code></pre>
<h4 id="5-4-Go-代码的执行流程"><a href="#5-4-Go-代码的执行流程" class="headerlink" title="5.4 Go 代码的执行流程"></a>5.4 Go 代码的执行流程</h4><blockquote>
<p><strong>Go Version</strong>: <code>1.12.6</code></p>
</blockquote>
<p>分析完<code>http</code>包后，现在梳理一下代码的执行过程。例如下面这段代码：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func index(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Hello %s!\n&quot;, r.URL.Path[1:])
}

func main() {
    http.HandleFunc(&quot;/&quot;, index)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>
<p><strong>首先调用</strong><code>http.HandleFunc()</code>：</p>
<pre><code class="lang-go">http.HandleFunc(&quot;/&quot;, index)
 └─ DefaultServeMux.HandleFunc(pattern, handler)  // 若 handler 为 nil，则触发 panic
     └─ mux.Handle(pattern, HandlerFunc(handler)) // 注册路由
</code></pre>
<ol>
<li>调用<code>DefaultServeMux.HandleFunc()</code></li>
<li>调用<code>DefaultServeMux.Handle()</code>，<strong>注册请求路径所对应的 handler</strong></li>
<li>在<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中<strong>增加对应的 handler 和路由规则</strong></li>
</ol>
<p><strong>之后调用</strong><code>http.ListenAndServe(&quot;:8080&quot;, nil)</code>：</p>
<pre><code class="lang-go">http.ListenAndServe(&quot;:8080&quot;, nil)
 ├─ server := &amp;Server{Addr: addr, Handler: handler}
 └─ server.ListenAndServe()
     ├─ net.Listen(&quot;tcp&quot;, addr)
     └─ srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
         ├─ l.Accept()
         ├─ c := srv.newConn(rw)
         └─ go c.serve(ctx)
             ├─ w, err := c.readRequest(ctx)
             └─ serverHandler{c.server}.ServeHTTP(w, w.req)
                 ├─ handler := sh.srv.Handler // nil 则为 DefaultServeMux
                 └─ handler.ServeHTTP(rw, req)
                     ├─ h, _ := mux.Handler(r)
                     └─ h.ServeHTTP(w, r)
</code></pre>
<ol>
<li>实例化<code>Server</code></li>
<li>调用<code>server.ListenAndServe()</code></li>
<li>调用<code>net.Listen(&quot;tcp&quot;, addr)</code><strong>监听端口</strong>，即<code>Listen</code></li>
<li>调用<code>srv.Serve()</code><strong>处理请求</strong>，即<code>Serve</code></li>
<li>在<code>Serve()</code>中启动一个 <strong>for 循环</strong>，在循环中调用<code>Accept()</code><strong>接收请求</strong></li>
<li>为每个请求实例化一个<code>Conn</code>，开启一个 <strong>goroutine</strong> 并调用<code>go c.serve(ctx)</code>，<strong>为这个请求进行服务</strong></li>
<li>调用<code>c.readRequest(ctx)</code><strong>读取每个请求内容</strong></li>
<li><strong>判断 handler 是否为空</strong>，如果为<code>nil</code>则设为<code>DefaultServeMux</code></li>
<li>调用<code>handler.ServeHTTP(rw, req)</code>，上面的例子中就进入到<code>DefaultServeMux.ServeHTTP(rw, req)</code></li>
<li><strong>根据 Request 选择 handler</strong>，并进入到这个 handler 的<code>ServeHTTP()</code>中</li>
</ol>
<p>选择 handler：</p>
<ul>
<li>循环遍历<code>ServeMux</code>的<code>muxEntry</code>，判断是否有路由能满足这个 Request</li>
<li>如果有路由满足，则调用这个路由 handler 的<code>ServeHTTP()</code></li>
<li>如果没有路由满足，则调用<code>NotFoundHandler</code>的<code>ServeHTTP()</code></li>
</ul>
<h3 id="6-表单"><a href="#6-表单" class="headerlink" title="6. 表单"></a>6. 表单</h3><h4 id="6-1-处理表单的输入"><a href="#6-1-处理表单的输入" class="headerlink" title="6.1 处理表单的输入"></a>6.1 处理表单的输入</h4><p>例如下面的表单<code>login.gtpl</code>：</p>
<pre><code class="lang-html">&lt;html&gt;

&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;
        用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
        密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>处理表单：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;html/template&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
)

func sayHelloName(w http.ResponseWriter, r *http.Request) {
    r.ParseForm() // 解析 URL 传递的参数，对于 POST 则解析 Request Body

    // 注意：如果没有调用 ParseForm 方法，下面无法获取表单的数据
    log.Println(&quot;Inside sayHelloName&quot;)
    fmt.Printf(&quot;Form:\t%v\n&quot;, r.Form)
    fmt.Printf(&quot;path:\t%s\n&quot;, r.URL.Path)
    fmt.Printf(&quot;scheme:\t%s\n&quot;, r.URL.Scheme)
    fmt.Println(r.Form[&quot;url_long&quot;])
    for k, v := range r.Form {
        fmt.Println(&quot;key:&quot;, k)
        fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))
    }
    fmt.Fprintf(w, &quot;Hello abel!\n&quot;)
}

func login(w http.ResponseWriter, r *http.Request) {
    fmt.Println(&quot;method:&quot;, r.Method) // 获取请求的方法
    if r.Method == &quot;GET&quot; {
        t, _ := template.ParseFiles(&quot;login.gtpl&quot;)
        log.Println(t.Execute(w, nil))
    } else {
        // 请求的是登录数据，那么执行登录的逻辑判断
        r.ParseForm()
        fmt.Println(&quot;username:&quot;, r.Form[&quot;username&quot;])
        fmt.Println(&quot;password:&quot;, r.Form[&quot;password&quot;])
    }
}

func main() {
    http.HandleFunc(&quot;/&quot;, sayHelloName)
    http.HandleFunc(&quot;/login&quot;, login)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre>
<p><code>request.Form</code>是一个<code>url.Values</code>类型，里面存储了<code>key=value</code>的信息：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;net/url&quot;
)

func main() {
    v := url.Values{}
    v.Set(&quot;name&quot;, &quot;abel&quot;)
    v.Add(&quot;friend&quot;, &quot;arjen&quot;)
    v.Add(&quot;friend&quot;, &quot;frank&quot;)

    fmt.Println(v.Encode())
    fmt.Println(v.Get(&quot;name&quot;))
    fmt.Println(v.Get(&quot;friend&quot;))
    fmt.Println(v[&quot;friend&quot;])
}

------
friend=arjen&amp;friend=frank&amp;name=abel
abel
arjen
[arjen frank]
</code></pre>
<h3 id="7-访问数据库"><a href="#7-访问数据库" class="headerlink" title="7. 访问数据库"></a>7. 访问数据库</h3><h3 id="8-Session-和数据存储"><a href="#8-Session-和数据存储" class="headerlink" title="8. Session 和数据存储"></a>8. Session 和数据存储</h3><h3 id="9-文本文件处理"><a href="#9-文本文件处理" class="headerlink" title="9. 文本文件处理"></a>9. 文本文件处理</h3><h4 id="9-1-XML-处理"><a href="#9-1-XML-处理" class="headerlink" title="9.1 XML 处理"></a>9.1 XML 处理</h4><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><h4 id="文章教程"><a href="#文章教程" class="headerlink" title="文章教程"></a>文章教程</h4><blockquote>
<ol>
<li><a href="https://github.com/sausheong/gwp" target="_blank" rel="noopener">Go Web Programming - sausheong | Github</a></li>
<li><a href="https://learnku.com/docs/build-web-application-with-golang/083-rest/3205" target="_blank" rel="noopener">08.3. REST - Go Web 编程 | Learnku</a></li>
<li><a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter - julienschmidt | Github</a></li>
<li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md" target="_blank" rel="noopener">build-web-application-with-golang - astaxie | Github</a></li>
<li><a href="https://blog.ruanbekker.com/blog/2018/11/21/golang-building-a-basic-web-server-in-go/" target="_blank" rel="noopener">Golang: Building a Basic Web Server in Go | Ruan Bekker’s Blog</a></li>
<li><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">project-layout - Standard Go Project Layout | Github</a></li>
<li><a href="https://github.com/Alikhll/golang-developer-roadmap" target="_blank" rel="noopener">Go Developer Roadmap - Go 开发者路线图 | Github</a></li>
<li><a href="https://colobu.com/2019/08/21/decorator-pattern-pipeline-pattern-and-go-web-middlewares/" target="_blank" rel="noopener">明白了，原来 Go Web 框架中的中间件都是这样实现的 | 鸟窝</a></li>
<li><a href="https://coolshell.cn/articles/17929.html" target="_blank" rel="noopener">Go 语言的修饰器编程 | 酷壳 CoolShell</a></li>
<li><a href="https://learnku.com/golang/t/24598" target="_blank" rel="noopener">教程：使用 go 的 gin 和 gorm 框架来构建 RESTful API 微服务 | LearnKu</a></li>
<li><a href="https://medium.com/@thedevsaddam/build-restful-api-service-in-golang-using-gin-gonic-framework-85b1a6e176f3" target="_blank" rel="noopener">Build RESTful API service in golang using gin-gonic framework | Medium</a></li>
</ol>
</blockquote>
<h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h4><ul>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南 | 阮一峰</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html" target="_blank" rel="noopener">RESTful API 最佳实践 | 阮一峰</a></li>
<li><a href="https://i6448038.github.io/2017/06/28/rest-接口规范/" target="_blank" rel="noopener">RESTful API 规范 | RyuGou</a></li>
<li><a href="https://mp.weixin.qq.com/s/kETBS8e5TU0OOJ76yPoKlg" target="_blank" rel="noopener">如何给老婆解释什么是Restful | Java3y</a></li>
<li><a href="https://blog.yumaojun.net/2017/10/03/restful-vs-soap/" target="_blank" rel="noopener">对比 RESTful 与 SOAP，深入理解 RESTful | 紫川秀的博客</a></li>
<li><a href="https://blog.yumaojun.net/2017/01/06/rest-api-design/" target="_blank" rel="noopener">RESTful API 设计规范 | 紫川秀的博客</a></li>
<li><a href="https://blog.yumaojun.net/2017/01/05/api-design-swagger/" target="_blank" rel="noopener">如何使用 swagger 设计出漂亮的 RESTful API | 紫川秀的博客</a></li>
<li><a href="https://razeencheng.com/post/go-swagger.html" target="_blank" rel="noopener">Go 学习笔记 (六) - 使用 swaggo 自动生成 Restful API 文档 | Razeen’s Blog</a></li>
</ul>
<h4 id="Mock-API"><a href="#Mock-API" class="headerlink" title="Mock API"></a>Mock API</h4><ul>
<li><a href="http://rap2.taobao.org" target="_blank" rel="noopener">RAP2 - Smart API manage tool</a></li>
</ul>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><ul>
<li><a href="http://lday.me/2017/10/22/0015_How_we_use_gRPC_to_build_a_client_server_system_in_Go/" target="_blank" rel="noopener">我们如何在 Go 中使用 gRPC 构建 C/S 结构系统 | lday</a></li>
</ul>
<h4 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h4><ul>
<li><a href="https://blog.yumaojun.net/2017/02/19/go-crypto/" target="_blank" rel="noopener">密码学简介与 Golang 的加密库 Crypto 的使用 | 紫川秀的博客</a></li>
<li><a href="https://learnku.com/docs/build-web-application-with-golang/096-encryption-and-decryption-of-data/3214" target="_blank" rel="noopener">加密和解密数据 - Go Web 编程 | LearnKu</a></li>
<li><a href="https://studygolang.com/articles/10134" target="_blank" rel="noopener">常见的加密算法 | Go 语言中文网</a></li>
<li><a href="https://blog.csdn.net/wade3015/article/details/84454836" target="_blank" rel="noopener">Golang 常用加密解密算法总结 (AES、DES、RSA、Sha1MD5) | CSDN</a></li>
</ul>
<h4 id="Go-Web-框架"><a href="#Go-Web-框架" class="headerlink" title="Go Web 框架"></a>Go Web 框架</h4><blockquote>
<ol>
<li><a href="https://studygolang.com/articles/11897?fr=sidebar" target="_blank" rel="noopener">6 款最棒的 Go 语言 Web 框架简介 | Go 语言中文网</a></li>
</ol>
</blockquote>
<h4 id="Vue-Element"><a href="#Vue-Element" class="headerlink" title="Vue + Element"></a>Vue + Element</h4><blockquote>
<ol>
<li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/" target="_blank" rel="noopener">vue-element-admin | A magical vue admin</a></li>
<li><a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">vue-element-admin - PanJiaChen | Github</a></li>
<li><a href="https://github.com/PanJiaChen/electron-vue-admin" target="_blank" rel="noopener">electron-vue-admin - PanJiaChen | Github</a></li>
<li><a href="https://github.com/PanJiaChen/vue-admin-template" target="_blank" rel="noopener">vue-admin-template - PanJiaChen | Github</a></li>
<li><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">element - A Vue.js 2.0 UI Toolkit for Web | Github</a></li>
<li><a href="https://github.com/ElementUI/element-starter" target="_blank" rel="noopener">element-starter - ElementUI | Github</a></li>
<li><a href="https://element.eleme.io/#/zh-CN/component/installation" target="_blank" rel="noopener">Element 开发指南</a></li>
</ol>
</blockquote>
<h4 id="Go-Vue"><a href="#Go-Vue" class="headerlink" title="Go + Vue"></a>Go + Vue</h4><blockquote>
<ol>
<li><a href="https://xuchao918.github.io/2019/07/09/Go-Vue-js%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">Go + Vue.js 开发 Web 应用 | 起风了</a></li>
<li><a href="https://studygolang.com/articles/16617" target="_blank" rel="noopener">使用 Golang 的 Gin 框架和 vue 编写 web 应用 | Go 语言中文网</a></li>
<li><a href="https://github.com/tdewolff/go-vue-template" target="_blank" rel="noopener">Go Vue Template - tdewolff | Github</a></li>
<li><a href="https://github.com/mikemintang/gonews" target="_blank" rel="noopener">GoNews - 基于 go+vue 实现的 golang 每日新闻可视化浏览检索平台 | Github</a></li>
<li><a href="https://github.com/mattn/go-vue-example" target="_blank" rel="noopener">go-vue-example - Example App using Go, Vue.js, Element, Axios | Github</a></li>
</ol>
</blockquote>
<h4 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h4><blockquote>
<ol>
<li><a href="https://github.com/asticode/go-astilectron" target="_blank" rel="noopener">go-astilelectron - Build cross platform GUI apps with GO and HTML/JS/CSS (powered by Electron) | Github</a></li>
</ol>
</blockquote>
<h4 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h4><blockquote>
<ol>
<li><a href="https://koa.bootcss.com/" target="_blank" rel="noopener">Koa - 基于 Node.js 平台的下一代 web 开发框架</a></li>
<li><a href="https://chenshenhai.github.io/koa2-note/" target="_blank" rel="noopener">Koa2 进阶学习笔记 | Gitbook</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="noopener">Koa 框架教程 | 阮一峰</a></li>
</ol>
</blockquote>
<h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><blockquote>
<ol>
<li><a href="https://expressjs.com/" target="_blank" rel="noopener">Express | Fast, unopinionated, minimalist web framework for Node.js</a></li>
</ol>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote>
<ol>
<li><a href="https://idoubi.cc/2019/08/11/vscode-dev-go/" target="_blank" rel="noopener">「分分钟上手 VS Code」打造 Go 开发环境 | 艾逗笔</a></li>
<li><a href="http://kodango.com/article-series" target="_blank" rel="noopener">连载文章 | 团子的小窝</a></li>
<li><a href="https://truewebartisans.com/posts/2019/05/native-macos-app-on-golang-and-react/" target="_blank" rel="noopener">Creating a native macOS app on Golang and React.js with full code protection | TrueWebArtisans</a></li>
</ol>
</blockquote>
<div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://abelsu7.top/2019/11/10/gops-intro/">gops：Go 程序查看和诊断分析工具简介</a></li><li><a href="https://abelsu7.top/2019/11/01/using-gogs-as-git-server/">使用 Gogs 自建 Git 服务</a></li><li><a href="https://abelsu7.top/2019/10/31/go-gin-swagger/">在 Gin 中使用 swaggo 自动生成 RESTful API 文档</a></li><li><a href="https://abelsu7.top/2019/10/24/go-build-compress-using-upx/">使用 upx 压缩 go build 打包的可执行文件</a></li><li><a href="chunlife.top/2019/06/19/转载《Go语言interface底层实现》/">转载《Go语言interface底层实现》</a></li><li><a href="www.chunlife.top/2019/06/19/转载《Go语言interface底层实现》/">转载《Go语言interface底层实现》</a></li></ul></div>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-10-24T15:20:01.010Z" itemprop="dateUpdated">2019-10-24 23:20:01</time>
</span><br>


        
        文章发布地址：<a href="/2019/08/15/go-web-programming/" target="_blank" rel="external">https://abelsu7.top/2019/08/15/go-web-programming/</a>
        
    </div>
    
    <footer>
        <a href="https://abelsu7.top">
            <img src="/img/fong.jpg" alt="Abel Su">
            Abel Su
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web-开发/">Web 开发</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://abelsu7.top/2019/08/15/go-web-programming/&title=《Go Web 编程笔记》 — Keep Coding&pic=https://abelsu7.top/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://abelsu7.top/2019/08/15/go-web-programming/&title=《Go Web 编程笔记》 — Keep Coding&source=
Go Web Programming Notes. To Be Updated…


                
                ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://abelsu7.top/2019/08/15/go-web-programming/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Go Web 编程笔记》 — Keep Coding&url=https://abelsu7.top/2019/08/15/go-web-programming/&via=https://abelsu7.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://abelsu7.top/2019/08/15/go-web-programming/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/08/18/go-tour-notes/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Go Tour 笔记</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/08/11/kvm-api-overview/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Kernel 2.6.32 中的 KVM API 概述</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment v" id="vcomments"></div>
    <!-- <div class="comment" id="comment"></div> -->
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
    <!-- <script src="//t1.aixinxi.net/o_1c3n4pim01nl3jg91b6l1kjtkvsa.js"></script> -->
    <!-- <script src="/js/Valine.min.js"></script> -->
    <!-- <script src="https://cdnjs.cat.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script> -->
    <script src="//cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            av: AV,
            // el: '#comments',
            el: '#vcomments',
            emoticon_url: 'https://abelsu7.top/alu', //表情图片网址
            emoticon_list: ["赞一个.png","坐等.png","长草.png","阴暗.png","邪恶.png","小眼睛.png","想一想.png","献黄瓜.png","献花.png","喜极而泣.png","无语.png","无所谓.png","无奈.png","投降.png","深思.png","期待.png","狂汗.png","蜡烛.png","看不见.png","惊喜.png","击掌.png","欢呼.png","得意.png","不出所料.png","观察.png"],//表情图片文件名
            // notify: 'false' == 'false',
            // verify: 'false' == 'false',
            // notify: 'false',
            // verify: 'false',
            notify: false,
            verify: false,
            appId: "aP2YQo0mfrRpTLrLb1bchILb-gzGzoHsz",
            appKey: "Cp82umQdGScRRFUYLmob6yyK",
            avatar: "mp",
            placeholder: "Write a comment",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->











</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-item switch">切换</span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                Abel Su &copy;
                    
                        2018 -
                            
                                2019
            </span>
            <span>
                
                    <a href="http://beian.miit.gov.cn/" target="_blank">
                        粤ICP备16068788号-2
                    </a>
                    <br>
                    
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://abelsu7.top/2019/08/15/go-web-programming/&title=《Go Web 编程笔记》 — Keep Coding&pic=https://abelsu7.top/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://abelsu7.top/2019/08/15/go-web-programming/&title=《Go Web 编程笔记》 — Keep Coding&source=
Go Web Programming Notes. To Be Updated…


                
                ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://abelsu7.top/2019/08/15/go-web-programming/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Go Web 编程笔记》 — Keep Coding&url=https://abelsu7.top/2019/08/15/go-web-programming/&via=https://abelsu7.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://abelsu7.top/2019/08/15/go-web-programming/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACIUlEQVR42u3aQW4cMQwEwP3/pzdATgHijLspxcBKpZOxGM+odCBIka9XvN6/V/LLn6v9/e9nNi8MDIyPZSSvW2Ekb9hAxcDAuIDxHGTzZ57DZXtAyXcxMDAwnrf4XlgJDAMDA2NXwJ2lg88HgYGBgTErYvNNz575oVocAwPjAxltY+An//6P/Q0MDIwPYewqQfNULz+aYicYGBhHM/IL/TbWJaFzliZGW8HAwDiUkQe+9jNt2M2D9RcBFwMD41BGdO1ebmgluA8bAxgYGIcyZk3KnJGXu88N0W/wGBgYFzBmH2jHLJJEcHb1hoGBcQMjH9vKg2w7QrECw8DAuJPRhstd7clZwoqBgXEDY9YASJLCNrC2BfCrPRsMDIwjGCvhNS9xZ0MeUS2OgYFxNGM2QjFrfD6npEma+M+Ai4GBcSijfd2Ml49i1EeGgYFxMSOvENsCNUk9i7QSAwPjaEaewM02lF+3ta0CDAyMmxn50OquxHFlWBYDA+MeRp7wrVy6zRLNohjGwMC4gDEbvMg/1rZI61QVAwPjaEa78iu2vHxtv/5aXxgYGB/CeJdrljgmITs/lC/+CwMD42jGLMy1iWNblOZjYRgYGPcw2iZikuTtGqTIW6cYGBg3MJIgu6udMEvsvnk/BgYGRjmkNWswLOWzGBgYGEEyt7cZWV+uYWBgXMDYGyJXOoxLN4IYGBiHMlYaA3lBm1+otceBgYFxNOMXW66odqFoiDgAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
