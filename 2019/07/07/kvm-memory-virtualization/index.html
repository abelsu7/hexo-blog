<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?c61262c25ca5d4ed66df331a31b5bf49"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="cc3c_UncRv21aEZwqejVxKpUMR7h9ldNUTeYjawUS-g">
    
    
    <meta name="baidu-site-verification" content="HnoV7q61W5">
    
    
    
    <title>QEMU 内存虚拟化源码分析 | Keep Coding | 苏易北</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="KVM,虚拟化,QEMU">
    <meta name="description" content="基于 QEMU 1.2.0、Kernel 2.6.32">
<meta name="keywords" content="KVM,虚拟化,QEMU">
<meta property="og:type" content="article">
<meta property="og:title" content="QEMU 内存虚拟化源码分析">
<meta property="og:url" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/index.html">
<meta property="og:site_name" content="Keep Coding">
<meta property="og:description" content="基于 QEMU 1.2.0、Kernel 2.6.32">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/cover.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/page-table.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/gva-to-hva.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/spt.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/ept.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/ram_list.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/as-mr-ramblock.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/memory-map.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/flat-view.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/mermaid-1.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/mermaid-2.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/flat-view.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/mermaid-3.png">
<meta property="og:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/mermaid-4.png">
<meta property="og:updated_time" content="2019-11-05T03:29:36.795Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="QEMU 内存虚拟化源码分析">
<meta name="twitter:description" content="基于 QEMU 1.2.0、Kernel 2.6.32">
<meta name="twitter:image" content="https://abelsu7.top/2019/07/07/kvm-memory-virtualization/cover.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="Keep Coding" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/back_blue.png)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/fong.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Abel Su</h5>
          <a href="mailto:abelsu7@gmail.com" title="abelsu7@gmail.com" class="mail">abelsu7@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://notes.abelsu7.top"  >
                <i class="icon icon-lg icon-sticky-note"></i>
                笔记
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/abelsu7"  >
                <i class="icon icon-lg icon-github"></i>
                代码
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends/"  >
                <i class="icon icon-lg icon-user"></i>
                友链
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/bookmarks/"  >
                <i class="icon icon-lg icon-bookmark"></i>
                收藏
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/books/"  >
                <i class="icon icon-lg icon-book"></i>
                读书
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/movies/"  >
                <i class="icon icon-lg icon-film"></i>
                影视
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/games/"  >
                <i class="icon icon-lg icon-gamepad"></i>
                游戏
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://notes.abelsu7.top/#/links/wechat"  >
                <i class="icon icon-lg icon-wechat"></i>
                微信
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/2018/09/21/how-to-learn-coding/"  >
                <i class="icon icon-lg icon-code"></i>
                学习
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/wiki/"  >
                <i class="icon icon-lg icon-sort-alpha-asc"></i>
                速查
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about/"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">QEMU 内存虚拟化源码分析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">QEMU 内存虚拟化源码分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-07-07T13:34:40.000Z" itemprop="datePublished" class="page-time">
  2019-07-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/KVM/">KVM</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-内存虚拟化概述"><span class="post-toc-text">1. 内存虚拟化概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-Overview"><span class="post-toc-text">1.1 Overview</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-传统的地址转换"><span class="post-toc-text">1.2 传统的地址转换</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-QEMU-的内存结构"><span class="post-toc-text">1.3 QEMU 的内存结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-1-影子页表"><span class="post-toc-text">1.3.1 影子页表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-2-EPT-硬件加速"><span class="post-toc-text">1.3.2 EPT 硬件加速</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-QEMU-的主要工作"><span class="post-toc-text">1.4 QEMU 的主要工作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-QEMU-和-KVM-的工作分界"><span class="post-toc-text">1.5 QEMU 和 KVM 的工作分界</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-相关数据结构"><span class="post-toc-text">2. 相关数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-AddressSpace"><span class="post-toc-text">2.1 AddressSpace</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-1-结构体定义"><span class="post-toc-text">2.1.1 结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-2-全局变量"><span class="post-toc-text">2.1.2 全局变量</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-MemoryRegion"><span class="post-toc-text">2.2 MemoryRegion</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-1-结构体定义"><span class="post-toc-text">2.2.1 结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-2-全局变量"><span class="post-toc-text">2.2.2 全局变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-3-MemoryRegion-的类型"><span class="post-toc-text">2.2.3 MemoryRegion 的类型</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-3-RAMBlock"><span class="post-toc-text">2.3 RAMBlock</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-1-结构体定义"><span class="post-toc-text">2.3.1 结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-2-全局变量-ram-list"><span class="post-toc-text">2.3.2 全局变量 ram_list</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-3-AS、MR、RAMBlock-之间的关系"><span class="post-toc-text">2.3.3 AS、MR、RAMBlock 之间的关系</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-FlatView"><span class="post-toc-text">2.4 FlatView</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-1-结构体定义"><span class="post-toc-text">2.4.1 结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-2-FlatRange"><span class="post-toc-text">2.4.2 FlatRange</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5-MemoryRegionSection"><span class="post-toc-text">2.5 MemoryRegionSection</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5-1-结构体定义"><span class="post-toc-text">2.5.1 结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5-2-和其他数据结构之间的关系"><span class="post-toc-text">2.5.2 和其他数据结构之间的关系</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-6-KVM-相关"><span class="post-toc-text">2.6 KVM 相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-6-1-KVMSlot"><span class="post-toc-text">2.6.1 KVMSlot</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-6-2-kvm-userspace-memory-region"><span class="post-toc-text">2.6.2 kvm_userspace_memory_region</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-7-MemoryListener"><span class="post-toc-text">2.7 MemoryListener</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-7-1-结构体定义"><span class="post-toc-text">2.7.1 结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-7-2-全局变量-memory-listeners"><span class="post-toc-text">2.7.2 全局变量 memory_listeners</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-8-重要数据结构总览"><span class="post-toc-text">2.8 重要数据结构总览</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-8-1-数据结构及其含义总览"><span class="post-toc-text">2.8.1 数据结构及其含义总览</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-8-2-全局变量总览"><span class="post-toc-text">2.8.2 全局变量总览</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-具体实现机制"><span class="post-toc-text">3. 具体实现机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-回调函数的注册"><span class="post-toc-text">3.1 回调函数的注册</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-AddressSpace-的初始化"><span class="post-toc-text">3.2 AddressSpace 的初始化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-实际内存的分配"><span class="post-toc-text">3.3 实际内存的分配</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-总结一下"><span class="post-toc-text">4. 总结一下</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-1-QEMU-侧"><span class="post-toc-text">4.1 QEMU 侧</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-KVM-侧"><span class="post-toc-text">4.2 KVM 侧</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文章"><span class="post-toc-text">参考文章</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#干货"><span class="post-toc-text">干货</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#阿里云-Bozh"><span class="post-toc-text">阿里云 Bozh</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#太初有道"><span class="post-toc-text">太初有道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OenHan"><span class="post-toc-text">OenHan</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#KVM-虚拟化"><span class="post-toc-text">KVM 虚拟化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#其他"><span class="post-toc-text">其他</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#leoufung"><span class="post-toc-text">leoufung</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#论文-and-PPT"><span class="post-toc-text">论文 and PPT</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#intel-白皮书"><span class="post-toc-text">intel 白皮书</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#EPT-amp-MMU"><span class="post-toc-text">EPT &amp; MMU</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Patchwork"><span class="post-toc-text">Patchwork</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#常用网站"><span class="post-toc-text">常用网站</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#肖光荣-Fast-Write-Protect-v1"><span class="post-toc-text">肖光荣 Fast Write Protect-v1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#肖光荣-Fast-Write-Protect-v2"><span class="post-toc-text">肖光荣 Fast Write Protect-v2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Mailing-List"><span class="post-toc-text">Mailing List</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#patch-教程"><span class="post-toc-text">patch 教程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#升级内核"><span class="post-toc-text">升级内核</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内存虚拟化基础"><span class="post-toc-text">内存虚拟化基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#地址空间"><span class="post-toc-text">地址空间</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#mmap"><span class="post-toc-text">mmap</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#QEMU-部分"><span class="post-toc-text">QEMU 部分</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#KVM-部分"><span class="post-toc-text">KVM 部分</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#其他-1"><span class="post-toc-text">其他</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-kvm-memory-virtualization"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">QEMU 内存虚拟化源码分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-07-07 21:34:40" datetime="2019-07-07T13:34:40.000Z"  itemprop="datePublished">2019-07-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/KVM/">KVM</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p><strong><em>基于 <a href="https://elixir.bootlin.com/qemu/v1.2.0/source" target="_blank" rel="noopener">QEMU 1.2.0</a>、<a href="https://elixir.bootlin.com/linux/v2.6.32/source/arch" target="_blank" rel="noopener">Kernel 2.6.32</a></em></strong></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/cover.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<a id="more"></a>
<h2 id="1-内存虚拟化概述"><a href="#1-内存虚拟化概述" class="headerlink" title="1. 内存虚拟化概述"></a>1. 内存虚拟化概述</h2><h3 id="1-1-Overview"><a href="#1-1-Overview" class="headerlink" title="1.1 Overview"></a>1.1 Overview</h3><p>QEMU-KVM 的内存虚拟化是由 QEMU 和 KVM 二者共同实现的，其本质上是一个<strong>将 Guest 虚拟内存转换成 Host 物理内存</strong>的过程。概括来看，主要有以下几点：</p>
<ul>
<li>Guest 启动时，由 QEMU 从它的进程地址空间申请内存并分配给 Guest 使用，即<strong>内存的申请是在用户空间完成的</strong></li>
<li>通过 KVM 提供的 API，QEMU 将 Guest 内存的地址信息传递并注册到 KVM 中维护，即<strong>内存的管理是由内核空间的 KVM 实现的</strong></li>
<li>整个转换过程涉及 <strong>GVA、GPA、HVA、HPA</strong> 四种地址，<strong>Guest 的物理地址空间从 QEMU 的虚拟地址空间中分配</strong></li>
<li>内存虚拟化的关键在于<strong>维护 GPA 到 HVA 的映射关系</strong>，Guest 使用的依然是 Host 的物理内存</li>
</ul>
<h3 id="1-2-传统的地址转换"><a href="#1-2-传统的地址转换" class="headerlink" title="1.2 传统的地址转换"></a>1.2 传统的地址转换</h3><p>64 位 CPU 上支持 48 位的虚拟地址寻址空间，和 52 位的物理地址寻址空间。Linux 采用 4 级页表机制将<strong>虚拟地址（VA）</strong>转换成<strong>物理地址（PA）</strong>，先从页表的基地址寄存器<code>CR3</code>中读取页表的起始地址，然后加上页号得到对应的页表项，从中取出页的物理地址，加上偏移量就得到 PA。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/page-table.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="1-3-QEMU-的内存结构"><a href="#1-3-QEMU-的内存结构" class="headerlink" title="1.3 QEMU 的内存结构"></a>1.3 QEMU 的内存结构</h3><p>QEMU 利用<code>mmap</code><strong>系统调用</strong>，在进程的虚拟地址空间中<strong>申请连续大小的空间，作为 Guest 的物理内存</strong>。</p>
<p>QEMU 作为 Host 上的一个进程运行，Guest 的每个 vCPU 都是 QEMU 进程的一个子线程。而 <strong>Guest 实际使用的仍是 Host 上的物理内存</strong>，因此对于 Guest 而言，在进行内存寻址时需要完成以下地址转换过程：</p>
<pre><code class="lang-c">  Guest虚拟内存地址(GVA)
          |
    Guest线性地址 
          |
   Guest物理地址(GPA)
          |             Guest
   ------------------
          |             Host
    Host虚拟地址(HVA)
          |
      Host线性地址
          |
    Host物理地址(HPA)
</code></pre>
<p>其中，虚拟地址到线性地址的转换过程可以省略，因此 KVM 的内存寻址主要涉及以下四种地址的转换：</p>
<pre><code class="lang-c">  Guest虚拟内存地址(GVA)
          |
   Guest物理地址(GPA)
          |             Guest
  ------------------
          |             Host
    Host虚拟地址(HVA)
          |
    Host物理地址(HPA)
</code></pre>
<p>其中，<code>GVA-&gt;GPA</code>的映射由 Guest OS 维护，<code>HVA-&gt;HPA</code>的映射由 Host OS 维护，因此<strong>需要一种机制，来维护</strong><code>GPA-&gt;HVA</code><strong>之间的映射关系</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/gva-to-hva.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>常用的实现有<code>SPT(Shadow Page Table)</code>和<code>EPT/NPT</code>，前者通过软件维护影子页表，后者通过硬件特性实现二级映射。</p>
<h4 id="1-3-1-影子页表"><a href="#1-3-1-影子页表" class="headerlink" title="1.3.1 影子页表"></a>1.3.1 影子页表</h4><p>KVM 通过维护记录<code>GVA-&gt;HPA</code>的<strong>影子页表 SPT</strong>，减少了地址转换带来的开销，可以<strong>直接将 GVA 转换为 HPA</strong>。</p>
<p>在软件虚拟化的内存转换中，GVA 到 GPA 的转换通过查询 CR3 寄存器来完成，CR3 中保存了 Guest 的页表基地址，然后载入 MMU 中进行地址转换。</p>
<p>在加入了 SPT 技术后，当 Guest 访问 CR3 时，KVM 会捕获到这个操作<code>EXIT_REASON_CR_ACCESS</code>，之后 KVM 会载入特殊的 CR3 和影子页表，欺骗 Guest 这就是真实的 CR3。之后就和传统的访问内存方式一致，当需要访问物理内存的时候，只会经过一层影子页表的转换。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/spt.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong>影子页表由 KVM 维护</strong>，实际上就是一个 <strong>Guest 页表到 Host 页表的映射</strong>。KVM 会将 Guest 的页表设置为只读，当 Guest OS 对页表进行修改时就会触发 Page Fault，VM-EXIT 到 KVM，之后 KVM 会对 GVA 对应的页表项进行访问权限检查，结合错误码进行判断：</p>
<ul>
<li>如果是 Guest OS 引起的，则将该异常注入回去，Guest OS 将调用自己的缺页处理函数，申请一个 Page，并将 Page 的 GPA 填充到上级页表项中</li>
<li>如果是 Guest OS 的页表和 SPT 不一致引起的，则同步 SPT，根据 Guest 页表和 mmap 映射找到 GPA 到 HVA 的映射关系，然后在 SPT 中增加/更新<code>GVA-HPA</code>表项</li>
</ul>
<p>当 Guest 切换进程时，会把带切换进程的页表基址载入到 Guest 的 CR3 中，导致 VM-EXIT 到 KVM 中。KVM 再通过哈希表找到对应的 SPT，然后加载到机器的 CR3 中。</p>
<p>影子页表的引入，减少了<code>GVA-&gt;HPA</code>的转换开销，但是缺点在于<strong>需要为 Guest 的每个进程都维护一个影子页表</strong>，这将带来很大的内存开销。同时<strong>影子页表的建立是很耗时的</strong>，如果 Guest 的进程过多，将导致影子页表频繁切换。因此 Intel 和 AMD 在此基础上提供了基于硬件的虚拟化技术。</p>
<h4 id="1-3-2-EPT-硬件加速"><a href="#1-3-2-EPT-硬件加速" class="headerlink" title="1.3.2 EPT 硬件加速"></a>1.3.2 EPT 硬件加速</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/ept.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>Intel EPT 技术引入了 <strong>EPT（Extended Page Table）</strong>和 <strong>EPTP（EPT base pointer）</strong>的概念。<strong>EPT</strong> 中维护着 <strong>GPA 到 HPA 的映射</strong>，而 <strong>EPTP</strong> 负责<strong>指向 EPT</strong>。</p>
<p>在 Guest OS 运行时，Guest 对应的 EPT 地址被加载到 EPTP，而 Guest OS 当前运行的进程页表基址被加载到 CR3。于是在进行地址转换时，首先通过 CR3 指向的页表实现 GVA 到 GPA 的转换，再通过 EPTP 指向的 EPT 完成 GPA 到 HPA 的转换。当发生 EPT Page Fault 时，需要 VM-EXIT 到 KVM，更新 EPT。</p>
<ul>
<li>优点：<strong>Guest 的缺页在 Guest OS 内部处理，不会 VM-EXIT 到 KVM 中</strong>。地址转化基本由硬件（MMU）查页表来完成，大大提升了效率，且<strong>只需为 Guest 维护一份 EPT 页表</strong>，减少内存的开销</li>
<li>缺点：两级页表查询，只能寄望于 <strong>TLB 命中</strong></li>
</ul>
<h3 id="1-4-QEMU-的主要工作"><a href="#1-4-QEMU-的主要工作" class="headerlink" title="1.4 QEMU 的主要工作"></a>1.4 QEMU 的主要工作</h3><p>内存虚拟化的目的就是让虚拟机能够无缝的访问内存。有了 Intel EPT 的支持后，CPU 在 VMX non-root 状态时进行内存访问会再做一次 EPT 转换。在这个过程中，QEMU 会负责以下内容：</p>
<ol>
<li>首先需要从自己的进程地址空间中申请内存用于 Guest</li>
<li>需要将上一步中申请到的内存的虚拟地址（HVA）和 Guest 的物理地址之间的映射关系传递给 KVM，即<code>GPA-&gt;HVA</code></li>
<li>需要组织一系列的数据结构来管理虚拟内存空间，并在内存拓扑结构更改时将最新的内存信息同步至 KVM 中</li>
</ol>
<h3 id="1-5-QEMU-和-KVM-的工作分界"><a href="#1-5-QEMU-和-KVM-的工作分界" class="headerlink" title="1.5 QEMU 和 KVM 的工作分界"></a>1.5 QEMU 和 KVM 的工作分界</h3><p>QEMU 和 KVM 之间是通过 KVM 提供的<code>ioctl()</code>接口进行交互的。在内核的<code>kvm_vm_ioctl()</code>中，<strong>设置虚拟机内存</strong>的系统调用为<code>KVM_SET_USER_MEMORY_REGION</code>：</p>
<pre><code class="lang-c">static long kvm_vm_ioctl(struct file *filp,
               unsigned int ioctl, unsigned long arg)
{
    /* ... */
    case KVM_SET_USER_MEMORY_REGION: { // 在 KVM 中注册用户空间传入的内存信息
        struct kvm_userspace_memory_region kvm_userspace_mem;

        r = -EFAULT;
         // 将传入的数据结构复制到内核空间
        if (copy_from_user(&amp;kvm_userspace_mem, argp, sizeof kvm_userspace_mem))
            goto out;

         // 实际进行处理的函数
        r = kvm_vm_ioctl_set_memory_region(kvm, &amp;kvm_userspace_mem, 1);
        if (r)
            goto out;
        break;
    }
    /* ... */
}
</code></pre>
<p>可以看到这里需要传递的参数类型为<code>kvm_userspace_memory_region</code>：</p>
<pre><code class="lang-c">/* for KVM_SET_USER_MEMORY_REGION */
struct kvm_userspace_memory_region {
    __u32 slot;            // slot 编号
    __u32 flags;           // 标志位，例如是否追踪脏页、是否可用等
    __u64 guest_phys_addr; // Guest 物理地址，即 GPA
    __u64 memory_size;     // 内存大小，单位 bytes
    __u64 userspace_addr;  // 从 QEMU 进程地址空间中分配内存的起始地址，即 HVA
};
</code></pre>
<p><code>KVM_SET_USER_MEMORY_REGION</code>这个 ioctl 主要目的就是设置<code>GPA-&gt;HVA</code>的映射关系，KVM 会继续调用<code>kvm_vm_ioctl_set_memory_region()</code>，在内核空间维护并管理 Guest 的内存。</p>
<h2 id="2-相关数据结构"><a href="#2-相关数据结构" class="headerlink" title="2. 相关数据结构"></a>2. 相关数据结构</h2><h3 id="2-1-AddressSpace"><a href="#2-1-AddressSpace" class="headerlink" title="2.1 AddressSpace"></a>2.1 AddressSpace</h3><h4 id="2-1-1-结构体定义"><a href="#2-1-1-结构体定义" class="headerlink" title="2.1.1 结构体定义"></a>2.1.1 结构体定义</h4><p>QEMU 用 AddressSpace 结构体表示 Guest 中 CPU/设备看到的内存，类似于物理机中<strong>地址空间</strong>的概念，但在这里表示的是 Guest 的一段地址空间，如内存地址空间<code>address_space_memory</code>、I/O 地址空间<code>address_space_io</code>，它在 QEMU 源码<code>memory.c</code>中定义：</p>
<pre><code class="lang-c">/* A system address space - I/O, memory, etc. */
struct AddressSpace {
    MemoryRegion *root;   // 根级 MemoryRegion
    FlatView current_map; // 对应的平面展开视图 FlatView
    int ioeventfd_nb;
    MemoryRegionIoeventfd *ioeventfds;
};
</code></pre>
<p>每个 AddressSpace 一般包含一系列的 MemoryRegion：<code>root</code>指针指向根级 MemoryRegion，而<code>root</code>可能有自己的若干个 subregions，于是形成<strong>树状结构</strong>。这些 MemoryRegion 通过树连接起来，树的根即为 AddressSpace 的<code>root</code>域。</p>
<h4 id="2-1-2-全局变量"><a href="#2-1-2-全局变量" class="headerlink" title="2.1.2 全局变量"></a>2.1.2 全局变量</h4><p>另外，QEMU 中有两个全局的静态 AddressSpace，在<code>memory.c</code>中定义：</p>
<pre><code class="lang-c">static AddressSpace address_space_memory; // 内存地址空间
static AddressSpace address_space_io;     // I/O 地址空间
</code></pre>
<p>其<code>root</code>域分别指向之后会提到的两个 MemoryRegion 类型变量：<code>system_memory</code>、<code>system_io</code>。</p>
<h3 id="2-2-MemoryRegion"><a href="#2-2-MemoryRegion" class="headerlink" title="2.2 MemoryRegion"></a>2.2 MemoryRegion</h3><h4 id="2-2-1-结构体定义"><a href="#2-2-1-结构体定义" class="headerlink" title="2.2.1 结构体定义"></a>2.2.1 结构体定义</h4><p>MemoryRegion 表示在 Guest Memory Layout 中的一段<strong>内存区域</strong>，它是联系 GPA 和 RAMBlocks（描述真实内存）之间的桥梁，在<code>memory.h</code>中定义：</p>
<pre><code class="lang-c">struct MemoryRegion {
    /* All fields are private - violators will be prosecuted */
    const MemoryRegionOps *ops;      // 回调函数集合
    void *opaque;
    MemoryRegion *parent;            // 父 MemoryRegion 指针
    Int128 size;                     // 该区域内存的大小
    target_phys_addr_t addr;         // 在 Address Space 中的地址，即 HVA
    void (*destructor)(MemoryRegion *mr);
    ram_addr_t ram_addr;             // MemoryRegion 的起始地址，即 GPA
    bool subpage;
    bool terminates;
    bool readable;
    bool ram;                        // 是否表示 RAM
    bool readonly; /* For RAM regions */
    bool enabled;                    // 是否已经通知 KVM 使用这段内存
    bool rom_device;
    bool warning_printed; /* For reservations */
    MemoryRegion *alias;             // 是否为 MemoryRegion alias
    target_phys_addr_t alias_offset; // 若为 alias，在原 MemoryRegion 中的 offset
    unsigned priority;
    bool may_overlap;
    QTAILQ_HEAD(subregions, MemoryRegion) subregions; // 子区域链表头
    QTAILQ_ENTRY(MemoryRegion) subregions_link;       // 子区域链表节点
    QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;
    const char *name;       // MemoryRegion 的名字，调试时使用
    uint8_t dirty_log_mask; // 表示哪一种 dirty map 被使用，共分三种
    unsigned ioeventfd_nb;
    MemoryRegionIoeventfd *ioeventfds;
};
</code></pre>
<h4 id="2-2-2-全局变量"><a href="#2-2-2-全局变量" class="headerlink" title="2.2.2 全局变量"></a>2.2.2 全局变量</h4><p>在 QEMU 的<code>exec.c</code>中也定义了两个静态的 MemoryRegion 指针变量：</p>
<pre><code class="lang-c">static MemoryRegion *system_memory; // 内存 MemoryRegion，对应 address_space_memory
static MemoryRegion *system_io;     // I/O MemoryRegion，对应 address_space_io
</code></pre>
<p>与两个全局 AddressSpace 对应，即 AddressSpace 的<code>root</code>域指向这两个 MemoryRegion。</p>
<h4 id="2-2-3-MemoryRegion-的类型"><a href="#2-2-3-MemoryRegion-的类型" class="headerlink" title="2.2.3 MemoryRegion 的类型"></a>2.2.3 MemoryRegion 的类型</h4><p>MemoryRegion 有多种类型，可以表示一段 RAM、ROM、MMIO、alias。</p>
<p>若为 alias 则表示一个 MemoryRegion 的部分区域，例如 QEMU 会为<code>pc.ram</code>这个表示 RAM 的 MemoryRegion 添加两个 alias：<code>ram-below-4g</code>和<code>ram-above-4g</code>，之后会看到具体的代码实例。</p>
<p>另外，MemoryRegion 也可以表示一个 container，这就表示它只是其他若干个 MemoryRegion 的容器</p>
<p>那么要如何创建不同类型的 MemoryRegion 呢？在 QEMU 中实际上是通过调用不同的初始化函数区分的。根据不同的初始化函数及其功能，可以将 MemoryRegion 划分为以下三种类型：</p>
<ul>
<li><strong>根级 MemoryRegion</strong>：直接通过<code>memory_region_init</code>初始化，没有自己的内存，用于管理 subregion，例如<code>system_memory</code>：</li>
</ul>
<pre><code class="lang-c">void memory_region_init(MemoryRegion *mr,
                        const char *name,
                        uint64_t size)
{
    mr-&gt;ops = NULL;
    mr-&gt;parent = NULL;
    mr-&gt;size = int128_make64(size);
    if (size == UINT64_MAX) {
        mr-&gt;size = int128_2_64();
    }
    mr-&gt;addr = 0;
    mr-&gt;subpage = false;
    mr-&gt;enabled = true;
    mr-&gt;terminates = false; // 非实体 MemoryRegion，搜索时会继续前往其 subregions
    mr-&gt;ram = false;        // 根级 MemoryRegion 不分配内存
    mr-&gt;readable = true;
    mr-&gt;readonly = false;
    mr-&gt;rom_device = false;
    mr-&gt;destructor = memory_region_destructor_none;
    mr-&gt;priority = 0;
    mr-&gt;may_overlap = false;
    mr-&gt;alias = NULL;
    QTAILQ_INIT(&amp;mr-&gt;subregions);
    memset(&amp;mr-&gt;subregions_link, 0, sizeof mr-&gt;subregions_link);
    QTAILQ_INIT(&amp;mr-&gt;coalesced);
    mr-&gt;name = g_strdup(name);
    mr-&gt;dirty_log_mask = 0;
    mr-&gt;ioeventfd_nb = 0;
    mr-&gt;ioeventfds = NULL;
}
</code></pre>
<p>可以看到<code>mr-&gt;addr</code>被设置为 0，而<code>mr-&gt;ram_addr</code>则并没有初始化。</p>
<ul>
<li><strong>实体 MemoryRegion</strong>：通过<code>memory_region_init_ram()</code>初始化，有自己的内存（从 QEMU 进程地址空间中分配），大小为<code>size</code>，例如<code>ram_memory</code>、<code>pci_memory</code>：</li>
</ul>
<pre><code class="lang-c">void *pc_memory_init(MemoryRegion *system_memory,
                    const char *kernel_filename,
                    const char *kernel_cmdline,
                    const char *initrd_filename,
                    ram_addr_t below_4g_mem_size,
                    ram_addr_t above_4g_mem_size,
                    MemoryRegion *rom_memory,
                    MemoryRegion **ram_memory)
{
    MemoryRegion *ram, *option_rom_mr;
    /* ...*/

    /* Allocate RAM.  We allocate it as a single memory region and use
     * aliases to address portions of it, mostly for backwards compatibility
     * with older qemus that used qemu_ram_alloc().
     */
    ram = g_malloc(sizeof(*ram));
    // 调用 memory_region_init_ram 对 ram_memory 进行初始化
    memory_region_init_ram(ram, &quot;pc.ram&quot;, below_4g_mem_size + above_4g_mem_size);
    vmstate_register_ram_global(ram);
    *ram_memory = ram;

    /* ... */
}
</code></pre>
<pre><code class="lang-c">void memory_region_init_ram(MemoryRegion *mr,
                            const char *name,
                            uint64_t size)
{
    memory_region_init(mr, name, size);
    mr-&gt;ram = true;
    mr-&gt;terminates = true;
    mr-&gt;destructor = memory_region_destructor_ram;
    mr-&gt;ram_addr = qemu_ram_alloc(size, mr);
}
</code></pre>
<p>可以看到这里是先调用了<code>memory_region_init()</code>，之后设置 RAM 属性，并继续调用<code>qemu_ram_alloc()</code>分配内存。</p>
<ul>
<li><strong>别名 MemoryRegion</strong>：通过<code>memory_region_init_alias()</code> 初始化，没有自己的内存，表示实体 MemoryRegion 的一部分。通过 alias 成员指向实体 MemoryRegion，<code>alias_offset</code>为在实体 MemoryRegion 中的偏移量，例如<code>ram_below_4g</code>、<code>ram_above_4g</code>：</li>
</ul>
<pre><code class="lang-c">void *pc_memory_init(MemoryRegion *system_memory,
                    const char *kernel_filename,
                    const char *kernel_cmdline,
                    const char *initrd_filename,
                    ram_addr_t below_4g_mem_size,
                    ram_addr_t above_4g_mem_size,
                    MemoryRegion *rom_memory,
                    MemoryRegion **ram_memory)
{
    MemoryRegion *ram_below_4g, *ram_above_4g;
    /* ... */
    ram_below_4g = g_malloc(sizeof(*ram_below_4g));
    // 调用 memory_region_init_alias 对 ram_below_4g 进行初始化
    memory_region_init_alias(ram_below_4g, &quot;ram-below-4g&quot;, ram, 0, below_4g_mem_size);
    /* ... */
}
</code></pre>
<pre><code class="lang-c">void memory_region_init_alias(MemoryRegion *mr,
                              const char *name,
                              MemoryRegion *orig,
                              target_phys_addr_t offset,
                              uint64_t size)
{
    memory_region_init(mr, name, size);
    mr-&gt;alias = orig; // 指向实体 MemoryRegion
    mr-&gt;alias_offset = offset;
}
</code></pre>
<h3 id="2-3-RAMBlock"><a href="#2-3-RAMBlock" class="headerlink" title="2.3 RAMBlock"></a>2.3 RAMBlock</h3><h4 id="2-3-1-结构体定义"><a href="#2-3-1-结构体定义" class="headerlink" title="2.3.1 结构体定义"></a>2.3.1 结构体定义</h4><p>MemoryRegion 用来描述一段逻辑层面上的内存区域，而<strong>记录实际分配的内存地址信息</strong>的结构体则是 <strong>RAMBlock</strong>，在<code>cpu-all.h</code>中定义：</p>
<pre><code class="lang-c">typedef struct RAMBlock {
    struct MemoryRegion *mr;    // 唯一对应的 MemoryRegion
    uint8_t *host;              // RAMBlock 关联的内存，即 HVA
    ram_addr_t offset;          // RAMBlock 在 VM 物理内存中的偏移量，即 GPA
    ram_addr_t length;          // RAMBlock 的长度
    uint32_t flags;
    char idstr[256];            // RAMBlock 的 id
    QLIST_ENTRY(RAMBlock) next; // 指向下一个 RAMBlock
#if defined(__linux__) &amp;&amp; !defined(TARGET_S390X)
    int fd;
#endif
} RAMBlock;
</code></pre>
<p>可以看到在 RAMBlock 中<code>host</code>和<code>offset</code>域分别对应了 HVA 和 GPA，因此也可以说 <strong>RAMBlock 中存储了</strong><code>GPA-&gt;HVA</code><strong>的映射关系</strong>，另外每一个 RAMBlock 都会指向其所属的 MemoryRegion。</p>
<h4 id="2-3-2-全局变量-ram-list"><a href="#2-3-2-全局变量-ram-list" class="headerlink" title="2.3.2 全局变量 ram_list"></a>2.3.2 全局变量 ram_list</h4><p>QEMU 在<code>cpu-all.h</code>中定义了一个全局变量<code>ram_list</code>，以<strong>链表</strong>的形式维护了所有的 RAMBlock：</p>
<pre><code class="lang-c">typedef struct RAMList {
    uint8_t *phys_dirty;
    QLIST_HEAD(, RAMBlock) blocks;
    uint64_t dirty_pages;
} RAMList;

extern RAMList ram_list;
</code></pre>
<p>每一个新分配的 RAMBlock 都会被插入到<code>ram_list</code>的头部。如需查找地址所对应的 RAMBlock，则需要遍历<code>ram_list</code>，当目标地址落在当前 RAMBlock 的地址区间时，该 RAMBlock 即为查找目标。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/ram_list.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="2-3-3-AS、MR、RAMBlock-之间的关系"><a href="#2-3-3-AS、MR、RAMBlock-之间的关系" class="headerlink" title="2.3.3 AS、MR、RAMBlock 之间的关系"></a>2.3.3 AS、MR、RAMBlock 之间的关系</h4><p>AddressSpace、MemoryRegion、RAMBlock 之间的关系如下所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/as-mr-ramblock.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>可以看到 AddressSpace 的<code>root</code>域指向根级 MemoryRegion，AddressSpace 是由<code>root</code>域指向的 MemoryRegion 及其子树共同表示的。<strong>MemoryRegion 作为一个逻辑层面的内存区域，还需借助分布在其中的 RAMBlock 来存储真实的地址映射关系</strong>。</p>
<p>下图是我根据自己的理解绘制的三者之间的关系图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/memory-map.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如图所示，以<code>address_space_memory</code>为例，其<code>root</code>域对应的 MemoryRegion 为<code>system_memory</code>。<code>system_memory</code>的 subregions 为两个 alias MemoryRegion：<code>ram_below_4g</code>、<code>ram_above_4g</code>，均指向<code>pc.ram</code>这个实体 MemoryRegion。<code>pc.ram</code>的内存实际上通过 RAMBlock 分配，其<code>addr</code>与<code>ram_addr</code>域分别对应了 RAMBlock 的 HVA、GPA。QEMU 从自己的进程地址空间中为该 RAMBlock 分配内存后，将其<code>mr</code>域指向<code>pc.ram</code>，至此就完成了 QEMU 侧的内存分配。</p>
<h3 id="2-4-FlatView"><a href="#2-4-FlatView" class="headerlink" title="2.4 FlatView"></a>2.4 FlatView</h3><p><strong>AddressSpace 的</strong><code>root</code><strong>域及其子树共同构成了 Guest 的物理地址空间</strong>，但这些都是在 QEMU 侧定义的。要传入 KVM 进行设置时，复杂的树状结构是不利于内核进行处理的，因此需要将其转换为一个“平坦”的地址模型，也就是一个从零开始、只包含地址信息的数据结构，这在 QEMU 中通过 <strong>FlatView</strong> 来表示。每个 AddressSpace 都有一个与之对应的 FlatView 指针<code>current_map</code>，表示其对应的<strong>平面展开视图</strong>。</p>
<h4 id="2-4-1-结构体定义"><a href="#2-4-1-结构体定义" class="headerlink" title="2.4.1 结构体定义"></a>2.4.1 结构体定义</h4><p>FlatView 在<code>memory.c</code>中定义：</p>
<pre><code class="lang-c">/* Flattened global view of current active memory hierarchy.  Kept in sorted
 * order.
 */
struct FlatView {
    FlatRange *ranges;     // 对应的 FlatRange 数组
    unsigned nr;           // FlatRange 的数目
    unsigned nr_allocated; // 当前数组的项数
};
</code></pre>
<p>其中，<code>ranges</code>是一个数组，记录了 FlatView 下所有的 FlatRange。</p>
<h4 id="2-4-2-FlatRange"><a href="#2-4-2-FlatRange" class="headerlink" title="2.4.2 FlatRange"></a>2.4.2 FlatRange</h4><p>在 FlatView 中，<strong>FlatRange</strong> 表示在 FlatView 中的一段<strong>内存范围</strong>，同样在<code>memory.c</code>中定义：</p>
<pre><code class="lang-c">/* Range of memory in the global map.  Addresses are absolute. */
struct FlatRange {
    MemoryRegion *mr;                    // 指向所属的 MemoryRegion
    target_phys_addr_t offset_in_region; // 在全局 MemoryRegion 中的 offset，对应 GPA
    AddrRange addr;                      // 代表的地址区间，对应 HVA
    uint8_t dirty_log_mask;
    bool readable;
    bool readonly;
};
</code></pre>
<p>每个 FlatRange 对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，<strong>按照地址的顺序保存在数组中</strong>，具体的地址范围由一个 <strong>AddrRange</strong> 结构来描述：</p>
<pre><code class="lang-c">/*
 * AddrRange 用于表示 FlatRange 的起始地址及大小
 */
struct AddrRange {
    Int128 start;
    Int128 size;
};
</code></pre>
<h3 id="2-5-MemoryRegionSection"><a href="#2-5-MemoryRegionSection" class="headerlink" title="2.5 MemoryRegionSection"></a>2.5 MemoryRegionSection</h3><h4 id="2-5-1-结构体定义"><a href="#2-5-1-结构体定义" class="headerlink" title="2.5.1 结构体定义"></a>2.5.1 结构体定义</h4><p>在 QEMU 中，还有几个起到中介作用的结构体，<strong>MemoryRegionSection</strong> 就是其中之一。</p>
<p>之前介绍的 FlatRange 代表一个物理地址空间的片段，偏向于描述在 Host 侧即 AddressSpace 中的分布，而 MemoryRegionSection 则代表在 Guest 侧即 <strong>MemoryRegion 中的片段</strong>。MemoryRegionSection 在<code>memory.h</code>中定义：</p>
<pre><code class="lang-c">/**
 * MemoryRegionSection: describes a fragment of a #MemoryRegion
 *
 * @mr: the region, or %NULL if empty
 * @address_space: the address space the region is mapped in
 * @offset_within_region: the beginning of the section, relative to @mr&#39;s start
 * @size: the size of the section; will not exceed @mr&#39;s boundaries
 * @offset_within_address_space: the address of the first byte of the section
 *     relative to the region&#39;s address space
 * @readonly: writes to this section are ignored
 */
struct MemoryRegionSection {
    MemoryRegion *mr;                               // 所属的 MemoryRegion
    MemoryRegion *address_space;                    // 关联的 AddressSpace
    target_phys_addr_t offset_within_region;        // 在 MemoryRegion 内部的 offset
    uint64_t size;                                  // Section 的大小
    target_phys_addr_t offset_within_address_space; // 在 AddressSpace 内部的 offset
    bool readonly;                                  // 是否为只读
};
</code></pre>
<ul>
<li><code>offset_within_region</code>：在所属 MemoryRegion 中的 offset。一个 AddressSpace 可能由多个 MemoryRegion 组成，因此该 offset 是局部的</li>
<li><code>offset_within_address_space</code>：在所属 AddressSpace 中的 offset，它是全局的</li>
</ul>
<h4 id="2-5-2-和其他数据结构之间的关系"><a href="#2-5-2-和其他数据结构之间的关系" class="headerlink" title="2.5.2 和其他数据结构之间的关系"></a>2.5.2 和其他数据结构之间的关系</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/flat-view.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>AddressSpace 的<code>root</code>指向对应的根级 MemoryRegion，<code>current_map</code>指向<code>root</code>通过<code>generate_memory_topology()</code>生成的 FlatView</li>
<li>FlatView 中的<code>ranges</code>数组表示该 MemoryRegion 所表示的 Guest 地址区间，并按照地址的顺序进行排列</li>
<li>MemoryRegionSection 由<code>ranges</code>数组中的 FlatRange 对应生成，作为注册到 KVM 中的基本单位</li>
</ul>
<h3 id="2-6-KVM-相关"><a href="#2-6-KVM-相关" class="headerlink" title="2.6 KVM 相关"></a>2.6 KVM 相关</h3><p>QEMU 在用户空间申请内存后，需要将内存信息通过一系列系统调用传入内核空间的 KVM，由 KVM 侧进行管理，因此 QEMU 侧也定义了一些用于向 KVM 传递参数的结构体。</p>
<h4 id="2-6-1-KVMSlot"><a href="#2-6-1-KVMSlot" class="headerlink" title="2.6.1 KVMSlot"></a>2.6.1 KVMSlot</h4><p>在<code>kvm-all.c</code>中定义，是 <strong>KVM 中内存管理的基本单位</strong>：</p>
<pre><code class="lang-c">typedef struct KVMSlot
{
    target_phys_addr_t start_addr; // Guest 物理地址，GPA
    ram_addr_t memory_size;        // 内存大小
    void *ram; // QEMU 用户空间地址，HVA
    int slot;  // Slot 编号
    int flags; // 标志位，例如是否追踪脏页、是否可用等
} KVMSlot;
</code></pre>
<p><strong>KVMSlot</strong> 类似于<strong>内存插槽</strong>的概念，在 KVMState 的定义中可以看到，<strong>最多支持 32 个 KVMSlot</strong>：</p>
<pre><code class="lang-c">struct KVMState
{
    KVMSlot slots[32]; // 最多支持 32 个 KVMSlot
    /* ... */
}

KVMState *kvm_state;
</code></pre>
<h4 id="2-6-2-kvm-userspace-memory-region"><a href="#2-6-2-kvm-userspace-memory-region" class="headerlink" title="2.6.2 kvm_userspace_memory_region"></a>2.6.2 kvm_userspace_memory_region</h4><p>调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 KVM 传递的参数，在<code>kvm.h</code>中定义</p>
<pre><code class="lang-c">/* for KVM_SET_USER_MEMORY_REGION */
struct kvm_userspace_memory_region {
    __u32 slot;            // slot 编号
    __u32 flags;           // 标志位，例如是否追踪脏页、是否可用等
    __u64 guest_phys_addr; // Guest 物理地址，GPA
    __u64 memory_size;     // 内存大小，bytes
    __u64 userspace_addr;  // 从 QEMU 进程空间分配的起始地址，HVA
};
</code></pre>
<h3 id="2-7-MemoryListener"><a href="#2-7-MemoryListener" class="headerlink" title="2.7 MemoryListener"></a>2.7 MemoryListener</h3><h4 id="2-7-1-结构体定义"><a href="#2-7-1-结构体定义" class="headerlink" title="2.7.1 结构体定义"></a>2.7.1 结构体定义</h4><p>为了<strong>监控虚拟机的物理地址访问</strong>，对于每一个 AddressSpace，都会有一个 MemoryListener 与之对应。每当物理映射<code>GPA-&gt;HVA</code>发生改变时，就会回调这些函数。<strong>MemoryListener</strong> 是对一些事件的<strong>回调函数合集</strong>，在<code>memory.h</code>中定义：</p>
<pre><code class="lang-c">/**
 * MemoryListener: callbacks structure for updates to the physical memory map
 *
 * Allows a component to adjust to changes in the guest-visible memory map.
 * Use with memory_listener_register() and memory_listener_unregister().
 */
struct MemoryListener {
    void (*begin)(MemoryListener *listener);
    void (*commit)(MemoryListener *listener);
    void (*region_add)(MemoryListener *listener, MemoryRegionSection *section);
    void (*region_del)(MemoryListener *listener, MemoryRegionSection *section);
    void (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);
    void (*log_start)(MemoryListener *listener, MemoryRegionSection *section);
    void (*log_stop)(MemoryListener *listener, MemoryRegionSection *section);
    void (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);
    void (*log_global_start)(MemoryListener *listener);
    void (*log_global_stop)(MemoryListener *listener);
    void (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,
                        bool match_data, uint64_t data, EventNotifier *e);
    void (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,
                        bool match_data, uint64_t data, EventNotifier *e);
    /* Lower = earlier (during add), later (during del) */
    unsigned priority;
    MemoryRegion *address_space_filter;
    QTAILQ_ENTRY(MemoryListener) link;
};
</code></pre>
<h4 id="2-7-2-全局变量-memory-listeners"><a href="#2-7-2-全局变量-memory-listeners" class="headerlink" title="2.7.2 全局变量 memory_listeners"></a>2.7.2 全局变量 memory_listeners</h4><p>所有的 MemoryListener 都会挂在全局变量<code>memory_listeners</code>链表上，在<code>memory.c</code>中定义：</p>
<pre><code class="lang-c">static QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners
    = QTAILQ_HEAD_INITIALIZER(memory_listeners);
</code></pre>
<p>在<code>memory.c</code>中枚举了 ListenerDireciton：</p>
<pre><code class="lang-c">enum ListenerDirection { Forward, Reverse };
</code></pre>
<p>另外，<code>system_memory</code>、<code>system_io</code>这两个全局 MemoryRegion 分别注册了<code>core_memory_listener</code>和<code>io_memory_listener</code>，在<code>exec.c</code>中定义：</p>
<pre><code class="lang-c">// 对应 system_memory 这个 MemoryRegion
static MemoryListener core_memory_listener = {
    .begin = core_begin,
    .commit = core_commit,
    .region_add = core_region_add,
    .region_del = core_region_del,
    .region_nop = core_region_nop,
    .log_start = core_log_start,
    .log_stop = core_log_stop,
    .log_sync = core_log_sync,
    .log_global_start = core_log_global_start,
    .log_global_stop = core_log_global_stop,
    .eventfd_add = core_eventfd_add,
    .eventfd_del = core_eventfd_del,
    .priority = 0,
};

// 对应 system_io 这个 MemoryRegion
static MemoryListener io_memory_listener = {
    .begin = io_begin,
    .commit = io_commit,
    .region_add = io_region_add,
    .region_del = io_region_del,
    .region_nop = io_region_nop,
    .log_start = io_log_start,
    .log_stop = io_log_stop,
    .log_sync = io_log_sync,
    .log_global_start = io_log_global_start,
    .log_global_stop = io_log_global_stop,
    .eventfd_add = io_eventfd_add,
    .eventfd_del = io_eventfd_del,
    .priority = 0,
};
</code></pre>
<p>除此之外，QEMU 还在全局注册了<code>kvm_memory_listener</code>，在<code>kvm-all.c</code>中定义，用于<strong>将 QEMU 侧内存拓扑结构的改动同步更新至 KVM 中</strong>：</p>
<pre><code class="lang-c">// 同时监听 system_memory、system_io
static MemoryListener kvm_memory_listener = {
    .begin = kvm_begin,
    .commit = kvm_commit,
    .region_add = kvm_region_add,
    .region_del = kvm_region_del,
    .region_nop = kvm_region_nop,
    .log_start = kvm_log_start,
    .log_stop = kvm_log_stop,
    .log_sync = kvm_log_sync,
    .log_global_start = kvm_log_global_start,
    .log_global_stop = kvm_log_global_stop,
    .eventfd_add = kvm_eventfd_add,
    .eventfd_del = kvm_eventfd_del,
    .priority = 10,
};
</code></pre>
<h3 id="2-8-重要数据结构总览"><a href="#2-8-重要数据结构总览" class="headerlink" title="2.8 重要数据结构总览"></a>2.8 重要数据结构总览</h3><h4 id="2-8-1-数据结构及其含义总览"><a href="#2-8-1-数据结构及其含义总览" class="headerlink" title="2.8.1 数据结构及其含义总览"></a>2.8.1 数据结构及其含义总览</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">结构体名</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AddressSpace</td>
<td style="text-align:center">memory.c</td>
<td style="text-align:center">VM 能看到的一段地址空间，偏向 Host 侧</td>
</tr>
<tr>
<td style="text-align:center">MemoryRegion</td>
<td style="text-align:center">memory.h</td>
<td style="text-align:center">地址空间中一段逻辑层面的内存区域，偏向 Guest 侧</td>
</tr>
<tr>
<td style="text-align:center">RAMBlock</td>
<td style="text-align:center">cpu-all.h</td>
<td style="text-align:center">记录实际分配的内存地址信息，存储了<code>GPA-&gt;HVA</code>的映射关系</td>
</tr>
<tr>
<td style="text-align:center">FlatView</td>
<td style="text-align:center">memory.c</td>
<td style="text-align:center">MemoryRegion 对应的平面展开视图，包含一个 FlatRange 类型的 ranges 数组</td>
</tr>
<tr>
<td style="text-align:center">FlatRange</td>
<td style="text-align:center">memory.c</td>
<td style="text-align:center">对应一段虚拟机物理地址区间，各个 FlatRange 不会重叠，按照地址的顺序保存在数组中</td>
</tr>
<tr>
<td style="text-align:center">MemoryRegionSection</td>
<td style="text-align:center">memory.h</td>
<td style="text-align:center">表示 MemoryRegion 中的片段</td>
</tr>
<tr>
<td style="text-align:center">MemoryListener</td>
<td style="text-align:center">memory.h</td>
<td style="text-align:center">回调函数集合</td>
</tr>
<tr>
<td style="text-align:center">KVMSlot</td>
<td style="text-align:center">kvm-all.c</td>
<td style="text-align:center">KVM 中内存管理的基本单位，表示一个内存插槽</td>
</tr>
<tr>
<td style="text-align:center">kvm_userspace_memory_region</td>
<td style="text-align:center">kvm.h</td>
<td style="text-align:center">调用<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>时需要向 KVM 传递的参数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-8-2-全局变量总览"><a href="#2-8-2-全局变量总览" class="headerlink" title="2.8.2 全局变量总览"></a>2.8.2 全局变量总览</h4><ul>
<li>两个 static AddressSpace，在<code>memory.c</code>中定义：</li>
</ul>
<pre><code class="lang-c">static AddressSpace address_space_memory; // 内存地址空间，对应 system_memory
static AddressSpace address_space_io;     // I/O 地址空间，对应 system_io
</code></pre>
<ul>
<li>两个 static MemoryRegion 指针，在<code>exec.c</code>中定义：</li>
</ul>
<pre><code class="lang-c">static MemoryRegion *system_memory; // 用于管理内存 subregion 的根级 MemoryRegion
static MemoryRegion *system_io;     // 用于管理 I/O subregion 的根级 MemoryRegion
</code></pre>
<ul>
<li>一个 RAMList，在<code>exec.c</code>中定义：</li>
</ul>
<pre><code class="lang-c">RAMList ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) }; // 用于管理全局的 RAMBlock
</code></pre>
<ul>
<li>一个 MemoryListener 全局链表，在<code>memory.c</code>中定义</li>
</ul>
<pre><code class="lang-c">static QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners
    = QTAILQ_HEAD_INITIALIZER(memory_listeners);
</code></pre>
<ul>
<li>三个 MemoryListener，在<code>exec.c</code>和<code>kvm-all.c</code>中定义：</li>
</ul>
<pre><code class="lang-c">// 对应 system_memory 这个 MemoryRegion
static MemoryListener core_memory_listener = {
    .begin = core_begin,
    .commit = core_commit,
    .region_add = core_region_add,
    .region_del = core_region_del,
    .region_nop = core_region_nop,
    .log_start = core_log_start,
    .log_stop = core_log_stop,
    .log_sync = core_log_sync,
    .log_global_start = core_log_global_start,
    .log_global_stop = core_log_global_stop,
    .eventfd_add = core_eventfd_add,
    .eventfd_del = core_eventfd_del,
    .priority = 0,
};

// 对应 system_io 这个 MemoryRegion
static MemoryListener io_memory_listener = {
    .begin = io_begin,
    .commit = io_commit,
    .region_add = io_region_add,
    .region_del = io_region_del,
    .region_nop = io_region_nop,
    .log_start = io_log_start,
    .log_stop = io_log_stop,
    .log_sync = io_log_sync,
    .log_global_start = io_log_global_start,
    .log_global_stop = io_log_global_stop,
    .eventfd_add = io_eventfd_add,
    .eventfd_del = io_eventfd_del,
    .priority = 0,
};

// 在全局注册，同时监听 system_memory、system_io
static MemoryListener kvm_memory_listener = {
    .begin = kvm_begin,
    .commit = kvm_commit,
    .region_add = kvm_region_add,
    .region_del = kvm_region_del,
    .region_nop = kvm_region_nop,
    .log_start = kvm_log_start,
    .log_stop = kvm_log_stop,
    .log_sync = kvm_log_sync,
    .log_global_start = kvm_log_global_start,
    .log_global_stop = kvm_log_global_stop,
    .eventfd_add = kvm_eventfd_add,
    .eventfd_del = kvm_eventfd_del,
    .priority = 10,
};
</code></pre>
<h2 id="3-具体实现机制"><a href="#3-具体实现机制" class="headerlink" title="3. 具体实现机制"></a>3. 具体实现机制</h2><p><strong>QEMU 的内存申请流程</strong>大致可分为三个部分：<strong>回调函数的注册、AddressSpace 的初始化、实际内存的分配</strong>。下面将根据在<code>vl.c</code>的<code>main()</code>函数中的调用顺序分别介绍。</p>
<h3 id="3-1-回调函数的注册"><a href="#3-1-回调函数的注册" class="headerlink" title="3.1 回调函数的注册"></a>3.1 回调函数的注册</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/mermaid-1.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<pre><code class="lang-c">int main()
  └─ static int configure_accelerator()
       └─ int kvm_init()                                     // 初始化 KVM
            ├─ int kvm_ioctl(KVM_CREATE_VM)                  // 创建 VM
            ├─ int kvm_arch_init()                           // 针对不同的架构进行初始化
            └─ void memory_listener_register()               // 注册 kvm_memory_listener
                 └─ static void listener_add_address_space() // 调用 region_add 回调
                      └─ static void kvm_region_add()        // region_add 对应的回调实现
                           └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot
                                └─ static int kvm_set_user_memory_region()
                                     └─ int ioctl(KVM_SET_USER_MEMORY_REGION)
</code></pre>
<p>进入<code>configure_accelerator()</code>后，QEMU 会先调用<code>configure_accelerator()</code>设置 KVM 的加速支持，之后进入<code>kvm_init()</code>。该函数主要完成对 KVM 的初始化，包括一些常规检查如 CPU 个数、KVM 版本等，之后通过<code>kvm_ioctl(KVM_CREATE_VM)</code>与内核交互，创建 KVM 虚拟机。在<code>kvm_init()</code>的最后，会调用<code>memory_listener_register()</code>注册<code>kvm_memory_listener</code>：</p>
<pre><code class="lang-c">int kvm_init(void)
{
    /* ... */
    s-&gt;vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0); // 创建 VM
    /* ... */
    ret = kvm_arch_init(s); // 针对不同的架构进行初始化
    if (ret &lt; 0) {
        goto err;
    }
    /* ... */
    memory_listener_register(&amp;kvm_memory_listener, NULL); // 注册回调函数
    /* ... */
}
</code></pre>
<p>该注册函数本身并不复杂，结合备注来看：</p>
<pre><code class="lang-c">void memory_listener_register(MemoryListener *listener, MemoryRegion *filter)
{
    MemoryListener *other = NULL;

    listener-&gt;address_space_filter = filter;
    /* 若 memory_listeners 为空或当前 listener 的优先级大于最后一个 listener 的优先级，则直接在末尾插入 */
    if (QTAILQ_EMPTY(&amp;memory_listeners)
        || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners,
                                             memory_listeners)-&gt;priority) {
        QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link);
    } else {
        /* 遍历链表，按照优先级升序排列 */
        QTAILQ_FOREACH(other, &amp;memory_listeners, link) {
            if (listener-&gt;priority &lt; other-&gt;priority) {
                break;
            }
        }
        /* 插入 listener */
        QTAILQ_INSERT_BEFORE(other, listener, link);
    }
    /* 对于以下 AddressSpace，设置其对应的 listener */
    listener_add_address_space(listener, &amp;address_space_memory);
    listener_add_address_space(listener, &amp;address_space_io);
}
</code></pre>
<p>最后的<code>listener_add_address_space()</code>主要是将<code>listener</code>注册到其对应的 AddressSpace 上，并根据 AddressSpace 对应的 FlatRange 数组，生成 MemoryRegionSection，并注册到 KVM 中：</p>
<pre><code class="lang-c">static void listener_add_address_space(MemoryListener *listener,
                                       AddressSpace *as)
{
    FlatRange *fr;

    /* 若非注册的 AddressSpace，直接返回 */
    if (listener-&gt;address_space_filter
        &amp;&amp; listener-&gt;address_space_filter != as-&gt;root) {
        return;
    }

    /* 开启内存脏页记录 */
    if (global_dirty_log) {
        listener-&gt;log_global_start(listener);
    }
    /* 遍历 AddressSpace 对应的 FlatRange 数组，并将其转换成 MemoryRegionSection */
    FOR_EACH_FLAT_RANGE(fr, &amp;as-&gt;current_map) {
        MemoryRegionSection section = {
            .mr = fr-&gt;mr,
            .address_space = as-&gt;root,
            .offset_within_region = fr-&gt;offset_in_region,
            .size = int128_get64(fr-&gt;addr.size),
            .offset_within_address_space = int128_get64(fr-&gt;addr.start),
            .readonly = fr-&gt;readonly,
        };
        /* 将 section 所代表的内存区域注册到 KVM 中 */
        listener-&gt;region_add(listener, &amp;section);
    }
}
</code></pre>
<p>由于此时 AddressSapce 尚未初始化，所以此处的循环为空，仅是在全局注册了<code>kvm_memory_listener</code>。最后调用了<code>kvm_memory_listener-&gt;region_add()</code>，对应的实现是<code>kvm_region_add()</code>，该函数最终会通过<code>ioctl(KVM_SET_USER_MEMORY_REGION)</code>，<strong>将 QEMU 侧申请的内存信息传入 KVM 进行注册</strong>，这里的流程会在下一部分进行分析。</p>
<h3 id="3-2-AddressSpace-的初始化"><a href="#3-2-AddressSpace-的初始化" class="headerlink" title="3.2 AddressSpace 的初始化"></a>3.2 AddressSpace 的初始化</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/mermaid-2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<pre><code class="lang-c">int main()
  └─ void cpu_exec_init_all()
       ├─ static void memory_map_init()
       |    ├─ void memory_region_init()    // 初始化 system_memory/io 这两个全局 MemoryRegion
       |    ├─ void set_system_memory_map() // address_space_memory-&gt;root = system_memory
       |    |    └─ static void memory_region_update_topology()        // 为 MemoryRegion 生成 FlatView
       |    |         └─ static void address_space_update_topology()   // as-&gt;current_map = new_view
       |    |              └─ static void address_space_update_topology_pass()
       |    |                   └─ static void kvm_region_add()        // region_add 对应的回调实现
       |    |                        └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot
       |    |                             └─ static int kvm_set_user_memory_region()
       |    |                                  └─ int ioctl(KVM_SET_USER_MEMORY_REGION)
       |    |
       |    └─ void memory_listener_register() // 注册对应的 MemoryListener
       |         └─ static void listener_add_address_space()
       |
       └─ static void io_mem_init()
            └─ void memory_region_init_io() // ram/rom/unassigned/notdirty/subpage-ram/watch
                 └─ void memory_region_init()
</code></pre>
<p>第一部分在全局注册了<code>kvm_memory_listener</code>，但由于 AddressSpace 尚未初始化，实际上并未向 KVM 中注册任何实际的内存信息。QEMU 在<code>main()</code>函数中会继续调用<code>cpu_exec_init_all()</code>对 AddressSpace 进行初始化，该函数实际上是对两个 init 函数的封装调用：</p>
<pre><code class="lang-c">void cpu_exec_init_all(void)
{
#if !defined(CONFIG_USER_ONLY)
    memory_map_init(); // 初始化两个全局 AddressSpace，以及对应的 MemoryRegion、FlatView
    io_mem_init();     // 初始化六个I/O MemoryRegion
#endif
}
</code></pre>
<p>先来看<code>memory_map_init()</code>，主要用来初始化两个全局的系统地址空间<code>system_memory</code>、<code>system_io</code>：</p>
<pre><code class="lang-c">static void memory_map_init(void)
{
    system_memory = g_malloc(sizeof(*system_memory));
    memory_region_init(system_memory, &quot;system&quot;, INT64_MAX); // 1. 初始化 system_memory
    set_system_memory_map(system_memory); // 2. 设置 address_space_memory 关联 system_memory 及其对应的 FlatView

    system_io = g_malloc(sizeof(*system_io));
    memory_region_init(system_io, &quot;io&quot;, 65536); // 1. 初始化 system_io
    set_system_io_map(system_io);         // 2. 设置 address_space_io 关联 system_io 及其对应的 FlatView

    memory_listener_register(&amp;core_memory_listener, system_memory); // 3. 注册 core_memory_listener
    memory_listener_register(&amp;io_memory_listener, system_io);       // 3. 注册 io_memory_listener
}
</code></pre>
<p>这样一来就完成了以下对应关系：</p>
<pre><code class="lang-c">AddressSpace              address_space_memory      address_space_io
                                ↓                       ↓
MemoryRegion              system_memory             system_io
                                ↑                       ↑
MemoryRegionListener      core_memory_listener      io_memory_listener
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">AddressSpace</th>
<th style="text-align:center">对应的 MemoryRegion</th>
<th style="text-align:center">对应的 MemoryRegionListener</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">address_space_memory</td>
<td style="text-align:center">system_memory</td>
<td style="text-align:center">core_memory_listener</td>
</tr>
<tr>
<td style="text-align:center">address_space_io</td>
<td style="text-align:center">system_io</td>
<td style="text-align:center">io_memory_listener</td>
</tr>
</tbody>
</table>
</div>
<p><code>memory_region_init</code>主要是初始化<code>system_memory</code>的各个字段，这里比较重要的是<code>set_system_memory_map()</code>，先设置 AddressSpace 对应的 MemoryRegion，之后根据<code>system_memory</code>更新<code>address_space_memory</code>对应的 FlatView：</p>
<pre><code class="lang-c">void set_system_memory_map(MemoryRegion *mr)
{
    address_space_memory.root = mr; // 将 address_space_memory 的 root 域指向 system_memory
    memory_region_update_topology(NULL); // 根据 system_memory 更新 address_space_memory 对应的 FlatView
}
</code></pre>
<p>而<code>memory_region_update_topology()</code>则会继续调用<code>address_space_update_topology()</code>，生成 AddressSpace 对应的 FlatView 视图：</p>
<pre><code class="lang-c">static void memory_region_update_topology(MemoryRegion *mr)
{
    // 此时仅在全局注册了 kvm_memory_listener，而 kvm_begin() 为空，无实际操作
    MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);

    if (address_space_memory.root) { // 更新 address_space_memory 的 FlatView
        address_space_update_topology(&amp;address_space_memory);
    }
    if (address_space_io.root) { // 更新 address_space_io 的 FlatView
        address_space_update_topology(&amp;address_space_io);
    }

    // 此时仅在全局注册了 kvm_memory_listener，而 kvm_commit() 为空，无实际操作
    MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);

    memory_region_update_pending = false;
}
</code></pre>
<p><code>address_space_update_topology()</code>会先调用<code>generate_memory_topology()</code>生成<code>system_memory</code>更新后的视图<code>new_view</code>，再将<code>address_space_memory</code>的<code>current_map</code>指向这个<code>new_view</code>，最后销毁<code>old_view</code>：</p>
<pre><code class="lang-c">static void address_space_update_topology(AddressSpace *as)
{
    FlatView old_view = as-&gt;current_map;
    FlatView new_view = generate_memory_topology(as-&gt;root); // 根据 system_memory 生成 new_view

    // 入参 adding 为 false 时将调用 kvm_region_del()
    address_space_update_topology_pass(as, old_view, new_view, false);
    // 入参 adding 为 true 时将调用 kvm_region_add()
    address_space_update_topology_pass(as, old_view, new_view, true);

    as-&gt;current_map = new_view; // 指向 new_view
    flatview_destroy(&amp;old_view); // 销毁 old_view
    address_space_update_ioeventfds(as);
}
</code></pre>
<p>在<code>address_space_update_topology_pass()</code>的最后，会调用<code>MEMORY_LISTENER_UPDATE_REGION</code>这个宏，触发<code>region_add</code>对应的回调函数<code>kvm_region_add()</code>：</p>
<pre><code class="lang-c">static void address_space_update_topology_pass(AddressSpace *as,
                                               FlatView old_view,
                                               FlatView new_view,
                                               bool adding)
{
    unsigned iold, inew;
    FlatRange *frold, *frnew;

    /* Generate a symmetric difference of the old and new memory maps.
     * Kill ranges in the old map, and instantiate ranges in the new map.
     */

    /* ... */

        } else {
            /* In new */
            if (adding) {
                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);
            }
            ++inew;
        }
    }
}
</code></pre>
<p>这个宏在<code>memory.c</code>中定义，会将 FlatView 中的 FlatRange 转换为 MemoryRegionSection，作为入参传递给<code>kvm_region_add()</code>：</p>
<pre><code class="lang-c">#define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback)            \
    MEMORY_LISTENER_CALL(callback, dir, (&amp;(MemoryRegionSection) {       \
        .mr = (fr)-&gt;mr,                                                 \
        .address_space = (as)-&gt;root,                                    \
        .offset_within_region = (fr)-&gt;offset_in_region,                 \
        .size = int128_get64((fr)-&gt;addr.size),                          \
        .offset_within_address_space = int128_get64((fr)-&gt;addr.start),  \
        .readonly = (fr)-&gt;readonly,                                     \
              }))
</code></pre>
<p>而<code>kvm_region_add()</code>实际上是对<code>kvm_set_phys_mem()</code>的封装调用。该函数比较复杂，会根据传入的<code>section</code>填充 KVMSlot，再传递给<code>kvm_set_user_memory_region()</code>：</p>
<pre><code class="lang-c">static int kvm_set_user_memory_region(KVMState *s, KVMSlot *slot)
{
    struct kvm_userspace_memory_region mem;

    mem.slot = slot-&gt;slot; // 根据 KVMSlot 填充 kvm_userspace_memory_region
    mem.guest_phys_addr = slot-&gt;start_addr;
    mem.memory_size = slot-&gt;memory_size;
    mem.userspace_addr = (unsigned long)slot-&gt;ram;
    mem.flags = slot-&gt;flags;
    if (s-&gt;migration_log) {
        mem.flags |= KVM_MEM_LOG_DIRTY_PAGES;
    }
    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);
}
</code></pre>
<p>可以看到这里又将 KVMSlot 转换为 kvm_userspace_memory_region，作为<code>ioctl()</code>的参数，交给内核中的 KVM 进行内存的注册。至此 QEMU 侧负责管理内存的数据结构均已完成初始化，可以参考下面的图片了解各数据结构之间的对应关系：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/flat-view.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>最后简单看下<code>io_mem_init()</code>，调用<code>memory_region_init_io()</code>对六个 I/O MemoryRegion 进行初始化：</p>
<pre><code class="lang-c">static void io_mem_init(void)
{
    memory_region_init_io(&amp;io_mem_ram, &amp;error_mem_ops, NULL, &quot;ram&quot;, UINT64_MAX);
    memory_region_init_io(&amp;io_mem_rom, &amp;rom_mem_ops, NULL, &quot;rom&quot;, UINT64_MAX);
    memory_region_init_io(&amp;io_mem_unassigned, &amp;unassigned_mem_ops, NULL, &quot;unassigned&quot;, UINT64_MAX);
    memory_region_init_io(&amp;io_mem_notdirty, &amp;notdirty_mem_ops, NULL, &quot;notdirty&quot;, UINT64_MAX);
    memory_region_init_io(&amp;io_mem_subpage_ram, &amp;subpage_ram_ops, NULL, &quot;subpage-ram&quot;, UINT64_MAX);
    memory_region_init_io(&amp;io_mem_watch, &amp;watch_mem_ops, NULL, &quot;watch&quot;, UINT64_MAX);
}
</code></pre>
<ul>
<li>io_mem_ram，名为 “ram”</li>
<li>io_mem_rom，名为 “rom”</li>
<li>io_mem_unassigned，名为 “unassigned”</li>
<li>io_mem_notdirty，名为 “notdirty”</li>
<li>io_mem_subpage_ram，名为 “subpage-ram”</li>
<li>io_mem_warch，名为 “watch”</li>
</ul>
<p>而<code>memory_region_init_io()</code>则会先调用<code>memory_region_init()</code>对上述六个 MemoryRegion 进行初始化，之后设置一些字段的值：</p>
<pre><code class="lang-c">void memory_region_init_io(MemoryRegion *mr,
                           const MemoryRegionOps *ops,
                           void *opaque,
                           const char *name,
                           uint64_t size)
{
    memory_region_init(mr, name, size);
    mr-&gt;ops = ops;
    mr-&gt;opaque = opaque;
    mr-&gt;terminates = true; // 表示为实体类型的 MemoryRegion
    mr-&gt;destructor = memory_region_destructor_iomem;
    mr-&gt;ram_addr = ~(ram_addr_t)0;
}
</code></pre>
<h3 id="3-3-实际内存的分配"><a href="#3-3-实际内存的分配" class="headerlink" title="3.3 实际内存的分配"></a>3.3 实际内存的分配</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/mermaid-3.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<pre><code class="lang-c">int main()
  └─ void machine-&gt;init(ram_size, ...)
       └─ static void pc_init_pci(ram_size, ...) // 初始化虚拟机
            └─ static void pc_init1(system_memory, system_io, ram_size, ...)
                 ├─ void memory_region_init(pci_memory, &quot;pci&quot;, ...) // pci_memory, rom_memory
                 └─ void pc_memory_init() // 初始化内存，分配实际的物理内存地址
                      ├─ void memory_region_init_ram() // 创建 pc.ram, pc.rom 并分配内存
                      |    ├─ void memory_region_init()
                      |    └─ ram_addr_t qemu_ram_alloc()
                      |         └─ ram_addr_t qemu_ram_alloc_from_ptr()
                      |
                      ├─ void vmstate_register_ram_global() // 将 MR 的 name 写入 RAMBlock 的 idstr
                      |    └─ void vmstate_register_ram()
                      |         └─ void qemu_ram_set_idstr()
                      |
                      ├─ void memory_region_init_alias()    // 初始化 ram_below_4g, ram_above_4g
                      └─ void memory_region_add_subregion() // 在 system_memory 中添加 subregions
                           └─ static void memory_region_add_subregion_common()
                                └─ static void memory_region_update_topology() // 为 MemoryRegion 生成 FlatView
                                     └─ static void address_space_update_topology() // as-&gt;current_map = new_view
                                          └─ static void address_space_update_topology_pass()
                                               └─ static void kvm_region_add() // region_add 对应的回调实现
                                                    └─ static void kvm_set_phys_mem() // 根据传入的 section 填充 KVMSlot
                                                         └─ static int kvm_set_user_memory_region()
                                                              └─ int ioctl(KVM_SET_USER_MEMORY_REGION)
</code></pre>
<p>之前的回调函数注册、AddressSpace 的初始化，实际上均没有对应的物理内存。顺着<code>main()</code>函数往下走，会来到<code>pc_init_pci()</code>这个函数。</p>
<p>函数<code>pc_init_pci()</code>负责在 QEMU 中初始化虚拟机，内存的虚拟化也是在这里完成的。调用<code>machine-&gt;init()</code>时传入了<code>ram_size</code>参数，表示申请内存的大小，一步步传递给了<code>pc_init1()</code>。</p>
<p>在<code>pc_init1()</code>中，先将<code>ram_size</code>分为<code>above_4g_mem_size</code>、<code>below_4g_mem_size</code>，之后调用<code>pc_memory_init()</code>对内存进行初始化：</p>
<pre><code class="lang-c">void *pc_memory_init(MemoryRegion *system_memory,
                    const char *kernel_filename,
                    const char *kernel_cmdline,
                    const char *initrd_filename,
                    ram_addr_t below_4g_mem_size,
                    ram_addr_t above_4g_mem_size,
                    MemoryRegion *rom_memory,
                    MemoryRegion **ram_memory)
{
    MemoryRegion *ram, *option_rom_mr;         // 两个实体 MR: pc.ram, pc.rom
    MemoryRegion *ram_below_4g, *ram_above_4g; // 两个别名 MR: ram_below_4g, ram_above_4g

    /* Allocate RAM.  We allocate it as a single memory region and use
     * aliases to address portions of it, mostly for backwards compatibility
     * with older qemus that used qemu_ram_alloc().
     */
    ram = g_malloc(sizeof(*ram)); // 创建 ram
    // 分配具体的内存（实际上会创建一个 RAMBlock 并将其 offset 值写入 ram.ram_addr，对应 GPA）
    memory_region_init_ram(ram, &quot;pc.ram&quot;, below_4g_mem_size + above_4g_mem_size);
    // 将 MR 的 name 写入 RAMBlock 的 idstr
    vmstate_register_ram_global(ram);
    *ram_memory = ram;

    // 创建 ram_below_4g 表示 4G 以下的内存
    ram_below_4g = g_malloc(sizeof(*ram_below_4g));
    memory_region_init_alias(ram_below_4g, &quot;ram-below-4g&quot;, ram, 0, below_4g_mem_size);
    // 将 ram_below_4g 挂在 system_memory 下
    memory_region_add_subregion(system_memory, 0, ram_below_4g);

    if (above_4g_mem_size &gt; 0) {
        ram_above_4g = g_malloc(sizeof(*ram_above_4g));
        memory_region_init_alias(ram_above_4g, &quot;ram-above-4g&quot;, ram, below_4g_mem_size, above_4g_mem_size);
        memory_region_add_subregion(system_memory, 0x100000000ULL, ram_above_4g);
    }
    /* ... */
}
</code></pre>
<p>这里的重点在于<code>memory_region_init_ram()</code>，它通过<code>qemu_ram_alloc()</code>获取<code>ram</code>这个 MemoryRegion 对应的 RAMBlock 的<code>offset</code>，并存入<code>ram.ram_addr</code>，这样就可以在<code>ram_list</code>中根据该字段查找 MR 对应的 RAMBlock：</p>
<pre><code class="lang-c">void memory_region_init_ram(MemoryRegion *mr, const char *name, uint64_t size)
{
    memory_region_init(mr, name, size); // 填充字段，初始化默认值
    mr-&gt;ram = true; // 表示为 RAM
    mr-&gt;terminates = true; // 表示为实体 MemoryRegion
    mr-&gt;destructor = memory_region_destructor_ram;
    mr-&gt;ram_addr = qemu_ram_alloc(size, mr); // 这里保存 RAMBlock 的 offset，即 GPA
}
</code></pre>
<p>而<code>qemu_ram_alloc()</code>最终会调用<code>qemu_ram_alloc_from_ptr()</code>，<strong>创建一个对应大小 RAMBlock 并分配内存，返回对应的 GPA 地址存入</strong><code>mr-&gt;ram_addr</code><strong>中</strong>：</p>
<pre><code class="lang-c">ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                   MemoryRegion *mr)
{
    RAMBlock *new_block; // 创建一个 RAMBlock

    size = TARGET_PAGE_ALIGN(size); // 页对齐
    new_block = g_malloc0(sizeof(*new_block)); // 初始化 new_block

    new_block-&gt;mr = mr; // 将 new_block-&gt; 指向入参的 MemoryRegion
    new_block-&gt;offset = find_ram_offset(size); // 从 ram_list 中的 RAMBlock 之间找到一段可以满足 size 需求的 gap，并返回起始地址的 offset，对应 GPA
    if (host) { // 新建的 RAMBlock host 字段为空，跳过
        new_block-&gt;host = host;
        new_block-&gt;flags |= RAM_PREALLOC_MASK;
    } else {
        if (mem_path) { // 未指定 mem_path
#if defined (__linux__) &amp;&amp; !defined(TARGET_S390X)
            new_block-&gt;host = file_ram_alloc(new_block, size, mem_path);
            if (!new_block-&gt;host) {
                new_block-&gt;host = qemu_vmalloc(size);
                qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);
            }
#else
            fprintf(stderr, &quot;-mem-path option unsupported\n&quot;);
            exit(1);
#endif
        } else {
            if (xen_enabled()) {
                xen_ram_alloc(new_block-&gt;offset, size, mr);
            } else if (kvm_enabled()) { // 从这里继续
                /* some s390/kvm configurations have special constraints */
                new_block-&gt;host = kvm_vmalloc(size); // 实际上还是调用 qemu_vmalloc(size)
            } else {
                new_block-&gt;host = qemu_vmalloc(size); // 从 QEMU 的线性空间中分配 size 大小的内存，返回 HVA
            }
            qemu_madvise(new_block-&gt;host, size, QEMU_MADV_MERGEABLE);
        }
    }
    new_block-&gt;length = size; // 将 length 设置为 size

    QLIST_INSERT_HEAD(&amp;ram_list.blocks, new_block, next); // 将该 RAMBlock 插入 ram_list 头部

    ram_list.phys_dirty = g_realloc(ram_list.phys_dirty, // 重新分配 ram_list.phys_dirty 的内存空间
                                       last_ram_offset() &gt;&gt; TARGET_PAGE_BITS);
    memset(ram_list.phys_dirty + (new_block-&gt;offset &gt;&gt; TARGET_PAGE_BITS),
           0, size &gt;&gt; TARGET_PAGE_BITS);
    cpu_physical_memory_set_dirty_range(new_block-&gt;offset, size, 0xff); // 对该 RAMBlock 对应的内存标记为 dirty

    qemu_ram_setup_dump(new_block-&gt;host, size);

    if (kvm_enabled())
        kvm_setup_guest_memory(new_block-&gt;host, size);

    return new_block-&gt;offset;
}
</code></pre>
<p>这样一来<code>ram</code>对应的 RAMBlock 中就分配好了 GPA 和 HVA，就可以<strong>将内存信息同步至 KVM 侧</strong>了。</p>
<p>最后回到<code>pc_memory_init()</code>中，在分配完实际内存后，会先调用<code>memory_region_init_alias()</code>初始化<code>ram_below_4g</code>、<code>ram_above_4g</code>这两个 alias，之后调用<code>memory_region_add_subregion()</code>将这两个 alias 指向<code>ram</code>这个实体 MemoryRegion。该函数最终会触发<code>kvm_region_add()</code>回调，将实际的内存信息传入 KVM 注册。该过程如下图所示，与之前分析的流程相同，此处不再赘述。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/07/07/kvm-memory-virtualization/mermaid-4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="4-总结一下"><a href="#4-总结一下" class="headerlink" title="4. 总结一下"></a>4. 总结一下</h2><h3 id="4-1-QEMU-侧"><a href="#4-1-QEMU-侧" class="headerlink" title="4.1 QEMU 侧"></a>4.1 QEMU 侧</h3><ul>
<li>创建一系列 MemoryRegion，分别表示 Guest 中的 RAM、ROM 等区域。MemoryRegion 之间通过 alias 或 subregions 的方式维护相互之间的关系，从而进一步细化区域的定义</li>
<li>对于一个实体 MemoryRegion（非 alias），在初始化内存的过程中 QEMU 会创建它所对应的 RAMBlock。该 RAMBlock 通过调用<code>qemu_ram_alloc_from_ptr()</code>从 QEMU 的进程地址空间中以 mmap 的方式分配内存，并负责维护该 MemoryRegion 对应内存的起始 GPA/HVA/size 等相关信息</li>
<li>AddressSpace 表示 Guest 的物理地址空间。如果 AddressSpace 中的 MemoryRegion 发生变化，则注册的 listener 会被触发，将所属的 MemoryRegion 树展开生成一维的 FlatView，比较 FlatRange 是否发生了变化。如果是则调用相应的方法对 MemoryRegionSection 进行检查，更新 QEMU 中的 KVMSlot，同时填充<code>kvm_userspace_memory_region</code>结构体，作为<code>ioctl()</code>的参数更新 KVM 中的<code>kvm_memory_slot</code></li>
</ul>
<h3 id="4-2-KVM-侧"><a href="#4-2-KVM-侧" class="headerlink" title="4.2 KVM 侧"></a>4.2 KVM 侧</h3><ul>
<li>当 QEMU 通过<code>ioctl()</code>创建 vcpu 时，调用<code>kvm_mmu_create()</code>初始化 MMU 相关信息</li>
<li>当 KVM 要进入 Guest 前，<code>vcpu_enter_guest()=&gt;kvm_mmu_reload()</code>会将根级页表地址加载到 VMCS，让 Guest 使用该页表</li>
<li>当发生 EPT Violation 时，VM-EXIT 到 KVM 中。如果是缺页，则根据 GPA 算出 gfn，再根据 gfn 找到对应的 KVMSlot，从中得到对应的 HVA。然后根据 HVA 算出对应的 pfn，确保该 Page 位于内存中。填好缺失的页之后，需要更新 EPT，完善其中缺少的页表项，逐层补全页表</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h3><ul>
<li><a href="https://www.anquanke.com/post/id/86412" target="_blank" rel="noopener">【系列分享】QEMU 内存虚拟化源码分析 | 安全客</a></li>
<li><a href="https://www.binss.me/blog/qemu-note-of-memory/#sidebar" target="_blank" rel="noopener">QEMU学习笔记——内存 | BinSite</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/6729224.html" target="_blank" rel="noopener">QEMU-KVM 内存虚拟化 1 | cnblogs</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/6738116.html" target="_blank" rel="noopener">QEMU-KVM 内存虚拟化 2 | cnblogs</a></li>
<li><a href="https://www.cnblogs.com/beixiaobei/p/10608293.html" target="_blank" rel="noopener">QEMU 中的内存管理 - 前进的code | cnblogs</a></li>
<li><a href="https://www.cnblogs.com/Bozh/p/5777077.html" target="_blank" rel="noopener">KVM 虚拟化原理探究（4）— 内存虚拟化 | cnblogs</a></li>
<li><a href="https://www.oipapio.com/cn/article-8819489" target="_blank" rel="noopener">QEMU 内存管理之生成 FlatView 内存拓扑模型过程分析（基于QEMU 2.0.0）- eric_liufeng</a></li>
<li><a href="http://juniorprincewang.github.io/2018/07/20/qemu内存虚拟化/" target="_blank" rel="noopener">QEMU-KVM 内存虚拟化 | 王子阳</a></li>
<li><a href="https://www.cnblogs.com/wuchanming/p/4732604.html" target="_blank" rel="noopener">QEMU 对虚拟机的地址空间管理 - Jessica 要努力了 | cnblogs</a></li>
<li><a href="http://abcdxyzk.github.io/blog/2015/07/28/kvm-pic/" target="_blank" rel="noopener">QEMU-KVM 部分流程/源代码分析（多图）| kk Blog</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/20160921?lang=en" target="_blank" rel="noopener">QEMU 深入浅出: Guest物理内存管理 | IBM 中国 Linux 与虚拟化实验室</a></li>
</ul>
<h3 id="阿里云-Bozh"><a href="#阿里云-Bozh" class="headerlink" title="阿里云 Bozh"></a>阿里云 Bozh</h3><blockquote>
<p><strong>目录</strong>：<a href="https://www.cnblogs.com/Bozh/p/5788431.html" target="_blank" rel="noopener">KVM 虚拟化原理探究 —— 目录 | 博客园</a></p>
</blockquote>
<ol>
<li><a href="https://www.cnblogs.com/Bozh/p/5750495.html" target="_blank" rel="noopener">KVM 虚拟化原理探究(1) —— Overview | 博客园</a></li>
<li><a href="https://www.cnblogs.com/Bozh/p/5753379.html" target="_blank" rel="noopener">KVM 虚拟化原理探究(2) —— QEMU 启动过程 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/Bozh/p/5757274.html" target="_blank" rel="noopener">KVM 虚拟化原理探究(3) —— CPU 虚拟化 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/Bozh/p/5777077.html" target="_blank" rel="noopener">KVM 虚拟化原理探究(4) —— 内存虚拟化 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/Bozh/p/5788364.html" target="_blank" rel="noopener">KVM 虚拟化原理探究(5) —— 网络 I/O 虚拟化 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/Bozh/p/5788402.html" target="_blank" rel="noopener">KVM 虚拟化原理探究(6) —— 块设备 I/O 虚拟化 | 博客园</a></li>
</ol>
<h3 id="太初有道"><a href="#太初有道" class="headerlink" title="太初有道"></a>太初有道</h3><blockquote>
<p><strong>目录</strong>：<a href="https://www.cnblogs.com/ck1020/category/884534.html" target="_blank" rel="noopener">KVM 虚拟化技术 - 太初有道 | 博客园</a></p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/ck1020/p/6043054.html" target="_blank" rel="noopener">intel EPT 机制详解 - 太初有道 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/6920765.html" target="_blank" rel="noopener">KVM 中 EPT 逆向映射机制分析 - 太初有道 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/6753206.html" target="_blank" rel="noopener">QEMU 进程页表和 EPT 的同步问题 - 太初有道 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/6729224.html" target="_blank" rel="noopener">QEMU-KVM 内存虚拟化 1 - 太初有道 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/6738116.html" target="_blank" rel="noopener">QEMU-KVM 内存虚拟化 2 - 太初有道 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/6770272.html" target="_blank" rel="noopener">Linux 下的 KSM 内存共享机制分析 - 太初有道 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/7424922.html" target="_blank" rel="noopener">KVM 中断虚拟化浅析 - 太初有道 | 博客园</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/7840470.html" target="_blank" rel="noopener">KVM vCPU 线程调度问题的讨论 - 太初有道| 博客园</a></li>
</ul>
<h3 id="OenHan"><a href="#OenHan" class="headerlink" title="OenHan"></a>OenHan</h3><h4 id="KVM-虚拟化"><a href="#KVM-虚拟化" class="headerlink" title="KVM 虚拟化"></a>KVM 虚拟化</h4><ul>
<li><a href="http://oenhan.com/kvm-src-1" target="_blank" rel="noopener">KVM 源代码分析 1: 基本工作原理 | OenHan</a></li>
<li><a href="http://oenhan.com/kvm-src-2-vm-run" target="_blank" rel="noopener">KVM 源代码分析 2: 虚拟机的创建与运行 | OenHan</a></li>
<li><a href="http://oenhan.com/kvm-src-3-cpu" target="_blank" rel="noopener">KVM 源代码分析 3: CPU 虚拟化 | OenHan</a></li>
<li><a href="http://oenhan.com/kvm-src-4-mem" target="_blank" rel="noopener">KVM 源代码分析 4: 内存虚拟化 | OenHan</a></li>
<li><a href="http://oenhan.com/kvm-src-5-io-pio" target="_blank" rel="noopener">KVM 源代码分析 5: I/O 虚拟化之 PIO | OenHan</a></li>
<li><a href="http://oenhan.com/qemu-memory-struct" target="_blank" rel="noopener">QEMU 下的内存结构 MemoryRegion 和 AddressSpace | OenHan</a></li>
<li><a href="http://oenhan.com/kvm-pv-kvmclock-tsc" target="_blank" rel="noopener">KVM CLOCK 时钟虚拟化源代码分析 | OenHan</a></li>
<li><a href="http://oenhan.com/kvm-free-mmu-page" target="_blank" rel="noopener">KVM MMU Page 释放机制 | OenHan</a></li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><a href="http://oenhan.com/topic" target="_blank" rel="noopener">TOPIC | OenHan</a></li>
<li><a href="http://oenhan.com/cpu-affinity" target="_blank" rel="noopener">CPU 亲和性的使用与机制 | OenHan</a></li>
<li><a href="http://oenhan.com/cgroup-src-1" target="_blank" rel="noopener">CGROUP 源码分析 1: 基本概念与框架 | OenHan</a></li>
<li><a href="http://oenhan.com/kernel-program-exec" target="_blank" rel="noopener">从一次内存泄露看程序在内核中的执行过程 | OenHan</a></li>
<li><a href="http://oenhan.com/linux-cache-writeback" target="_blank" rel="noopener">Linux 缓存写回机制 | OenHan</a></li>
</ul>
<h3 id="leoufung"><a href="#leoufung" class="headerlink" title="leoufung"></a>leoufung</h3><ul>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781209" target="_blank" rel="noopener">QEMU内存管理之生成 FlatView 内存拓扑模型过程分析（基于QEMU2.0.0）| CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781203" target="_blank" rel="noopener">QEMU 内存管理之 FlatView 模型（QEMU2.0.0）| CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/52667307" target="_blank" rel="noopener">kvm_mmu_get_page 函数解析 | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/52638357" target="_blank" rel="noopener">tdp_page_fault 函数解析之 level, gfn 变量的含义 | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/49024149" target="_blank" rel="noopener">QEMU 中通过 GPA 得到对应 HVA 的方法 | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781123" target="_blank" rel="noopener">kvm_mmu_page 结构和用法解析（基于Kernel3.10.0）| CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781185" target="_blank" rel="noopener">通过 KVM_SET_USER_MEMORY_REGION 操作虚拟机内存（Kernel 3.10.0 &amp; qemu 2.0.0）| CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781197" target="_blank" rel="noopener">QEMU 的 AddrRange 地址空间对象模型算法总结(QEMU2.0.0) | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781203" target="_blank" rel="noopener">QEMU 内存管理之 FlatView 模型（QEMU2.0.0）| CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781205" target="_blank" rel="noopener">MemoryRegion 模型原理，以及同 FlatView 模型的关系(QEMU2.0.0) | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/48781207" target="_blank" rel="noopener">如何查看系统中都注册了哪些 MemoryRegion (QEMU2.0.0) | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/49155193" target="_blank" rel="noopener">QEMU 中关于 CPU 初始化的重要函数调用栈 | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/49175151" target="_blank" rel="noopener">如何调试 QEMU | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/52470790" target="_blank" rel="noopener">单独编译 KVM 模块的方法(进行调试) | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/52485114" target="_blank" rel="noopener">kvm 代码中 vcpu_vmx、vcpu、vmcs、cpu 的关系 | CSDN</a></li>
</ul>
<h3 id="论文-and-PPT"><a href="#论文-and-PPT" class="headerlink" title="论文 and PPT"></a>论文 and PPT</h3><ul>
<li><a href="http://events17.linuxfoundation.org/sites/events/files/slides/Guangrong-fast-write-protection.pdf" target="_blank" rel="noopener">Fast Write Protection - 肖光荣 | PDF</a></li>
<li><a href="https://www.linux-kvm.org/images/c/c8/KvmForum2008%24kdf2008_21.pdf" target="_blank" rel="noopener">Nested paging hardware and software - KVM Forum 2018 | PDF</a></li>
<li><a href="http://vglab.cse.iitd.ac.in/~sbansal/csl862-virt/readings/p26-bhargava.pdf" target="_blank" rel="noopener">Accelerating Two-Dimensional Page Walks for Virtualized Systems | PDF</a></li>
</ul>
<h3 id="intel-白皮书"><a href="#intel-白皮书" class="headerlink" title="intel 白皮书"></a>intel 白皮书</h3><ul>
<li><a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf" target="_blank" rel="noopener">Intel 64 and IA-32 Architectures Software Developer’s Manual | PDF</a></li>
<li><a href="https://software.intel.com/sites/default/files/managed/2b/80/5-level_paging_white_paper.pdf" target="_blank" rel="noopener">5-Level Paging and 5-Level EPT | PDF</a></li>
<li><a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/page-modification-logging-vmm-white-paper.pdf" target="_blank" rel="noopener">Page Modification Logging for Virtual Machine Monitor White Paper | PDF</a></li>
<li><a href="https://www.jianshu.com/p/8d19b485617e" target="_blank" rel="noopener">Intel 64 架构 5 级分页和 5 级 EPT 白皮书 | 简书</a></li>
</ul>
<h3 id="EPT-amp-MMU"><a href="#EPT-amp-MMU" class="headerlink" title="EPT &amp; MMU"></a>EPT &amp; MMU</h3><ul>
<li><a href="http://sec-lbx.tk/2016/06/27/kvm%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" target="_blank" rel="noopener">EPT 缺页异常源码分析 | Benxi Liu</a></li>
<li><a href="http://sec-lbx.tk/2016/06/15/Intel%20VT-x:EPT%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">VT-x/EPT 解读 | Benxi Liu</a></li>
<li><a href="http://sec-lbx.tk/2017/07/30/%E8%AF%A6%E8%A7%A3%E4%B8%AD%E6%96%AD%E8%99%9A%E6%8B%9F%E5%8C%96/" target="_blank" rel="noopener">关于中断虚拟化 | Benxi Liu</a></li>
<li><a href="http://www.luo666.com/?p=35" target="_blank" rel="noopener">梳理一下 EPT 表项的建立 | GeekBen</a></li>
<li><a href="https://blog.csdn.net/Lux_Veritas/article/details/9284635" target="_blank" rel="noopener">KVM 地址翻译流程及 EPT 页表的建立过程 | CSDN</a></li>
<li><a href="https://blog.csdn.net/leoufung/article/details/52638357" target="_blank" rel="noopener">tdp_page_fault 函数解析之 level，gfn 变量的含义 | CSDN</a></li>
<li><a href="https://kvm.vger.kernel.narkive.com/8CNlP9QP/ept-page-fault-procedure" target="_blank" rel="noopener">EPT Page Fault Procedure</a></li>
<li><a href="http://ningfxkvm.blogspot.com/2015/11/kvmept-exception.html" target="_blank" rel="noopener">KVM 中的 EPT Exception | Blogger</a></li>
<li><a href="https://zhoujianshi.github.io/articles/2019/KVM%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E9%87%87%E6%A0%B7%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%89%A9%E5%B1%95%E9%A1%B5%E8%A1%A8EPT%E7%9A%84%E7%BB%93%E6%9E%84/index.html" target="_blank" rel="noopener">KVM 内存访问采样（一）—— 扩展页表 EPT 的结构 | 周语馨</a></li>
<li><a href="https://www.cnblogs.com/scu-cjx/p/6878568.html" target="_blank" rel="noopener">KVM 的 EPT 机制 | 博客园</a></li>
<li><a href="https://kvm.vger.kernel.narkive.com/8CNlP9QP/ept-page-fault-procedure" target="_blank" rel="noopener">EPT page fault procedure | KVM Mailing List</a></li>
<li><a href="https://www.jianshu.com/p/114c69af7337" target="_blank" rel="noopener">科普 VT、EPT | 简书</a></li>
<li><a href="http://www.linux-kvm.org/page/Memory" target="_blank" rel="noopener">Memory | KVM Documents</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/virtual/kvm/mmu.txt" target="_blank" rel="noopener">mmu.txt | KVM </a></li>
<li><a href="https://blog.csdn.net/xelatex_kvm/article/details/17685123" target="_blank" rel="noopener">KVM MMU EPT 内存管理 | CSDN</a></li>
<li><a href="https://blog.csdn.net/zhuriyuxiao/article/details/8814595" target="_blank" rel="noopener">qemu-kvm 内存虚拟化 - ept | CSDN</a></li>
<li><a href="https://www.xuejiayuan.net/blog/99e416562c7d4212b399c6fc1990ec82" target="_blank" rel="noopener">KVM MMU EPT 内存管理 | 学佳园</a></li>
</ul>
<h3 id="Patchwork"><a href="#Patchwork" class="headerlink" title="Patchwork"></a>Patchwork</h3><h4 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h4><ul>
<li><a href="https://patchwork.kernel.org/project/kvm/list/" target="_blank" rel="noopener">KVM development | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/project/qemu-devel/list/" target="_blank" rel="noopener">QEMU patches | Patchwork</a></li>
<li><a href="https://elixir.bootlin.com/linux/latest/source" target="_blank" rel="noopener">Bootlin - Elixir Cross Reference | 在线阅读 Kernel、QEMU 源码</a></li>
<li><a href="https://rpmfind.net/" target="_blank" rel="noopener">rpmfind | 用来找 rpm 包</a></li>
<li><a href="https://rpmfind.net/linux/RPM/centos/7.6.1810/x86_64/Packages/kernel-3.10.0-957.el7.x86_64.html" target="_blank" rel="noopener">kernel-3.10.0-957.el7 RPM for x86_64 | rpmfind</a></li>
<li><a href="https://git.kernel.org/pub/scm/virt/kvm/kvm.git/commit/?h=dirty-ring-buffer&amp;id=8d19462882d3ad12238755956d9154f3732f78bf" target="_blank" rel="noopener">KVM: x86: implement ring-based dirty memory tracking | kvm.git</a></li>
</ul>
<h4 id="肖光荣-Fast-Write-Protect-v1"><a href="#肖光荣-Fast-Write-Protect-v1" class="headerlink" title="肖光荣 Fast Write Protect-v1"></a>肖光荣 Fast Write Protect-v1</h4><ul>
<li><a href="https://patchwork.kernel.org/patch/9709351/" target="_blank" rel="noopener">[0/7] KVM: MMU: fast write protect | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9709359/" target="_blank" rel="noopener">[1/7] KVM: MMU: correct the behavior of mmu_spte_update_no_track | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9709353/" target="_blank" rel="noopener">[2/7] KVM: MMU: introduce possible_writable_spte_bitmap | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9709391/" target="_blank" rel="noopener">[3/7] KVM: MMU: introduce kvm_mmu_write_protect_all_pages | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9709363/" target="_blank" rel="noopener">[4/7] KVM: MMU: enable KVM_WRITE_PROTECT_ALL_MEM | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9709369/" target="_blank" rel="noopener">[5/7] KVM: MMU: allow dirty log without write protect | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9709367/" target="_blank" rel="noopener">[6/7] KVM: MMU: clarify fast_pf_fix_direct_spte | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9709365/" target="_blank" rel="noopener">[7/7] KVM: MMU: stop using mmu_spte_get_lockless under mmu-lock | Patchwork</a></li>
</ul>
<h4 id="肖光荣-Fast-Write-Protect-v2"><a href="#肖光荣-Fast-Write-Protect-v2" class="headerlink" title="肖光荣 Fast Write Protect-v2"></a>肖光荣 Fast Write Protect-v2</h4><ul>
<li><a href="https://patchwork.kernel.org/patch/9798939/" target="_blank" rel="noopener">[v2,0/7] KVM: MMU: fast write protect | Patchwork | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9798937/" target="_blank" rel="noopener">[v2,1/7] KVM: MMU: correct the behavior of mmu_spte_update_no_track | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9798927/" target="_blank" rel="noopener">[v2,2/7] KVM: MMU: introduce possible_writable_spte_bitmap | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9798907/" target="_blank" rel="noopener">[v2,3/7] KVM: MMU: introduce kvm_mmu_write_protect_all_pages | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9798921/" target="_blank" rel="noopener">[v2,4/7] KVM: MMU: enable KVM_WRITE_PROTECT_ALL_MEM | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9798925/" target="_blank" rel="noopener">[v2,5/7] KVM: MMU: allow dirty log without write protect | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9798915/" target="_blank" rel="noopener">[v2,6/7] KVM: MMU: clarify fast_pf_fix_direct_spte | Patchwork</a></li>
<li><a href="https://patchwork.kernel.org/patch/9798905/" target="_blank" rel="noopener">[v2,7/7] KVM: MMU: stop using mmu_spte_get_lockless under mmu-lock | Patchwork</a></li>
</ul>
<h4 id="Mailing-List"><a href="#Mailing-List" class="headerlink" title="Mailing List"></a>Mailing List</h4><ul>
<li><a href="https://lkml.org/lkml/2017/6/20/274" target="_blank" rel="noopener">[PATCH v2 0/7] KVM: MMU: fast write protect | LKML</a></li>
<li><a href="https://lists.gnu.org/archive/html/qemu-devel/2017-05/msg00582.html" target="_blank" rel="noopener">Re: [Qemu-devel] [PATCH 0/7] KVM: MMU: fast write protect | gnu.org</a></li>
</ul>
<h4 id="patch-教程"><a href="#patch-教程" class="headerlink" title="patch 教程"></a>patch 教程</h4><ul>
<li><a href="https://onestraw.github.io/linux/apply-patch-to-linux-kernel/" target="_blank" rel="noopener">如何给 Linux 内核打补丁 | 一根稻草</a></li>
<li><a href="https://orzfly.com/html/diff-and-patch-and-windows.html" target="_blank" rel="noopener">diff 和 patch 的入门（及 Windows 下的用法）| orzfly.com</a></li>
<li><a href="http://linux-wiki.cn/wiki/zh-hans/%E8%A1%A5%E4%B8%81%28patch%29%E7%9A%84%E5%88%B6%E4%BD%9C%E4%B8%8E%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">补丁(patch)的制作与应用 | Linux-Wiki.cn</a></li>
<li><a href="https://blog.csdn.net/pashanhu6402/article/details/51849354" target="_blank" rel="noopener">Linux 内核补丁与 patch/diff 使用详解 | CSDN</a></li>
</ul>
<h4 id="升级内核"><a href="#升级内核" class="headerlink" title="升级内核"></a>升级内核</h4><ul>
<li><a href="https://wsgzao.github.io/post/linux-kernel-update/#" target="_blank" rel="noopener">Linux kernel 内核升级和降级的方法实践 | Hello Dog</a></li>
<li><a href="https://jasonhzy.github.io/2019/02/05/linux-kernel-version/" target="_blank" rel="noopener">Linux 内核版本介绍与查询 | Jason Website</a></li>
</ul>
<h3 id="内存虚拟化基础"><a href="#内存虚拟化基础" class="headerlink" title="内存虚拟化基础"></a>内存虚拟化基础</h3><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><ul>
<li><a href="https://blog.csdn.net/leves1989/article/details/3305402" target="_blank" rel="noopener">操作系统 内存地址（逻辑地址、线性地址、物理地址）概念 | CSDN</a></li>
<li><a href="https://blog.csdn.net/macrossdzh/article/details/5954763" target="_blank" rel="noopener">物理地址、虚拟地址（线性地址）、逻辑地址以及MMU的知识 | CSDN</a></li>
<li><a href="https://blog.csdn.net/radianceblau/article/details/81608729" target="_blank" rel="noopener">PCIe 的内存地址空间、I/O 地址空间和配置地址空间 | CSDN</a></li>
<li><a href="https://www.zhihu.com/question/29918252" target="_blank" rel="noopener">Linux 线性地址，逻辑地址和虚拟地址的关系？| 知乎</a></li>
<li><a href="https://blog.csdn.net/u014379540/article/details/52502470" target="_blank" rel="noopener">Linux 中的物理地址、虚拟地址、总线地址的区别 | CSDN</a></li>
<li><a href="https://blog.csdn.net/zyboy2000/article/details/52003160" target="_blank" rel="noopener">物理地址和总线地址的区别 | CSDN</a></li>
</ul>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><ul>
<li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">认真分析 mmap：是什么 为什么 怎么用 | cnblogs</a></li>
</ul>
<h3 id="QEMU-部分"><a href="#QEMU-部分" class="headerlink" title="QEMU 部分"></a>QEMU 部分</h3><ul>
<li><a href="https://www.anquanke.com/post/id/86412" target="_blank" rel="noopener">【干货！】【系列分享】QEMU内存虚拟化源码分析 | 安全客</a></li>
<li><a href="http://juniorprincewang.github.io/2018/07/20/qemu%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/" target="_blank" rel="noopener">QEMU-KVM 内存虚拟化 | 王子阳</a></li>
<li><a href="https://www.binss.me/blog/qemu-note-of-memory/" target="_blank" rel="noopener">QEMU 学习笔记 —— 内存 | BinSite</a></li>
<li><a href="https://www.cnblogs.com/beixiaobei/p/10608293.html" target="_blank" rel="noopener">QEMU 中的内存管理 - 前进的code| cnblogs</a></li>
<li><a href="https://www.cnblogs.com/wuchanming/p/4732604.html" target="_blank" rel="noopener">QEMU 对虚拟机的地址空间管理 - Jessica 要努力了 | cnblogs</a></li>
<li><a href="https://www.oipapio.com/cn/article-8819489" target="_blank" rel="noopener">QEMU 内存管理之生成 FlatView 内存拓扑模型过程分析（基于 QEMU 2.0.0）| leoufung</a></li>
<li><a href="https://blog.csdn.net/Shirleylinyuer/article/details/83592286" target="_blank" rel="noopener">Qemu 内存管理代码分析 1：qemu (tag: v3.0.0-rc1) 命令行配置 guest ram 及 machine_class_init 的 QOM 调用 | CSDN</a></li>
<li><a href="https://blog.csdn.net/Shirleylinyuer/article/details/83592614" target="_blank" rel="noopener">Qemu 内存管理主要结构体分析 2：MemoryRegion/AddressSpace/FlatView | CSDN</a></li>
<li><a href="https://blog.csdn.net/Shirleylinyuer/article/details/83592758" target="_blank" rel="noopener">Qemu 内存管理代码分析 3：guest ram 的初始化及分配 | CSDN</a></li>
<li><a href="http://abcdxyzk.github.io/blog/2015/07/28/kvm-pic/" target="_blank" rel="noopener">qemu-kvm 部分流程/源代码分析（多图）| kk Blog</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/20160921?lang=en" target="_blank" rel="noopener">QEMU深入浅出: guest物理内存管理 | IBM 中国 Linux 与虚拟化实验室</a></li>
<li><a href="https://yq.aliyun.com/articles/296913?spm=a2c4e.11153940.0.0.266a2889oNXlFM&amp;type=2" target="_blank" rel="noopener">QEMU 对虚机的地址空间管理 | 阿里云栖社区</a></li>
<li><a href="https://cloud.tencent.com/info/80c1ef1f14b108c6cc87e0e24429c0e8.html" target="_blank" rel="noopener">QEMU 内存管理 | 腾讯云+社区</a></li>
<li><a href="https://blog.csdn.net/u011364612/article/details/51345110" target="_blank" rel="noopener">QEMU 中的内存管理介绍 | CSDN</a></li>
</ul>
<h3 id="KVM-部分"><a href="#KVM-部分" class="headerlink" title="KVM 部分"></a>KVM 部分</h3><ul>
<li><a href="http://liujunming.top/2017/06/26/KVM%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">KVM 初始化过程 | liujunming.top</a></li>
<li><a href="http://liujunming.top/2017/06/27/KVM%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener">KVM 内核模块重要的数据结构 | liujunming.top</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-kvm-mem/index.html" target="_blank" rel="noopener">KVM 内存虚拟化及其实现 | IBM Developer</a></li>
<li><a href="https://nieyong.github.io/wiki_cpu/CPU%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-MMU.html" target="_blank" rel="noopener">CPU 体系架构 - MMU | NieNet</a></li>
<li><a href="https://www.cnblogs.com/linhaostudy/p/7771437.html" target="_blank" rel="noopener">TLB 和 MMU 的区别 | 博客园</a></li>
<li><a href="https://blog.csdn.net/hit_shaoqi/article/details/75633512" target="_blank" rel="noopener">MMU 和 Cache 详解（TLB 机制）| CSDN</a></li>
<li><a href="https://www.binss.me/blog/An-overview-of-the-virtualization-of-x86/" target="_blank" rel="noopener">x86 虚拟化概述 | BinSite</a></li>
</ul>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><blockquote>
<ol>
<li><a href="https://www.cnblogs.com/gcczhongduan/p/5044785.html" target="_blank" rel="noopener">KVM，QEMU 核心分析 | 博客园</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1138790" target="_blank" rel="noopener">内存虚拟化到底是咋整的？- 腾讯云 TStack | 腾讯云+社区</a></li>
<li><a href="https://www.kernelnote.com/entry/kvmguestswap" target="_blank" rel="noopener">从kvm场景下guest访问的内存被swap出去之后说起 | kernelnote</a></li>
<li><a href="https://www.kernelnote.com/entry/linuxcpu-loadcpu" target="_blank" rel="noopener">linux 下 cpu load 和 cpu 使用率的关系 | kernelnote</a></li>
<li><a href="https://www.kernelnote.com/entry/linux" target="_blank" rel="noopener">关于linux下进程栈的研究 | kernelnote</a></li>
<li><a href="https://www.kernelnote.com/entry/hypercall" target="_blank" rel="noopener">虚拟化环境中的hypercall介绍 | kernelnote</a></li>
<li><a href="https://www.kernelnote.com/entry/linux-ksm-merge" target="_blank" rel="noopener">linux ksm 内存 merge机制研究 | kernelnote</a></li>
<li><a href="https://remimin.github.io/2018/09/10/kvm-vmx/" target="_blank" rel="noopener">KVM 虚拟化之 VM Exit/Entry | Min’s Blog</a></li>
<li><a href="http://blog.vmsplice.net/2016/01/qemu-internals-how-guest-physical-ram.html" target="_blank" rel="noopener">QEMU Internals: How guest physical RAM works | Stefan Hajnoczi</a></li>
<li><a href="https://blog.stgolabs.net/2012/03/kvm-virtual-x86-mmu-setup.html" target="_blank" rel="noopener">kvm: virtual x86 mmu setup | Davidlohr Bueso</a></li>
<li><a href="https://www.cnblogs.com/ck1020/p/7795242.html" target="_blank" rel="noopener">GDB 调试 QEMU 源码记录 - 太初有道 | cnblogs</a></li>
<li><a href="https://github.com/xuliker/kde/issues/17" target="_blank" rel="noopener">SIG@QEMU-KVM - kernel-dev-environment | Github </a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMjkzOQ==&amp;mid=2247484572&amp;idx=1&amp;sn=d85fbc5069ec144bdd325b65097ce8ed&amp;chksm=96cdaa08a1ba231e1e1b5ed3a5bd28e74c05e4c038aaeb70f077b7680ddbc29133a856d209f6&amp;mpshare=1&amp;scene=23&amp;srcid=10299joM7LwUdxTxw1gNV4Mo#rd" target="_blank" rel="noopener">向大家汇报，我们连续第二年登上KVM全球开源贡献榜 | 腾讯开源</a></li>
</ol>
</blockquote>
<div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://abelsu7.top/2019/09/02/virtio-in-kvm/">半虚拟化 I/O 框架 virtio</a></li><li><a href="https://abelsu7.top/2019/08/26/compile-kvm-module/">单独编译 KVM 内核模块</a></li><li><a href="https://abelsu7.top/2019/08/11/kvm-api-overview/">Kernel 2.6.32 中的 KVM API 概述</a></li><li><a href="https://abelsu7.top/2019/08/11/qemu-main-func/">QEMU 1.2.0 入口 main() 函数调用流程分析</a></li><li><a href="http://www.borgor.cn/2017-10-23/16f315c1.html">迁移 VMware 虚拟机到 KVM</a></li><li><a href="https://zsnmwy.net/47278.html">微星B350M 虚拟化开启 AMD-V</a></li></ul></div>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-11-05T03:29:36.795Z" itemprop="dateUpdated">2019-11-05 11:29:36</time>
</span><br>


        
        文章发布地址：<a href="/2019/07/07/kvm-memory-virtualization/" target="_blank" rel="external">https://abelsu7.top/2019/07/07/kvm-memory-virtualization/</a>
        
    </div>
    
    <footer>
        <a href="https://abelsu7.top">
            <img src="/img/fong.jpg" alt="Abel Su">
            Abel Su
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/虚拟化/">虚拟化</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/&title=《QEMU 内存虚拟化源码分析》 — Keep Coding&pic=https://abelsu7.top/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/&title=《QEMU 内存虚拟化源码分析》 — Keep Coding&source=
基于 QEMU 1.2.0、Kernel 2.6.32


                
                    
        ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《QEMU 内存虚拟化源码分析》 — Keep Coding&url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/&via=https://abelsu7.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/07/07/qemu-nbd/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">使用 qemu-nbd 挂载虚拟机镜像</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/07/07/perf-quick-guides/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Linux 下使用 Perf 分析系统性能</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment v" id="vcomments"></div>
    <!-- <div class="comment" id="comment"></div> -->
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
    <!-- <script src="//t1.aixinxi.net/o_1c3n4pim01nl3jg91b6l1kjtkvsa.js"></script> -->
    <!-- <script src="/js/Valine.min.js"></script> -->
    <!-- <script src="https://cdnjs.cat.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script> -->
    <script src="//cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            av: AV,
            // el: '#comments',
            el: '#vcomments',
            emoticon_url: 'https://abelsu7.top/alu', //表情图片网址
            emoticon_list: ["赞一个.png","坐等.png","长草.png","阴暗.png","邪恶.png","小眼睛.png","想一想.png","献黄瓜.png","献花.png","喜极而泣.png","无语.png","无所谓.png","无奈.png","投降.png","深思.png","期待.png","狂汗.png","蜡烛.png","看不见.png","惊喜.png","击掌.png","欢呼.png","得意.png","不出所料.png","观察.png"],//表情图片文件名
            // notify: 'false' == 'false',
            // verify: 'false' == 'false',
            // notify: 'false',
            // verify: 'false',
            notify: false,
            verify: false,
            appId: "aP2YQo0mfrRpTLrLb1bchILb-gzGzoHsz",
            appKey: "Cp82umQdGScRRFUYLmob6yyK",
            avatar: "mp",
            placeholder: "Write a comment",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->











</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-item switch">切换</span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                Abel Su &copy;
                    
                        2018 -
                            
                                2019
            </span>
            <span>
                
                    <a href="http://beian.miit.gov.cn/" target="_blank">
                        粤ICP备16068788号-2
                    </a>
                    <br>
                    
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/&title=《QEMU 内存虚拟化源码分析》 — Keep Coding&pic=https://abelsu7.top/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/&title=《QEMU 内存虚拟化源码分析》 — Keep Coding&source=
基于 QEMU 1.2.0、Kernel 2.6.32


                
                    
        ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《QEMU 内存虚拟化源码分析》 — Keep Coding&url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/&via=https://abelsu7.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://abelsu7.top/2019/07/07/kvm-memory-virtualization/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACOklEQVR42u3awY6DMAxFUf7/pxlptp3CfTaMFOdmVVEacli4jp3jwOP8HdfXPz9/DjLbt28fGDJkyFiWcV6Obw8m93/7Fb9C1iZDhox9GCSYkjs7S0lDswwZMmTwgEsWwb+VIUOGjKcC7glGOht5fTJkyNiZwTel5DopopEg+8peXIYMGQsy0sbAf35+sb8hQ4aMRRhnOPgMJOzyZsPNqmTIkDGawduKtaStFkb5djfoTsiQIWNZRq2w1dnu1o6F3VyRIUPGBoxW4xAfy6g1D4otARkyZIxj1FK9tM3ZKbfFqaEMGTIGMTqF+zT5I0G5dVhNhgwZQxm1RfPASubssGXIkLEDgzcG0uCYNgz4ka9WC1OGDBnLMvpbUDJDpwkRJJcyZMgYzeiU9dNUkpfS0manDBkypjI6W01eJkOJXZh0HrXYLEOGjMUZ6XJ5ukaOWfCjGMVymwwZMhZk1Dal/YDL0z70ByBDhowNGLxARgIlB/Mi3c1sMmTIGM3oTMqL++mzOgmoDBky5jFIGE0Tu+v7+XGK1gELGTJkjGPwpJAX1NLX1CrbyZAhYzSjFgprRfxOEhn/e8iQIWMQ4wwHh9WKd7VmpwwZMmYz0mD3bCmfFOxeaRjIkCFjQQYJsmm5P+hFpJlsJ2+VIUPG4oyngmyaXNaC/h9XZMiQISPcTNaaAekhjFamKUOGjNGMWhjl7NpLkSFDxg6MWom/1rbkpf9WJ1aGDBmDGE81Bviv0s3wU4U8GTJkLMj4Ac5+Qc9P+ObnAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
