<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?c61262c25ca5d4ed66df331a31b5bf49"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="cc3c_UncRv21aEZwqejVxKpUMR7h9ldNUTeYjawUS-g">
    
    
    <meta name="baidu-site-verification" content="HnoV7q61W5">
    
    
    
    <title>《快学 Go 语言》笔记 | Keep Coding | 苏易北</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="读书,Go">
    <meta name="description" content="快学 Go 语言 - 老钱 | 知乎专栏《快学 Go 语言》最新内容大全代码在线运行 - 在线工具">
<meta name="keywords" content="读书,Go">
<meta property="og:type" content="article">
<meta property="og:title" content="《快学 Go 语言》笔记">
<meta property="og:url" content="https://abelsu7.top/2019/01/04/quickgo-notes/index.html">
<meta property="og:site_name" content="Keep Coding">
<meta property="og:description" content="快学 Go 语言 - 老钱 | 知乎专栏《快学 Go 语言》最新内容大全代码在线运行 - 在线工具">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/zhihu.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/star.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/star.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/tool.ico">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/star.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/cover.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-team.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/pointer.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/program.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/slice.jpg">
<meta property="og:image" content="https://notes.abelsu7.top/_media/star.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/slice-cut.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/map-ptr.png">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/byte-and-rune.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/str-structure.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-struct.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-interface.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-routine.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/process-thread.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-routine-status.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-routine.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/channel-struct.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/unsafe-pointer.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/uintptr.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/address-ptr.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/string-slice-unsafe.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-interface.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/var-type-value.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/wechat.svg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/go-get-install-build.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/diamond.jpg">
<meta property="og:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/vendor.jpg">
<meta property="og:updated_time" content="2019-09-01T13:04:11.631Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《快学 Go 语言》笔记">
<meta name="twitter:description" content="快学 Go 语言 - 老钱 | 知乎专栏《快学 Go 语言》最新内容大全代码在线运行 - 在线工具">
<meta name="twitter:image" content="https://abelsu7.top/2019/01/04/quickgo-notes/zhihu.svg">
    
        <link rel="alternate" type="application/atom+xml" title="Keep Coding" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <link rel="stylesheet" href="/css/prism/prism-tomorrow-night.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-list-ul"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/back_blue.png)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/fong.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Abel Su</h5>
          <a href="mailto:abelsu7@gmail.com" title="abelsu7@gmail.com" class="mail">abelsu7@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives/"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://notes.abelsu7.top"  >
                <i class="icon icon-lg icon-sticky-note"></i>
                笔记
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/abelsu7"  >
                <i class="icon icon-lg icon-github"></i>
                代码
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/friends/"  >
                <i class="icon icon-lg icon-user"></i>
                友链
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/bookmarks/"  >
                <i class="icon icon-lg icon-bookmark"></i>
                收藏
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/books/"  >
                <i class="icon icon-lg icon-book"></i>
                读书
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/movies/"  >
                <i class="icon icon-lg icon-film"></i>
                影视
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/games/"  >
                <i class="icon icon-lg icon-gamepad"></i>
                游戏
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://notes.abelsu7.top/#/links/wechat"  >
                <i class="icon icon-lg icon-wechat"></i>
                微信
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/2018/09/21/how-to-learn-coding/"  >
                <i class="icon icon-lg icon-code"></i>
                学习
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/wiki/"  >
                <i class="icon icon-lg icon-sort-alpha-asc"></i>
                速查
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about/"  >
                <i class="icon icon-lg icon-info-circle"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">《快学 Go 语言》笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">《快学 Go 语言》笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-01-04T02:05:15.000Z" itemprop="datePublished" class="page-time">
  2019-01-04
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#目录"><span class="post-toc-text">目录</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-预备知识"><span class="post-toc-text">1. 预备知识</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Go-语言的「元团队」"><span class="post-toc-text">Go 语言的「元团队」</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Hello-World"><span class="post-toc-text">Hello World</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设置-GOPATH-环境变量"><span class="post-toc-text">设置 GOPATH 环境变量</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-变量"><span class="post-toc-text">2. 变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义变量的三种方式"><span class="post-toc-text">定义变量的三种方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#全局变量和局部变量"><span class="post-toc-text">全局变量和局部变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#变量与常量"><span class="post-toc-text">变量与常量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针类型"><span class="post-toc-text">指针类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Go-语言基础类型大全"><span class="post-toc-text">Go 语言基础类型大全</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-分支与循环"><span class="post-toc-text">3. 分支与循环</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#if-else-语句"><span class="post-toc-text">if else 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#switch-语句"><span class="post-toc-text">switch 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for-循环"><span class="post-toc-text">for 循环</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#循环控制"><span class="post-toc-text">循环控制</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-数组"><span class="post-toc-text">4. 数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组变量的定义"><span class="post-toc-text">数组变量的定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组的访问"><span class="post-toc-text">数组的访问</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组的下标越界检查"><span class="post-toc-text">数组的下标越界检查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组赋值"><span class="post-toc-text">数组赋值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组的遍历"><span class="post-toc-text">数组的遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-切片"><span class="post-toc-text">5. 切片</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的创建"><span class="post-toc-text">切片的创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的初始化"><span class="post-toc-text">切片的初始化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#空切片"><span class="post-toc-text">空切片</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的赋值"><span class="post-toc-text">切片的赋值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的遍历"><span class="post-toc-text">切片的遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的追加"><span class="post-toc-text">切片的追加</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的域是只读的"><span class="post-toc-text">切片的域是只读的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的切割"><span class="post-toc-text">切片的切割</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数组变切片"><span class="post-toc-text">数组变切片</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#copy-函数"><span class="post-toc-text">copy 函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的扩容点"><span class="post-toc-text">切片的扩容点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-字典"><span class="post-toc-text">6. 字典</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典的创建"><span class="post-toc-text">字典的创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典的读写"><span class="post-toc-text">字典的读写</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典-key-不存在会怎么样？"><span class="post-toc-text">字典 key 不存在会怎么样？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典的遍历"><span class="post-toc-text">字典的遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程安全"><span class="post-toc-text">线程安全</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字典变量里存的是什么？"><span class="post-toc-text">字典变量里存的是什么？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-字符串"><span class="post-toc-text">7. 字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#按字节遍历"><span class="post-toc-text">按字节遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#按字符-rune-遍历"><span class="post-toc-text">按字符 rune 遍历</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串的内存表示"><span class="post-toc-text">字符串的内存表示</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串是只读的"><span class="post-toc-text">字符串是只读的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串的切割"><span class="post-toc-text">字符串的切割</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字节切片和字符串的相互转换"><span class="post-toc-text">字节切片和字符串的相互转换</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-结构体"><span class="post-toc-text">8. 结构体</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体类型的定义"><span class="post-toc-text">结构体类型的定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体变量的创建"><span class="post-toc-text">结构体变量的创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#零值结构体和-nil-结构体"><span class="post-toc-text">零值结构体和 nil 结构体</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体的内存大小"><span class="post-toc-text">结构体的内存大小</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体的拷贝"><span class="post-toc-text">结构体的拷贝</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体中的数组和切片"><span class="post-toc-text">结构体中的数组和切片</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体的参数传递"><span class="post-toc-text">结构体的参数传递</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体方法"><span class="post-toc-text">结构体方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结构体的指针方法"><span class="post-toc-text">结构体的指针方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内嵌结构体"><span class="post-toc-text">内嵌结构体</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#匿名内嵌结构体"><span class="post-toc-text">匿名内嵌结构体</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Go-语言的结构体没有多态性"><span class="post-toc-text">Go 语言的结构体没有多态性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-接口"><span class="post-toc-text">9. 接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#空接口"><span class="post-toc-text">空接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口变量的本质"><span class="post-toc-text">接口变量的本质</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#用接口来模拟多态"><span class="post-toc-text">用接口来模拟多态</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口的组合继承"><span class="post-toc-text">接口的组合继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口变量的赋值"><span class="post-toc-text">接口变量的赋值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指向指针的接口变量"><span class="post-toc-text">指向指针的接口变量</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-错误和异常"><span class="post-toc-text">10. 错误和异常</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#错误接口"><span class="post-toc-text">错误接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#错误处理首体验"><span class="post-toc-text">错误处理首体验</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#体验-Redis-的错误处理"><span class="post-toc-text">体验 Redis 的错误处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#异常与捕捉"><span class="post-toc-text">异常与捕捉</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多个-defer-语句"><span class="post-toc-text">多个 defer 语句</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-协程"><span class="post-toc-text">11. 协程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程的启动"><span class="post-toc-text">协程的启动</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#子协程异常退出"><span class="post-toc-text">子协程异常退出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程的本质"><span class="post-toc-text">协程的本质</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设置线程数"><span class="post-toc-text">设置线程数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程的应用"><span class="post-toc-text">协程的应用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-通道"><span class="post-toc-text">12. 通道</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建通道"><span class="post-toc-text">创建通道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读写通道"><span class="post-toc-text">读写通道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读写阻塞"><span class="post-toc-text">读写阻塞</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关闭通道"><span class="post-toc-text">关闭通道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通道写安全"><span class="post-toc-text">通道写安全</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多路通道"><span class="post-toc-text">多路通道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#非阻塞读写"><span class="post-toc-text">非阻塞读写</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通道内部结构"><span class="post-toc-text">通道内部结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-并发与安全"><span class="post-toc-text">13. 并发与安全</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程不安全的字典"><span class="post-toc-text">线程不安全的字典</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程安全的字典"><span class="post-toc-text">线程安全的字典</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#避免锁复制"><span class="post-toc-text">避免锁复制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用匿名锁字段"><span class="post-toc-text">使用匿名锁字段</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用读写锁"><span class="post-toc-text">使用读写锁</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-魔术变性指针"><span class="post-toc-text">14. 魔术变性指针</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#unsafe-Pointer"><span class="post-toc-text">unsafe.Pointer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#指针的加减运算"><span class="post-toc-text">指针的加减运算</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#切片的内部结构"><span class="post-toc-text">切片的内部结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符串与切片的高效转换"><span class="post-toc-text">字符串与切片的高效转换</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#深入接口变量的赋值"><span class="post-toc-text">深入接口变量的赋值</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15-反射"><span class="post-toc-text">15. 反射</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#反射的目标"><span class="post-toc-text">反射的目标</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#reflect-kind"><span class="post-toc-text">reflect.kind</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#反射的基础代码"><span class="post-toc-text">反射的基础代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#reflect-Type"><span class="post-toc-text">reflect.Type</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#reflect-Value"><span class="post-toc-text">reflect.Value</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Go-语言官方的反射三大定律"><span class="post-toc-text">Go 语言官方的反射三大定律</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-包管理-GOPATH-和-Vendor"><span class="post-toc-text">16. 包管理 GOPATH 和 Vendor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#系统包路径"><span class="post-toc-text">系统包路径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#全局管理-GOPATH"><span class="post-toc-text">全局管理 GOPATH</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#友好的包路径"><span class="post-toc-text">友好的包路径</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#编写第一个模块"><span class="post-toc-text">编写第一个模块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#替换导入包名"><span class="post-toc-text">替换导入包名</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#无名导入"><span class="post-toc-text">无名导入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#go-get-build-install"><span class="post-toc-text">go get/build/install</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#局部管理-Vendor"><span class="post-toc-text">局部管理 Vendor</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-quickgo-notes"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">《快学 Go 语言》笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-01-04 10:05:15" datetime="2019-01-04T02:05:15.000Z"  itemprop="datePublished">2019-01-04</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p><img src="/2019/01/04/quickgo-notes/zhihu.svg"><a href="https://zhuanlan.zhihu.com/quickgo" target="_blank" rel="noopener">快学 Go 语言 - 老钱 | 知乎专栏</a><img src="/2019/01/04/quickgo-notes/star.svg"><br><img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/OVEPFX6YRBgdq2M_WVns7Q" target="_blank" rel="noopener">《快学 Go 语言》最新内容大全</a><img src="/2019/01/04/quickgo-notes/star.svg"><br><img src="/2019/01/04/quickgo-notes/tool.ico" width="16"><a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">代码在线运行 - 在线工具</a><img src="/2019/01/04/quickgo-notes/star.svg"></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/cover.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<a id="more"></a>
<p><strong>更新中…</strong></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#目录">目录</a></li>
<li><a href="#1-预备知识">1. 预备知识</a><ul>
<li><a href="#Go-语言的「元团队」">Go 语言的「元团队」</a></li>
<li><a href="#Hello-World">Hello World</a></li>
<li><a href="#设置-GOPATH-环境变量">设置 GOPATH 环境变量</a></li>
</ul>
</li>
<li><a href="#2-变量">2. 变量</a><ul>
<li><a href="#定义变量的三种方式">定义变量的三种方式</a></li>
<li><a href="#全局变量和局部变量">全局变量和局部变量</a></li>
<li><a href="#变量与常量">变量与常量</a></li>
<li><a href="#指针类型">指针类型</a></li>
<li><a href="#Go-语言基础类型大全">Go 语言基础类型大全</a></li>
</ul>
</li>
<li><a href="#3-分支与循环">3. 分支与循环</a><ul>
<li><a href="#if-else-语句">if else 语句</a></li>
<li><a href="#switch-语句">switch 语句</a></li>
<li><a href="#for-循环">for 循环</a></li>
<li><a href="#循环控制">循环控制</a></li>
</ul>
</li>
<li><a href="#4-数组">4. 数组</a><ul>
<li><a href="#数组变量的定义">数组变量的定义</a></li>
<li><a href="#数组的访问">数组的访问</a></li>
<li><a href="#数组的下标越界检查">数组的下标越界检查</a></li>
<li><a href="#数组赋值">数组赋值</a></li>
<li><a href="#数组的遍历">数组的遍历</a></li>
</ul>
</li>
<li><a href="#5-切片">5. 切片</a><ul>
<li><a href="#切片的创建">切片的创建</a></li>
<li><a href="#切片的初始化">切片的初始化</a></li>
<li><a href="#空切片">空切片</a></li>
<li><a href="#切片的赋值">切片的赋值</a></li>
<li><a href="#切片的遍历">切片的遍历</a></li>
<li><a href="#切片的追加">切片的追加</a></li>
<li><a href="#切片的域是只读的">切片的域是只读的</a></li>
<li><a href="#切片的切割">切片的切割</a></li>
<li><a href="#数组变切片">数组变切片</a></li>
<li><a href="#copy-函数">copy 函数</a></li>
<li><a href="#切片的扩容点">切片的扩容点</a></li>
</ul>
</li>
<li><a href="#6-字典">6. 字典</a><ul>
<li><a href="#字典的创建">字典的创建</a></li>
<li><a href="#字典的读写">字典的读写</a></li>
<li><a href="#字典-key-不存在会怎么样？">字典 key 不存在会怎么样？</a></li>
<li><a href="#字典的遍历">字典的遍历</a></li>
<li><a href="#线程安全">线程安全</a></li>
<li><a href="#字典变量里存的是什么？">字典变量里存的是什么？</a></li>
</ul>
</li>
<li><a href="#7-字符串">7. 字符串</a><ul>
<li><a href="#按字节遍历">按字节遍历</a></li>
<li><a href="#按字符-rune-遍历">按字符 rune 遍历</a></li>
<li><a href="#字符串的内存表示">字符串的内存表示</a></li>
<li><a href="#字符串是只读的">字符串是只读的</a></li>
<li><a href="#字符串的切割">字符串的切割</a></li>
<li><a href="#字节切片和字符串的相互转换">字节切片和字符串的相互转换</a></li>
</ul>
</li>
<li><a href="#8-结构体">8. 结构体</a><ul>
<li><a href="#结构体类型的定义">结构体类型的定义</a></li>
<li><a href="#结构体变量的创建">结构体变量的创建</a></li>
<li><a href="#零值结构体和-nil-结构体">零值结构体和 nil 结构体</a></li>
<li><a href="#结构体的内存大小">结构体的内存大小</a></li>
<li><a href="#结构体的拷贝">结构体的拷贝</a></li>
<li><a href="#结构体中的数组和切片">结构体中的数组和切片</a></li>
<li><a href="#结构体的参数传递">结构体的参数传递</a></li>
<li><a href="#结构体方法">结构体方法</a></li>
<li><a href="#结构体的指针方法">结构体的指针方法</a></li>
<li><a href="#内嵌结构体">内嵌结构体</a></li>
<li><a href="#匿名内嵌结构体">匿名内嵌结构体</a></li>
<li><a href="#Go-语言的结构体没有多态性">Go 语言的结构体没有多态性</a></li>
</ul>
</li>
<li><a href="#9-接口">9. 接口</a><ul>
<li><a href="#空接口">空接口</a></li>
<li><a href="#接口变量的本质">接口变量的本质</a></li>
<li><a href="#用接口来模拟多态">用接口来模拟多态</a></li>
<li><a href="#接口的组合继承">接口的组合继承</a></li>
<li><a href="#接口变量的赋值">接口变量的赋值</a></li>
<li><a href="#指向指针的接口变量">指向指针的接口变量</a></li>
</ul>
</li>
<li><a href="#10-错误和异常">10. 错误和异常</a><ul>
<li><a href="#错误接口">错误接口</a></li>
<li><a href="#错误处理首体验">错误处理首体验</a></li>
<li><a href="#体验-Redis-的错误处理">体验 Redis 的错误处理</a></li>
<li><a href="#异常与捕捉">异常与捕捉</a></li>
<li><a href="#多个-defer-语句">多个 defer 语句</a></li>
</ul>
</li>
<li><a href="#11-协程">11. 协程</a><ul>
<li><a href="#协程的启动">协程的启动</a></li>
<li><a href="#子协程异常退出">子协程异常退出</a></li>
<li><a href="#协程的本质">协程的本质</a></li>
<li><a href="#设置线程数">设置线程数</a></li>
<li><a href="#协程的应用">协程的应用</a></li>
</ul>
</li>
<li><a href="#12-通道">12. 通道</a><ul>
<li><a href="#创建通道">创建通道</a></li>
<li><a href="#读写通道">读写通道</a></li>
<li><a href="#读写阻塞">读写阻塞</a></li>
<li><a href="#关闭通道">关闭通道</a></li>
<li><a href="#通道写安全">通道写安全</a></li>
<li><a href="#多路通道">多路通道</a></li>
<li><a href="#非阻塞读写">非阻塞读写</a></li>
<li><a href="#通道内部结构">通道内部结构</a></li>
</ul>
</li>
<li><a href="#13-并发与安全">13. 并发与安全</a><ul>
<li><a href="#线程不安全的字典">线程不安全的字典</a></li>
<li><a href="#线程安全的字典">线程安全的字典</a></li>
<li><a href="#避免锁复制">避免锁复制</a></li>
<li><a href="#使用匿名锁字段">使用匿名锁字段</a></li>
<li><a href="#使用读写锁">使用读写锁</a></li>
</ul>
</li>
<li><a href="#14-魔术变性指针">14. 魔术变性指针</a><ul>
<li><a href="#unsafe-Pointer">unsafe.Pointer</a></li>
<li><a href="#指针的加减运算">指针的加减运算</a></li>
<li><a href="#切片的内部结构">切片的内部结构</a></li>
<li><a href="#字符串与切片的高效转换">字符串与切片的高效转换</a></li>
<li><a href="#深入接口变量的赋值">深入接口变量的赋值</a></li>
</ul>
</li>
<li><a href="#15-反射">15. 反射</a><ul>
<li><a href="#反射的目标">反射的目标</a></li>
<li><a href="#reflect-kind">reflect.kind</a></li>
<li><a href="#反射的基础代码">反射的基础代码</a></li>
<li><a href="#reflect-Type">reflect.Type</a></li>
<li><a href="#reflect-Value">reflect.Value</a></li>
<li><a href="#Go-语言官方的反射三大定律">Go 语言官方的反射三大定律</a></li>
</ul>
</li>
<li><a href="#16-包管理-GOPATH-和-Vendor">16. 包管理 GOPATH 和 Vendor</a><ul>
<li><a href="#系统包路径">系统包路径</a></li>
<li><a href="#全局管理-GOPATH">全局管理 GOPATH</a></li>
<li><a href="#友好的包路径">友好的包路径</a></li>
<li><a href="#编写第一个模块">编写第一个模块</a></li>
<li><a href="#替换导入包名">替换导入包名</a></li>
<li><a href="#无名导入">无名导入</a></li>
<li><a href="#go-get-build-install">go get/build/install</a></li>
<li><a href="#局部管理-Vendor">局部管理 Vendor</a></li>
</ul>
</li>
</ul>
<h2 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/gbz9-gXZjE05L-8L2lL-UA" target="_blank" rel="noopener">《快学 Go 语言》第 1 课 —— Hello World</a></p>
</blockquote>
<h3 id="Go-语言的「元团队」"><a href="#Go-语言的「元团队」" class="headerlink" title="Go 语言的「元团队」"></a>Go 语言的「元团队」</h3><p>很多著名的计算机语言都是那么一两个人业余时间捣鼓出来的，但是 Go 语言是 <strong>Google</strong> 养着一帮团队打造出来的。这个团队非常豪华，它被称之为 <strong>Go Team</strong>，成员之一就有大名鼎鼎的 Unix 操作系统的创造者 <strong>Ken Thompson</strong>，C 语言就是他和已经过世的 <a href="https://abelsu7.top/2018/09/28/awesome-coder/#11-C%E8%AF%AD%E8%A8%80%E5%92%8CUnix%E4%B9%8B%E7%88%B6%EF%BC%9ADennis-Ritchie">Dennis Ritchie</a> 一起发明的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-team.jpg" alt="图中翘着二郎腿的谢顶老头就是 Ken Thompson" title>
                </div>
                <div class="image-caption">图中翘着二郎腿的谢顶老头就是 Ken Thompson</div>
            </figure>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;hello world!&quot;)
}
</code></pre>
<p>直接运行源文件<code>main.go</code>：</p>
<pre><code class="lang-bash">&gt; go run main.go
</code></pre>
<p>编译二进制文件：</p>
<pre><code class="lang-bash">&gt; go build main.go
</code></pre>
<h3 id="设置-GOPATH-环境变量"><a href="#设置-GOPATH-环境变量" class="headerlink" title="设置 GOPATH 环境变量"></a>设置 GOPATH 环境变量</h3><p>环境变量 <strong>GOPATH</strong> 指向一个目录，以后我们下载的<strong>第三方包</strong>和我们<strong>自己开发的程序代码包</strong>都要放在这个目录里面，它就是 <strong>Go 语言的工作目录</strong>。</p>
<p>当你在源码里使用<code>import</code>语句导入一个包时，编译器都会来 GOPATH 目录下面寻找这个包。</p>
<p><strong>Mac</strong> 和 <strong>Linux</strong> 用户的 <strong>GOPATH</strong> 通常设置为<code>~/go</code>。将下面环境变量的设置命令追加到<code>~/.bashrc</code>或<code>~/.zshrc</code>的文件末尾，然后重启终端：</p>
<pre><code class="lang-bash">&gt; export GOPATH=~/go
</code></pre>
<blockquote>
<p>在 Go 语言的<strong>早期版本</strong>中，还需要用户设置 <strong>GOROOT</strong> 环境变量,指代 <strong>Go 语言开发包的目录</strong>，类似于 Java 语言里面的<code>JAVA_HOME</code>环境变量。不过<strong>后来 Go 取消了 GOROOT 的设置</strong>，也就是说用户可以不必再操心这个环境变量了，当它不存在就行。</p>
</blockquote>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/PFZBxYH-L5svUHONIT4YLQ" target="_blank" rel="noopener">《快学 Go 语言》第 2 课 —— 变量什么的最讨厌了</a></p>
</blockquote>
<h3 id="定义变量的三种方式"><a href="#定义变量的三种方式" class="headerlink" title="定义变量的三种方式"></a>定义变量的三种方式</h3><pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 int = 42 // 显式定义，可读性最强
    var s2 = 42 // 编译器自动推导变量类型
    s3 := 42 // 自动推导类型 + 赋值
    fmt.Println(s1, s2, s3)
}

-------------
42 42 42
</code></pre>
<blockquote>
<ol>
<li>如果一个变量很重要，建议使用第一种<strong>显式声明类型</strong>的方式来定义，比如<strong>全局变量</strong>的定义就比较偏好第一种定义方式。</li>
<li>如果要使用一个不那么重要的<strong>局部变量</strong>，就可以使用第三种，比如<strong>循环下标变量</strong>。</li>
<li><code>var</code>关键字无法直接写进循环条件的初始化语句中。</li>
</ol>
</blockquote>
<pre><code class="lang-go">for i:=0; i&lt;10; i++ {
  doSomething()
}
</code></pre>
<p>如果在第一种声明变量的时候<strong>不赋初值</strong>，编译器就会<strong>自动赋予相应类型的「零值」</strong>，不同类型的零值不尽相同，比如<strong>字符串</strong>的零值不是<code>nil</code>，而是<strong>空串</strong>，<strong>整型</strong>的零值就是<code>0</code>，<strong>布尔类型</strong>的零值是<code>false</code>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var i int
    fmt.Println(i)
}

-----------
0
</code></pre>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p><strong>局部变量</strong>定义在<strong>函数内部</strong>，函数调用结束就<strong>随之消亡</strong>。<strong>全局变量</strong>则定义在<strong>函数外部</strong>，在程序运行期间会<strong>一直存在</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

var globali int = 24

func main() {
    var locali int = 42
    fmt.Println(globali, locali)
}

---------------
24 42
</code></pre>
<ul>
<li><strong>首字母大写</strong>的全局变量：<strong>公开</strong>的全局变量</li>
<li><strong>首字母小写</strong>的全局变量：<strong>内部</strong>的全局变量</li>
</ul>
<blockquote>
<p><strong>内部的全局变量</strong>只有<strong>当前包内的代码可以访问</strong>，外面包的代码是不能看见的。另外，Go 语言<strong>没有静态变量</strong>。</p>
</blockquote>
<h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><p><strong>常量</strong>关键字<code>const</code>用来定义常量，可以是全局常量也可以是局部常量，<strong>大小写规则与变量一致</strong>。常量必须<strong>初始化</strong>，因为它<strong>无法二次赋值</strong>。不可以对常量进行修改，否则编译器会报错。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

const globali int = 24

func main() {
    const locali int = 42
    fmt.Println(globali, locali)
}

---------------
24 42
</code></pre>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p><strong>Go 语言</strong>被称为<strong>互联网时代的 C 语言</strong>，它延续使用了 C 语言的指针类型。<strong>指针符号</strong><code>*</code>和<strong>取地址符</strong><code>&amp;</code>在功能和使用上同 C 语言几乎一模一样。同 C 语言一样，指针还支持<strong>二级指针、三级指针</strong>，不过在日常应用中很少遇到。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var value int = 42
    var p1 *int = &amp;value
    var p2 **int = &amp;p1
    var p3 ***int = &amp;p2
    fmt.Println(p1, p2, p3)
    fmt.Println(*p1, **p2, ***p3)
}

----------
0xc4200160a0 0xc42000c028 0xc42000c030
42 42 42
</code></pre>
<blockquote>
<p><strong>指针变量</strong>本质上就是一个<strong>整型变量</strong>，里面存储的值是<strong>另一个变量的内存地址</strong>。<code>*</code>和<code>&amp;</code>符号都只是它的<strong>语法糖</strong>，是用来在形式上方便使用和理解指针的。<code>*</code>操作符存在<strong>两次内存读写</strong>，第一次获取指针变量的值，也就是<strong>内存地址</strong>，然后再去拿这个内存地址所在的<strong>变量内容</strong>。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/pointer.jpg" alt="指针变量" title>
                </div>
                <div class="image-caption">指针变量</div>
            </figure>
<p>如果<strong>普通变量</strong>是一个<strong>储物箱</strong>，那么<strong>指针变量</strong>就是<strong>另一个储物箱</strong>，这个储物箱里存放了<strong>普通变量所在储物箱的钥匙</strong>。通过多级指针来读取变量值就好比在玩一个解密游戏。</p>
<h3 id="Go-语言基础类型大全"><a href="#Go-语言基础类型大全" class="headerlink" title="Go 语言基础类型大全"></a>Go 语言基础类型大全</h3><pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    // 有符号整数，可以表示正负
    var a int8 = 1 // 1 字节
    var b int16 = 2 // 2 字节
    var c int32 = 3 // 4 字节
    var d int64 = 4 // 8 字节
    fmt.Println(a, b, c, d)

    // 无符号整数，只能表示非负数
    var ua uint8 = 1
    var ub uint16 = 2
    var uc uint32 = 3
    var ud uint64 = 4
    fmt.Println(ua, ub, uc, ud)

    // int 类型，在32位机器上占4个字节，在64位机器上占8个字节
    var e int = 5
    var ue uint = 5
    fmt.Println(e, ue)

    // bool 类型
    var f bool = true
    fmt.Println(f)

    // 字节类型
    var j byte = &#39;a&#39;
    fmt.Println(j)

    // 字符串类型
    var g string = &quot;abcdefg&quot;
    fmt.Println(g)

    // 浮点数
    var h float32 = 3.14
    var i float64 = 3.141592653
    fmt.Println(h, i)
}

-------------
1 2 3 4
1 2 3 4
5 5
true
abcdefg
3.14 3.141592653
97
</code></pre>
<p>另外还有几个不太常用的数据类型：</p>
<ul>
<li><strong>复数</strong>类型：<code>complex64</code>和<code>complex128</code></li>
<li><strong>Unicode 字符</strong>类型：<code>rune</code></li>
<li><strong>指针</strong>类型：<code>uinitptr</code></li>
</ul>
<h2 id="3-分支与循环"><a href="#3-分支与循环" class="headerlink" title="3. 分支与循环"></a>3. 分支与循环</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/49pVEDXSZblNNaSZS1vlXw" target="_blank" rel="noopener">《快学 Go 语言》第 3 课 —— 分支与循环</a></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/program.jpg" alt="程序 = 数据结构 + 算法" title>
                </div>
                <div class="image-caption">程序 = 数据结构 + 算法</div>
            </figure>
<p>上面的等式并不是什么严格的数学公式，它只是<strong>对一般程序的简单认知</strong>：</p>
<ol>
<li><strong>数据结构</strong>是<strong>内存数据关系</strong>的<strong>静态表示</strong>，<strong>算法</strong>是数据结构从一个状态变化到另一个状态需要执行的<strong>机器指令序列</strong>；</li>
<li>数据结构是<strong>静态的</strong>，算法是<strong>动态的</strong>；</li>
<li>数据结构是<strong>状态</strong>，算法是<strong>状态的变化</strong>。</li>
</ol>
<h3 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h3><p>Go 语言<strong>没有三元操作符</strong><code>a &gt; b ? a : b</code>，另外<strong>分支与循环语句</strong>的<strong>条件</strong>也<strong>不需要用括号括起来</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(sign(max(min(24, 42), max(24, 42))))
}

func max(a int, b int) int {
    if a &gt; b {
        return a
    }
    return b
}

func min(a int, b int) int {
    if a &lt; b {
        return a
    }
    return b
}

func sign(a int) int {
    if a &gt; 0 {
        return 1
    } else if a &lt; 0 {
        return -1
    } else {
        return 0
    }
}

------------
1
</code></pre>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><strong>switch 语句</strong>有两种<strong>匹配模式</strong>：一种是<strong>变量值匹配</strong>，另一种是<strong>表达式匹配</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(prize1(60))
    fmt.Println(prize2(60))
}

// 值匹配
func prize1(score int) string {
    switch score / 10 {
    case 0, 1, 2, 3, 4, 5:
        return &quot;差&quot;
    case 6, 7:
        return &quot;及格&quot;
    case 8:
        return &quot;良&quot;
    default:
        return &quot;优&quot;
    }
}

// 表达式匹配
func prize2(score int) string {
    // 注意 switch 后面什么也没有
    switch {
        case score &lt; 60:
            return &quot;差&quot;
        case score &lt; 80:
            return &quot;及格&quot;
        case score &lt; 90:
            return &quot;良&quot;
        default:
            return &quot;优&quot;
    }
}
</code></pre>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>Go 语言虽然没有提供 while 和 do while 语句，不过这两个语句都可以使用 for 循环的形式来模拟。平时使用 while 语句来写死循环<code>while (true) {}</code>，Go 语言可以这么写：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    for {
        fmt.Println(&quot;hello world!&quot;)
    }
}
</code></pre>
<p>或者：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    for true {
        fmt.Println(&quot;hello world!&quot;)
    }
}
</code></pre>
<p>for 什么条件也不带的，相当于 <strong>loop</strong> 语句。for 带一个条件的，相当于 <strong>while</strong> 语句。for 带三个条件的就是普通的 <strong>for</strong> 语句。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    for i := 0; i &lt; 10; i++ {
        fmt.Println(&quot;hello world!&quot;)
    }
}
</code></pre>
<h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p>Go 语言支持 <strong>continue</strong> 和 <strong>break</strong> 语句来控制循环，除此之外还支持 <strong>goto</strong> 语句。</p>
<h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/HETSijks5UlCE1L3h_Fj_A" target="_blank" rel="noopener">《快学 Go 语言》第 4 课 —— 低调的数组</a></p>
</blockquote>
<p>Go 语言里面的数组其实很不常用，这是因为数组是<strong>定长静态</strong>的，一旦定义好长度就无法更改，而且<strong>不同长度的数组属于不同的类型</strong>，之间不能相互转换与赋值，用起来多有不便。</p>
<p><strong>切片 (slice) </strong>是动态的数组，是<strong>可以扩充内容增加长度的数组</strong>。当切片长度不变时，用起来和普通数组一样。<strong>当长度不同时，它们也属于相同的类型，之间可以相互赋值</strong>。这就决定了数组的应用领域都广泛的被切片取代了。</p>
<blockquote>
<p>在切片的<strong>底层实现</strong>中，<strong>数组是切片的基石</strong>，是切片的特殊语法隐藏了内部的细节，让用户不能直接看到内部隐藏的数组。可以说<strong>切片是数组的一个包装</strong>。</p>
</blockquote>
<h3 id="数组变量的定义"><a href="#数组变量的定义" class="headerlink" title="数组变量的定义"></a>数组变量的定义</h3><p>只声明类型，<strong>不赋初值</strong>，这时编译器会给数组<strong>默认赋上「零值」</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var a [9]int
    fmt.Println(a)
}

------------
[0 0 0 0 0 0 0 0 0]
</code></pre>
<p>另外三种变量定义形式如下，效果都是一样的的：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var a = [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    var b [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    c := [8]int{1, 2, 3, 4, 5, 6, 7, 8}
    fmt.Println(a)
    fmt.Println(b)
    fmt.Println(c)
}

---------------------
[1 2 3 4 5 6 7 8 9]
[1 2 3 4 5 6 7 8 9 10]
[1 2 3 4 5 6 7 8]
</code></pre>
<h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><p>使用下标访问数组中的元素：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var squares [9]int
    for i := 0; i &lt; len(squares); i++ {
        squares[i] = (i + 1) * (i + 1)
    }
    fmt.Println(squares)
}

--------------------
[1 4 9 16 25 36 49 64 81]
</code></pre>
<h3 id="数组的下标越界检查"><a href="#数组的下标越界检查" class="headerlink" title="数组的下标越界检查"></a>数组的下标越界检查</h3><p>Go 语言会对<strong>数组访问下标越界</strong>进行<strong>编译器检查</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var a = [5]int{1,2,3,4,5}
    a[101] = 255
    fmt.Println(a)
}

-----
./main.go:7:3: invalid array index 101 (out of bounds for 5-element array)
</code></pre>
<p>而当数组下标是变量时，Go 会<strong>在编译后的代码中插入下标越界检查的逻辑</strong>，在运行时也会提示数组下标越界。所以数组的下标访问效率是要打折扣的，比不上 C 语言的数组访问性能。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var a = [5]int{1,2,3,4,5}
    var b = 101
    a[b] = 255
    fmt.Println(a)
}

------------
panic: runtime error: index out of range

goroutine 1 [running]:
main.main()
    /Users/qianwp/go/src/github.com/pyloque/practice/main.go:8 +0x3d
exit status 2
</code></pre>
<h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><p><strong>同样的子元素类型</strong>并且是<strong>同样长度</strong>的数组才可以<strong>相互赋值</strong>，否则就是不同的数组类型，不能赋值。数组的赋值本质上是一种<strong>浅拷贝操作</strong>，赋值的两个数组变量的值<strong>不会共享</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var a = [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    var b [9]int
    b = a
    a[0] = 12345
    fmt.Println(a)
    fmt.Println(b)
}

--------------------------
[12345 2 3 4 5 6 7 8 9]
[1 2 3 4 5 6 7 8 9]
</code></pre>
<p>从上面代码的运行结果中可以看出<strong>赋值后的两个数组并没有共享内部元素</strong>。如果数组的长度很大，那么拷贝操作是有一定的开销的，使用的时候要多加注意。</p>
<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>数组除了可以使用下标进行遍历之外，还可以使用<code>range</code>关键字来进行遍历。<code>range</code>遍历提供了下面两种形式：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var a = [5]int{1,2,3,4,5}
    for index := range a {
  fmt.Println(index, a[index])
 }
 for index, value := range a {
        fmt.Println(index, value)
    }
}

------------
0 1
1 2
2 3
3 4
4 5
0 1
1 2
2 3
3 4
4 5
</code></pre>
<h2 id="5-切片"><a href="#5-切片" class="headerlink" title="5. 切片"></a>5. 切片</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/XfyBIZ2TaFULAEmucCihzw" target="_blank" rel="noopener">《快学 Go 语言》第 5 课 —— 神奇的切片</a></p>
</blockquote>
<p>学过 Java 语言的人会比较容易理解切片，因为它的内部结构非常类似于 ArrayList，<strong>ArrayList 的内部实现也是一个数组</strong>。当数组容量不够需要扩容时，就会换新的数组，还需要将老数组的内容拷贝到新数组。ArrayList 内部有两个非常重要的属性<code>capacity</code>和<code>length</code>。<code>capacity</code>表示<strong>内部数组的总长度</strong>，<code>length</code>表示<strong>当前已经使用的数组的长度</strong>。<code>length</code>永远不能超过<code>capacity</code>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/slice.jpg" alt="Go 语言中的切片" title>
                </div>
                <div class="image-caption">Go 语言中的切片</div>
            </figure>
<p>上图中的一个切片变量包含三个域，分别是<strong>底层数组的指针</strong>、<strong>切片的长度</strong><code>length</code>和<strong>切片的容量</strong><code>capacity</code>。切片支持 <strong>append</strong> 操作可以将新内容追加到底层数组，也就是填充上图中的灰色格子。如果格子满了，<strong>切片就需要扩容，底层的数组就会更换</strong>。</p>
<h3 id="切片的创建"><a href="#切片的创建" class="headerlink" title="切片的创建"></a>切片的创建</h3><p>切片的创建有多种方式，先来看最通用的创建方法，那就是内置的 <strong>make</strong> 函数：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 []int = make([]int, 5, 8)
    var s2 []int = make([]int, 8) // 满容切片
    fmt.Println(s1)
    fmt.Println(s2)
}

-------------
[0 0 0 0 0]
[0 0 0 0 0 0 0 0]
</code></pre>
<p>使用 <strong>make</strong> 函数创建切片，需要提供三个参数：<strong>切片的类型</strong>、<strong>切片的长度</strong>和<strong>容量</strong>。其中第三个参数是可选的，如果不声明切片的容量，那么长度和容量相等，也就是说切片是满容的。</p>
<p>切片和普通变量一样，也可以使用类型自动推导，省区类型定义以及<code>var</code>关键字：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = make([]int, 5, 8)
    s2 := make([]int, 8)
    fmt.Println(s1)
    fmt.Println(s2)
}

-------------
[0 0 0 0 0]
[0 0 0 0 0 0 0 0]
</code></pre>
<h3 id="切片的初始化"><a href="#切片的初始化" class="headerlink" title="切片的初始化"></a>切片的初始化</h3><p>使用 <strong>make</strong> 函数创建的切片内容是<strong>「零值切片」</strong>，也就是内部数组的元素都是零值。Go 语言还提供了另一种创建切片的语法，允许我们给它赋初值，<strong>使用这种方式创建的切片是满容的</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s []int = []int{1,2,3,4,5}  // 满容的
    fmt.Println(s, len(s), cap(s))
}

---------
[1 2 3 4 5] 5 5
</code></pre>
<p>Go 语言提供了内置函数<code>len()</code>和<code>cap()</code>可以直接获得切片的<strong>长度</strong>和<strong>容量</strong>属性。</p>
<h3 id="空切片"><a href="#空切片" class="headerlink" title="空切片"></a>空切片</h3><p>在创建切片时，还有两个非常特殊的情况需要考虑，那就是<strong>容量和长度都是零</strong>的切片，叫做<strong>「空切片」</strong>。这个不同与之前提到的「零值切片」。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 []int
    var s2 []int = []int{}
    var s3 []int = make([]int, 0)
    fmt.Println(s1, s2, s3)
    fmt.Println(len(s1), len(s2), len(s3))
    fmt.Println(cap(s1), cap(s2), cap(s3))
}

-----------
[] [] []
0 0 0
0 0 0
</code></pre>
<p>上面三种形式创建的切片都是<strong>「空切片」</strong>，不过在内部结构上这三种形式还是有所差异的，准确来说第一种应该称为<strong>「nil 切片」</strong>，但是二者形式上几乎一模一样，用起来差不多没有区别，所以初级用户暂时可以不必区分。</p>
<h3 id="切片的赋值"><a href="#切片的赋值" class="headerlink" title="切片的赋值"></a>切片的赋值</h3><p><strong>切片的赋值</strong>是一次<strong>浅拷贝操作</strong>，拷贝的是<strong>切片变量的三个域</strong>。拷贝前后两个变量<strong>共享底层数组</strong>，对一个切片的修改会影响另一个切片的内容。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = make([]int, 5, 8)
    // 切片的访问和数组差不多
    for i := 0; i &lt; len(s1); i++ {
        s1[i] = i + 1
    }
    var s2 = s1
    fmt.Println(s1, len(s1), cap(s1))
    fmt.Println(s2, len(s2), cap(s2))

    // 尝试修改切片内容
    s2[0] = 255
    fmt.Println(s1)
    fmt.Println(s2)
}

--------
[1 2 3 4 5] 5 8
[1 2 3 4 5] 5 8
[255 2 3 4 5]
[255 2 3 4 5]
</code></pre>
<p>从上面的输出可以看到<strong>赋值的两切片共享了底层数组</strong>。</p>
<h3 id="切片的遍历"><a href="#切片的遍历" class="headerlink" title="切片的遍历"></a>切片的遍历</h3><p>切片在遍历的语法上和数组是一样的，除了支持<strong>下标遍历</strong>外，那就是使用 <strong>range</strong> 关键字。</p>
<pre><code class="lang-go">package main


import &quot;fmt&quot;


func main() {
    var s = []int{1,2,3,4,5}
    for index := range s {
        fmt.Println(index, s[index])
    }
    for index, value := range s {
        fmt.Println(index, value)
    }
}

--------
0 1
1 2
2 3
3 4
4 5
0 1
1 2
2 3
3 4
4 5
</code></pre>
<h3 id="切片的追加"><a href="#切片的追加" class="headerlink" title="切片的追加"></a>切片的追加</h3><p>之前有提到切片是<strong>动态的数组</strong>，其长度是可以变化的，可以通过<strong>追加操作</strong>来<strong>改变切片的长度</strong>。</p>
<p>切片<strong>每一次追加</strong>后都会形成<strong>新的切片变量</strong>，如果<strong>底层数组没有扩容</strong>，那么追加前后的两个切片变量就<strong>共享底层数组</strong>；如果<strong>底层数组扩容了</strong>，那么追加前后的<strong>底层数组是分离的不共享的</strong>。</p>
<blockquote>
<p>如果底层数组是共享的，那么<strong>一个切片的内容变化就会影响到另一个切片</strong>，这点需要特别注意。</p>
</blockquote>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = []int{1,2,3,4,5}
    fmt.Println(s1, len(s1), cap(s1))

    // 对满容的切片进行追加会分离底层数组
    var s2 = append(s1, 6)
    fmt.Println(s1, len(s1), cap(s1))
    fmt.Println(s2, len(s2), cap(s2))

    // 对非满容的切片进行追加会共享底层数组
    var s3 = append(s2, 7)
    fmt.Println(s2, len(s2), cap(s2))
    fmt.Println(s3, len(s3), cap(s3))
}

--------------------------
[1 2 3 4 5] 5 5
[1 2 3 4 5] 5 5
[1 2 3 4 5 6] 6 10
[1 2 3 4 5 6] 6 10
[1 2 3 4 5 6 7] 7 10
</code></pre>
<p>正是因为切片追加后是新的切片变量，所以 <strong>Go 编译器禁止追加了切片后不使用这个新的切片变量</strong>，以避免用户以为追加操作的返回值和原切片变量是同一个变量。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = []int{1,2,3,4,5}
    append(s1, 6)
    fmt.Println(s1)
}

--------------
./main.go:7:8: append(s1, 6) evaluated but not used
</code></pre>
<p>如果真的不需要使用这个新的变量，可以将 <strong>append</strong> 的结果赋值给<strong>下划线变量<code>_</code></strong>。</p>
<blockquote>
<p><strong>下划线变量<code>_</code></strong>是 Go 语言特殊的<strong>内置变量</strong>，它就像一个黑洞，<strong>可以将任意变量赋值给它</strong>，但是却<strong>不能读取这个特殊变量</strong>。</p>
</blockquote>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = []int{1,2,3,4,5}
    _ = append(s1, 6)
    fmt.Println(s1)
}

----------
[1 2 3 4 5]
</code></pre>
<p>还需要注意的是追加虽然会导致底层数组发生扩容、更换的新的数组，但是<strong>旧数组并不会立即被销毁被回收</strong>，因为<strong>老切片还指向着旧数组</strong>。</p>
<h3 id="切片的域是只读的"><a href="#切片的域是只读的" class="headerlink" title="切片的域是只读的"></a>切片的域是只读的</h3><blockquote>
<p><img src="https://notes.abelsu7.top/_media/star.svg" alt data-no-zoom><strong>需要仔细思考</strong></p>
</blockquote>
<p>我们刚才说切片的长度是可以变化的，为什么又说切片是只读的呢？这不是矛盾么。这是为了提醒读者注意切片追加后形成了一个新的切片变量，而<strong>老的切片变量的三个域其实并不会改变，改变的只是底层的数组</strong>。这里说的是切片的「域」是只读的，而不是说切片是只读的。<strong>切片的「域」</strong>就是<strong>组成切片变量的三个部分</strong>，分别是<strong>底层数组的指针</strong>、<strong>切片的长度</strong>和<strong>切片的容量</strong>。</p>
<h3 id="切片的切割"><a href="#切片的切割" class="headerlink" title="切片的切割"></a>切片的切割</h3><p>切片的切割可以类比字符串的子串，它并不是要把切片割断，而是<strong>从母切片中拷贝一个子切片出来，子切片和母切片共享底层数组</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = []int{1,2,3,4,5,6,7}
    // start_index 和 end_index，不包含 end_index
    // [start_index, end_index)
    var s2 = s1[2:5] 
    fmt.Println(s1, len(s1), cap(s1))
    fmt.Println(s2, len(s2), cap(s2))
}

------------
[1 2 3 4 5 6 7] 7 7
[3 4 5] 3 5
</code></pre>
<p>上面的输出需要特别注意的是：<strong>既然切割前后共享底层数据，那为什么容量不一样呢</strong>？下图可以解释这个问题。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/slice-cut.jpg" alt="切片的切割" title>
                </div>
                <div class="image-caption">切片的切割</div>
            </figure>
<p>可以注意到<strong>子切片的内部数据指针</strong>指向了<strong>数组的中间位置</strong>，而不再是数组的开头了。<strong>子切片容量的大小</strong>是<strong>从中间的位置开始直到切片末尾的长度</strong>，母子切片依旧<strong>共享底层数组</strong>。</p>
<p><strong>子切片语法</strong>上要提供<strong>起始</strong>和<strong>结束位置</strong>，这两个位置都是<strong>可选的</strong>。不提供起始位置，默认就是从母切片的初始位置开始（不是底层数组的初始位置）。不提供结束位置，默认就结束到母切片尾部（是长度线，不是容量线）。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = []int{1, 2, 3, 4, 5, 6, 7}
    var s2 = s1[:5]
    var s3 = s1[3:]
    var s4 = s1[:]
    fmt.Println(s1, len(s1), cap(s1))
    fmt.Println(s2, len(s2), cap(s2))
    fmt.Println(s3, len(s3), cap(s3))
    fmt.Println(s4, len(s4), cap(s4))
}

-----------
[1 2 3 4 5 6 7] 7 7
[1 2 3 4 5] 5 7
[4 5 6 7] 4 4
[1 2 3 4 5 6 7] 7 7
</code></pre>
<p>上面的<code>s1[:]</code>与<strong>普通的切片赋值</strong>没有区别，同样是共享底层数组，同样是浅拷贝。另外，Go 语言中<strong>切片的下标不支持负数</strong>。</p>
<h3 id="数组变切片"><a href="#数组变切片" class="headerlink" title="数组变切片"></a>数组变切片</h3><p><strong>对数组进行切割可以转换成切片</strong>。切片将原数组作为内部底层数组，也就是说<strong>修改了原数组会影响到新切片，对切片的修改也会影响到原数组</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var a = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    var b = a[2:6]
    fmt.Println(b)
    a[4] = 100
    fmt.Println(b)
}

-------
[3 4 5 6]
[3 4 100 6]
</code></pre>
<h3 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy 函数"></a>copy 函数</h3><p>Go 语言还内置了一个 <strong>copy</strong> 函数，用来进行<strong>切片的深拷贝</strong>。不过其实也没那么深，只是深到底层的数组而已。如果数组里面装的是指针，比如<code>[]*int</code>类型，那么指针指向的内容还是共享的。</p>
<pre><code class="lang-go">func copy(dst, src []T) int
</code></pre>
<p><strong>copy</strong> 函数不会因为原切片和目标切片的长度问题而额外分配底层数组的内存，它<strong>只负责拷贝数组的内容，从原切片拷贝到目标切片</strong>，拷贝的量是<strong>原切片和目标切片长度的较小值</strong><code>min(len(src), len(dst))</code>，函数返回的是<strong>拷贝的实际长度</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s = make([]int, 5, 8)
    for i:=0;i&lt;len(s);i++ {
        s[i] = i+1
    }
    fmt.Println(s)
    var d = make([]int, 2, 6)
    var n = copy(d, s)
    fmt.Println(n, d)
}

-----------
[1 2 3 4 5]
2 [1 2]
</code></pre>
<h3 id="切片的扩容点"><a href="#切片的扩容点" class="headerlink" title="切片的扩容点"></a>切片的扩容点</h3><p>当<strong>比较短的切片</strong>扩容时，系统会多分配 <strong>100%</strong> 的空间，也就是说<strong>分配的数组容量是切片长度的 2 倍</strong>。但当<strong>切片长度超过 1024 时</strong>，扩容策略调整为多分配 <strong>25%</strong> 的空间，这是为了<strong>避免空间的过多浪费</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    s1 := make([]int, 6)
    s2 := make([]int, 1024)
    s1 = append(s1, 1)
    s2 = append(s2, 2)
    fmt.Println(len(s1), cap(s1))
    fmt.Println(len(s2), cap(s2))
}

-------------------------------------------
7 12
1025 1344
</code></pre>
<h2 id="6-字典"><a href="#6-字典" class="headerlink" title="6. 字典"></a>6. 字典</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/mOE7wJuJ22JzM7jlI1tsJg" target="_blank" rel="noopener">《快学 Go 语言》第 6 课 —— 字典</a></p>
</blockquote>
<p>数组<strong>切片</strong>让我们具备了可以<strong>操作一块连续内存</strong>的能力，它是<strong>对同质元素的统一管理</strong>。而<strong>字典</strong>则赋予了<strong>不连续不同类的内存变量的关联性</strong>，它表达的是一种<strong>因果关系</strong>，字典的 <strong>key</strong> 是因，字典的 <strong>value</strong> 是果。</p>
<blockquote>
<p><strong>指针、数组切片和字典都是容器型变量</strong>。字典比数组切片在使用上要简单很多，但是内部结构却非常复杂。</p>
</blockquote>
<h3 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h3><p>在创建字典时，<strong>必须要给 key 和 value 指定类型</strong>。创建字典也可以使用 <strong>make</strong> 函数：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var m map[int]string = make(map[int]string)
    fmt.Println(m, len(m))
}

----------
map[] 0
</code></pre>
<p>使用 <strong>make</strong> 函数创建的字典是空的，长度为零，内部没有任何元素。如果需要给字典提供初始化的元素，就需要使用另一种创建字典的方式：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var m map[int]string = map[int]string{
        90: &quot;优秀&quot;,
        80: &quot;良好&quot;,
        60: &quot;及格&quot;,  // 注意这里逗号不可缺少，否则会报语法错误
    }
    fmt.Println(m, len(m))
}

---------------
map[90:优秀 80:良好 60:及格] 3
</code></pre>
<p>字典变量同样支持<strong>类型推导</strong>，上面的变量定义可以简写成：</p>
<pre><code class="lang-go">var m = map[int]string {
    90: &quot;优秀&quot;,
    80: &quot;良好&quot;,
    60: &quot;及格&quot;,
}
</code></pre>
<p>如果提前知道字典内部键值对的数量，那么还可以给 <strong>make</strong> 函数传递一个整数值，<strong>通知运行时提前分配好相应的内存</strong>，这样可以<strong>避免字典</strong>在长大的过程中要经历的<strong>多次扩容操作</strong>：</p>
<pre><code class="lang-go">var m = make(map[int]string, 16)
</code></pre>
<h3 id="字典的读写"><a href="#字典的读写" class="headerlink" title="字典的读写"></a>字典的读写</h3><p>字典可以使用<strong>中括号</strong><code>[]</code>来<strong>读写内部元素</strong>，使用 <strong>delete</strong> 函数来<strong>删除元素</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
      var fruits = map[string]int {
          &quot;apple&quot;: 2,
          &quot;banana&quot;: 5,
          &quot;orange&quot;: 8,
      }
      // 读取元素
      var score = fruits[&quot;banana&quot;]
      fmt.Println(score)

      // 增加或修改元素
      fruits[&quot;pear&quot;] = 3
      fmt.Println(fruits)

      // 删除元素
      delete(fruits, &quot;pear&quot;)
      fmt.Println(fruits)
}

-----------------------
5
map[apple:2 banana:5 orange:8 pear:3]
map[orange:8 apple:2 banana:5]
</code></pre>
<h3 id="字典-key-不存在会怎么样？"><a href="#字典-key-不存在会怎么样？" class="headerlink" title="字典 key 不存在会怎么样？"></a>字典 key 不存在会怎么样？</h3><p><strong>删除操作</strong>时，如果对应的 <strong>key</strong> 不存在，<strong>delete</strong> 函数会<strong>静默处理</strong>。<strong>读操作</strong>时，如果 <strong>key</strong> 不存在，也<strong>不会抛出异常</strong>，它会返回 <strong>value</strong> 类型对应的零值。</p>
<p>可以通过<strong>字典的特殊语法</strong>来判断<strong>对应的 key 是否存在</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var fruits = map[string]int {
        &quot;apple&quot;: 2,
        &quot;banana&quot;: 5,
        &quot;orange&quot;: 8,
    }

    var score, ok = fruits[&quot;durin&quot;]
    if ok {
        fmt.Println(score)
    } else {
        fmt.Println(&quot;durin not exists&quot;)
    }

    fruits[&quot;durin&quot;] = 0
    score, ok = fruits[&quot;durin&quot;]
    if ok {
        fmt.Println(score)
    } else {
        fmt.Println(&quot;durin still not exists&quot;)
    }
}

-------------
durin not exists
0
</code></pre>
<p><strong>字典的下标读取</strong>可以返回两个值，使用<strong>第二个返回值</strong>都表示<strong>对应的 key 是否存在</strong>。它只是 Go 语言提供的<strong>语法糖</strong>，内部并没有太多的玄妙。</p>
<blockquote>
<p>正常的函数调用可以返回多个值，但是并不具备这种“随机应变”的特殊能力 —— 「多态返回值」。</p>
</blockquote>
<h3 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h3><p>字典的遍历提供了以下两种方式：一种是需要携带 <strong>value</strong>，另一种是只需要 <strong>key</strong>，需要使用到 Go 语言的 <strong>range</strong> 关键字：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var fruits = map[string]int {
        &quot;apple&quot;: 2,
        &quot;banana&quot;: 5,
        &quot;orange&quot;: 8,
    }

    for name, score := range fruits {
        fmt.Println(name, score)
    }

    for name := range fruits {
        fmt.Println(name)
    }
}

------------
orange 8
apple 2
banana 5
apple
banana
orange
</code></pre>
<p>然而，Go 语言的字典并没有提供例如<code>keys()</code>或<code>values()</code>这样的方法，意味着如果要获取 <strong>key</strong> 列表，就得自己循环一下：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var fruits = map[string]int {
        &quot;apple&quot;: 2,
        &quot;banana&quot;: 5,
        &quot;orange&quot;: 8,
    }

    var names = make([]string, 0, len(fruits))
    var scores = make([]int, 0, len(fruits))

    for name, score := range fruits {
        names = append(names, name)
        scores = append(scores, score)
    }

    fmt.Println(names, scores)
}

----------
[apple banana orange] [2 5 8]
</code></pre>
<blockquote>
<p><strong>注意</strong>：遍历的时候，直接得到的 <strong>value</strong> 是<strong>拷贝过后的</strong>，会影响性能。在遍历中，使用<code>map[key]</code>的方式可以<strong>直接用索引获取数据</strong>，速度要比使用 <strong>value</strong> 快将近一倍，但要注意<strong>指针安全</strong>的问题。</p>
</blockquote>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>Go 语言的内置字典不是线程安全的</strong>，如果需要线程安全，<strong>必须使用锁来控制</strong>。</p>
<h3 id="字典变量里存的是什么？"><a href="#字典变量里存的是什么？" class="headerlink" title="字典变量里存的是什么？"></a>字典变量里存的是什么？</h3><p><strong>字典变量</strong>里存的只是一个<strong>地址指针</strong>，这个指针指向<strong>字典的头部对象</strong>。所以字典变量占用的空间是<strong>一个字</strong>，也就是<strong>一个指针的大小</strong>，64 位机器是 8 字节，32 位机器是 4 字节。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/map-ptr.png" alt="字典变量中的地址指针" title>
                </div>
                <div class="image-caption">字典变量中的地址指针</div>
            </figure>
<p>可以使用 <strong>unsafe</strong> 包提供的<code>Sizeof</code>函数来计算一个变量的大小：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    var m = map[string]int{
        &quot;apple&quot;:  2,
        &quot;pear&quot;:   3,
        &quot;banana&quot;: 5,
    }
    fmt.Println(unsafe.Sizeof(m))
}

------
8
</code></pre>
<h2 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7. 字符串"></a>7. 字符串</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/XYDrS383ZrKfW4ySb89IOQ" target="_blank" rel="noopener">《快学 Go 语言》第 7 课 —— 字符串</a></p>
</blockquote>
<p>字符串通常有两种设计，一种是「字符」串，一种是「字节」串。「字符」串中的每个字都是定长的，而「字节」串中每个字是不定长的。<strong>Go 语言里的字符串是「字节」串，英文字符占用 1 个字节，非英文字符占多个字节</strong>。这意味着<strong>无法通过位置来快速定位出一个完整的字符来</strong>，而必须通过<strong>遍历</strong>的方式来<strong>逐个获取单个字符</strong>。</p>
<p>我们所说的字符通常是指 <strong>unicode</strong> 字符，一个 <strong>unicode</strong> 字符通常用 4 个字节来表示，对应的 Go 语言中的字符 <strong>rune</strong> 占 4 个字节。</p>
<blockquote>
<p>在 Go 语言的源码中可以看到，<strong>rune</strong> 类型是一个衍生类型，它在内存里面使用<code>int32</code>类型的 <strong>4 个字节</strong>存储。</p>
</blockquote>
<pre><code class="lang-go">type rune int32
</code></pre>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/byte-and-rune.jpg" alt="字节 byte 和字符 rune 的关系" title>
                </div>
                <div class="image-caption">字节 byte 和字符 rune 的关系</div>
            </figure>
<p>其中 <strong>codepoint</strong> 是每个「字」的<strong>实际偏移量</strong>。Go 语言的字符串采用 <strong>utf-8</strong> 编码，<strong>中文汉字</strong>通常需要占用 <strong>3 个字节</strong>，<strong>英文</strong>只需要 <strong>1 个字节</strong>。<code>len()</code>函数得到的是<strong>字节的数量</strong>，通过下标来访问字符串得到的是「字节」。</p>
<h3 id="按字节遍历"><a href="#按字节遍历" class="headerlink" title="按字节遍历"></a>按字节遍历</h3><p>字符串可以<strong>通过下标来访问内部字节数组具体位置上的字节</strong>，字节是 <strong>byte</strong> 类型：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s = &quot;嘻哈china&quot;
    for i:=0;i&lt;len(s);i++ {
        fmt.Printf(&quot;%x &quot;, s[i])
    }

}

-----------
e5 98 bb e5 93 88 63 68 69 6e 61
</code></pre>
<h3 id="按字符-rune-遍历"><a href="#按字符-rune-遍历" class="headerlink" title="按字符 rune 遍历"></a>按字符 rune 遍历</h3><pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s = &quot;嘻哈china&quot;
    for codepoint, runeValue := range s {
        fmt.Printf(&quot;%d %d &quot;, codepoint, int32(runeValue))
    }
}

-----------
0 22075 3 21704 6 99 7 104 8 105 9 110 10 97
</code></pre>
<p>对字符串进行 <strong>range</strong> 遍历，每次迭代出两个变量<code>codepoint</code>和<code>runeValue</code>，<strong>codepoint</strong> 表示<strong>字符起始位置</strong>，<strong>runeValue</strong>表示对应的 <strong>unicode 编码</strong>（类型是 <strong>rune</strong>）。</p>
<h3 id="字符串的内存表示"><a href="#字符串的内存表示" class="headerlink" title="字符串的内存表示"></a>字符串的内存表示</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/str-structure.jpg" alt="字符串的内存结构" title>
                </div>
                <div class="image-caption">字符串的内存结构</div>
            </figure>
<p><strong>字符串的内存结构</strong>不仅包含前面提到的<strong>字节数组</strong>，编译器还为它分配了<strong>头部字段</strong>来存储 <strong><em>长度信息</em></strong> 和 <strong><em>指向底层字节数组的指针</em></strong>，如上图所示，结构非常类似于切片，区别是头部少了一个容量字段。</p>
<h3 id="字符串是只读的"><a href="#字符串是只读的" class="headerlink" title="字符串是只读的"></a>字符串是只读的</h3><p>可以使用下标来读取字符串指定位置的字节，但是<strong>无法修改这个位置上的字节内容</strong>。如果尝试使用下标赋值，编译器在语法上直接拒绝：</p>
<pre><code class="lang-go">package main

func main() {
    var s = &quot;hello&quot;
    s[0] = &#39;H&#39;
}
--------
./main.go:5:7: cannot assign to s[0]
</code></pre>
<h3 id="字符串的切割"><a href="#字符串的切割" class="headerlink" title="字符串的切割"></a>字符串的切割</h3><p>字符串在内存形式上比较接近于切片，它也可以像切片一样进行切割来获取子串。<strong>子串和母串共享底层字节数组</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = &quot;hello world&quot;
    var s2 = s1[3:8]
    fmt.Println(s2)
}

-------
lo wo
</code></pre>
<h3 id="字节切片和字符串的相互转换"><a href="#字节切片和字符串的相互转换" class="headerlink" title="字节切片和字符串的相互转换"></a>字节切片和字符串的相互转换</h3><p>在使用 Go 语言进行网络编程时，经常需要将来自网络的字节流转换成内存字符串，同时也需要将内存字符串转换成网络字节流。Go 语言直接<strong>内置了字节切片和字符串的相互转换语法</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var s1 = &quot;hello world&quot;
    var b = []byte(s1)  // 字符串转字节切片
    var s2 = string(b)  // 字节切片转字符串
    fmt.Println(b)
    fmt.Println(s2)
}

--------
[104 101 108 108 111 32 119 111 114 108 100]
hello world
</code></pre>
<blockquote>
<p><strong>注意</strong>：字节切片和字符串的<strong>底层字节数组不是共享的</strong>，底层字节数组会被<strong>拷贝</strong>。这是因为字节切片的底层数组内容是可以修改的，而字符串的底层字节数组是只读的，<strong>如果共享了，就会导致字符串的只读属性不再成立</strong>。</p>
</blockquote>
<h2 id="8-结构体"><a href="#8-结构体" class="headerlink" title="8. 结构体"></a>8. 结构体</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/VdNvbGj0TfIdmdDVpYxO2w" target="_blank" rel="noopener">《快学 Go 语言》第 8 课 —— 结构体</a></p>
</blockquote>
<p><strong>Go 语言结构体</strong>里面装的是<strong>基础类型、数组、切片、字典</strong>以及<strong>其他类型结构体</strong>等。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-struct.jpg" alt="Go 语言中的结构体" title>
                </div>
                <div class="image-caption">Go 语言中的结构体</div>
            </figure>
<h3 id="结构体类型的定义"><a href="#结构体类型的定义" class="headerlink" title="结构体类型的定义"></a>结构体类型的定义</h3><p>结构体和其它高级语言里的「类」比较相似：</p>
<pre><code class="lang-go">type Circle struct {
    x int
    y int
    Radius int
}
</code></pre>
<p>需要特别注意的是<strong>结构体内部变量的大小写</strong>，<strong>首字母大写</strong>是<strong>公开变量</strong>，<strong>首字母小写</strong>是<strong>内部变量</strong>，分别相当于类成员变量的 <strong>public</strong> 和 <strong>private</strong> 类别。内部变量只有<strong>属于同一个 package 的代码</strong>才能直接访问。</p>
<h3 id="结构体变量的创建"><a href="#结构体变量的创建" class="headerlink" title="结构体变量的创建"></a>结构体变量的创建</h3><p>最常见的创建形式是<strong>「KV 形式」</strong>，通过<strong>显式指定结构体内部字段的名称和初始值</strong>来初始化结构体，没有指定初值的字段会自动初始化为相应类型的<strong>「零值」</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func main() {
    var c1 Circle = Circle{
        x:      100,
        y:      100,
        Radius: 50,
    }
    var c2 Circle = Circle{
        Radius: 50,
    }
    var c3 Circle = Circle{}
    fmt.Printf(&quot;%+v\n&quot;, c1)
    fmt.Printf(&quot;%+v\n&quot;, c2)
    fmt.Printf(&quot;%+v\n&quot;, c3)
}

----------
{x:100 y:100 Radius:50}
{x:0 y:0 Radius:50}
{x:0 y:0 Radius:0}
</code></pre>
<p>结构体的第二种创建形式是<strong>不指定字段名称来顺序字段初始化</strong>，需要<strong>显式提供所有字段的初值</strong>，一个都不能少。这种形式称之为<strong>「顺序形式」</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func main() {
    var c Circle = Circle{100, 100, 50}
    fmt.Printf(&quot;%+v\n&quot;, c)
}

-------
{x:100 y:100 Radius:50}
</code></pre>
<p>结构体变量和普通变量都有<strong>指针形式</strong>，使用取地址符<code>&amp;</code>就可以得到<strong>结构体的指针类型</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func main() {
    var c *Circle = &amp;Circle{100, 100, 50}
    fmt.Printf(&quot;%+v\n&quot;, c)
}

-----------
&amp;{x:100 y:100 Radius:50}
</code></pre>
<p>结构体变量创建的第三种形式是<strong>使用全局的</strong><code>new()</code><strong>函数</strong>来创建一个<strong>「零值」结构体</strong>，所有字段都被初始化为相应类型的零值：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func main() {
    var c *Circle = new(Circle)
    fmt.Printf(&quot;%+v\n&quot;, c)
}

----------
&amp;{x:0 y:0 Radius:0}
</code></pre>
<p>第四种创建形式也是零值初始化：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func main() {
    var c Circle
    fmt.Printf(&quot;%+v\n&quot;, c)
}

----------
{x:0 y:0 Radius:0}
</code></pre>
<p>三种零值初始化形式对比：</p>
<pre><code class="lang-go">var c1 Circle = Circle{}
var c2 Circle
var c3 *Circle = new(Circle)
</code></pre>
<h3 id="零值结构体和-nil-结构体"><a href="#零值结构体和-nil-结构体" class="headerlink" title="零值结构体和 nil 结构体"></a>零值结构体和 nil 结构体</h3><p><strong>nil 结构体</strong>是指结构体指针变量<strong>没有指向一个实际存在的内存</strong>。这样的指针变量只会占用 <strong>1 个指针的存储空间</strong>，也就是一个机器字的内存大小。</p>
<pre><code class="lang-go">var c *Circle = nil
</code></pre>
<p>而<strong>零值结构体</strong>则会实际<strong>占用内存空间</strong>，只不过<strong>每个字段都是零值</strong>。</p>
<h3 id="结构体的内存大小"><a href="#结构体的内存大小" class="headerlink" title="结构体的内存大小"></a>结构体的内存大小</h3><p>Go 语言的 <strong>unsafe</strong> 包提供了获取结构体<strong>内存占用</strong>的函数<code>Sizeof()</code>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;unsafe&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func main() {
    var c Circle = Circle{Radius: 50}
    fmt.Println(unsafe.Sizeof(c))
}

-------
24
</code></pre>
<p><strong>64 位</strong>机器上每个 <strong>int</strong> 类型都是 <strong>8 字节</strong>。而 <strong>32 位</strong>机器上，<strong>Circle</strong> 结构体就只会占用 <strong>12 字节</strong>。</p>
<h3 id="结构体的拷贝"><a href="#结构体的拷贝" class="headerlink" title="结构体的拷贝"></a>结构体的拷贝</h3><p><strong>结构体</strong>之间可以相互赋值，本质上是一次<strong>浅拷贝操作</strong>，拷贝了<strong>结构体内部的所有字段</strong>。</p>
<p><strong>结构体指针</strong>之间也可以相互赋值，本质上也是一次浅拷贝操作，不过它拷贝的仅仅是<strong>指针地址值</strong>，<strong>结构体的内容是共享的</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func main() {
    var c1 Circle = Circle{Radius: 50}
    var c2 Circle = c1
    fmt.Printf(&quot;%+v\n&quot;, c1)
    fmt.Printf(&quot;%+v\n&quot;, c2)
    c1.Radius = 100
    fmt.Printf(&quot;%+v\n&quot;, c1)
    fmt.Printf(&quot;%+v\n&quot;, c2)

    var c3 *Circle = &amp;Circle{Radius: 50}
    var c4 *Circle = c3
    fmt.Printf(&quot;%+v\n&quot;, c3)
    fmt.Printf(&quot;%+v\n&quot;, c4)
    c3.Radius = 100
    fmt.Printf(&quot;%+v\n&quot;, c3)
    fmt.Printf(&quot;%+v\n&quot;, c4)
}

----------------------
{x:0 y:0 Radius:50}
{x:0 y:0 Radius:50}
{x:0 y:0 Radius:100}
{x:0 y:0 Radius:50}
&amp;{x:0 y:0 Radius:50}
&amp;{x:0 y:0 Radius:50}
&amp;{x:0 y:0 Radius:100}
&amp;{x:0 y:0 Radius:100}
</code></pre>
<blockquote>
<p>通过观察 Go 语言的<strong>底层源码</strong>，可以发现<strong>所有的 Go 语言内置的高级数据结构都是由结构体来完成的</strong>。</p>
</blockquote>
<h3 id="结构体中的数组和切片"><a href="#结构体中的数组和切片" class="headerlink" title="结构体中的数组和切片"></a>结构体中的数组和切片</h3><p>之前分析了数组与切片在<strong>内存形式</strong>上的区别：<strong>数组只有「体」</strong>，<strong>切片</strong>除了「体」之外，<strong>还有「头」部</strong>。切片的<strong>头部和内容体是分离的</strong>，使用<strong>指针</strong>关联起来。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;unsafe&quot;

type ArrayStruct struct {
    value [10]int
}

type SliceStruct struct {
    value []int
}

func main() {
    var as = ArrayStruct{[...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}}
    var ss = SliceStruct{[]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}}
    fmt.Println(unsafe.Sizeof(as), unsafe.Sizeof(ss))
}

-------------
80 24
</code></pre>
<p>注意代码中的<strong>数组初始化</strong>使用了<code>[...]</code><strong>语法糖</strong>，表示让编译器<strong>自动推导数组的长度</strong>。</p>
<h3 id="结构体的参数传递"><a href="#结构体的参数传递" class="headerlink" title="结构体的参数传递"></a>结构体的参数传递</h3><p>函数调用时参数传递结构体变量，<strong>值传递</strong>涉及到<strong>结构体字段的浅拷贝</strong>，<strong>指针传递</strong>则会<strong>共享结构体内容</strong>，只拷贝指针地址，规则上和赋值是等价的：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Circle struct {
    x      int
    y      int
    Radius int
}

func expandByValue(c Circle) {
    c.Radius *= 2
}

func expandByPointer(c *Circle) {
    c.Radius *= 2
}

func main() {
    var c = Circle{Radius: 50}
    expandByValue(c)
    fmt.Println(c)
    expandByPointer(&amp;c)
    fmt.Println(c)
}

---------
{0 0 50}
{0 0 100}
</code></pre>
<h3 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h3><pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;math&quot;
)

type Circle struct {
    x      int
    y      int
    Radius int
}

// 面积
func (c Circle) Area() float64 {
    return math.Pi * float64(c.Radius) * float64(c.Radius)
}

// 周长
func (c Circle) Circumference() float64 {
    return 2 * math.Pi * float64(c.Radius)
}

func main() {
    var c = Circle{Radius: 50}
    fmt.Println(c.Area(), c.Circumference())
    // 指针变量调用方法形式上是一样的
    var pc = &amp;c
    fmt.Println(pc.Area(), pc.Circumference())
}

-----------
7853.981633974483 314.1592653589793
7853.981633974483 314.1592653589793
</code></pre>
<ul>
<li>Go 语言不喜欢类型的隐式转换，所以<strong>需要将整型显式转换成浮点型</strong></li>
<li>Go 语言结构体方法里面也<strong>没有</strong><code>self</code>和<code>this</code><strong>这样的关键字来指代当前的对象</strong></li>
<li>Go 语言的方法名称也分<strong>首字母大小写</strong>，它的权限规则和字段一样，首字母大写就是公开方法，首字母小写就是内部方法，只有归属与同一个包的代码才可以访问</li>
<li>结构体的<strong>值类型和指针类型访问内部字段</strong>和方法在形式上是<strong>一样的</strong>，都是使用<strong>句点</strong><code>.</code><strong>操作符</strong></li>
</ul>
<h3 id="结构体的指针方法"><a href="#结构体的指针方法" class="headerlink" title="结构体的指针方法"></a>结构体的指针方法</h3><p><strong>结构体的值方法无法改变结构体内部状态</strong>。例如，使用下面的方法无法扩大 <strong>Circle</strong> 的半径：</p>
<pre><code class="lang-go">func (c Circle) expand() {
    c.Radius *= 2
}
</code></pre>
<p>这是因为<strong>参数传递是值传递</strong>，复制了一份结构体内容。要想修改结构体内部状态，就必须要使用<strong>结构体的指针方法</strong>：</p>
<pre><code class="lang-go">func (c *Circle) expand() {
    c.Radius *= 2
}
</code></pre>
<p>通过指针访问内部的字段需要 <strong>2 次内存读取操作</strong>，第一步是<strong>取得指针地址</strong>，第二步是<strong>读取地址的内容</strong>，<strong>它比值访问要慢</strong>。但是在方法调用时，<strong>指针传递</strong>可以<strong>避免结构体的拷贝操作</strong>，结构体比较大时，这种性能的差距就会比较明显。</p>
<blockquote>
<p>还有一些特殊的结构体不允许被复制，比如<strong>结构体内部包含有锁</strong>时，这时就<strong>必须使用它的指针形式来定义方法</strong>，否则会发生一些莫名其妙的问题。</p>
</blockquote>
<h3 id="内嵌结构体"><a href="#内嵌结构体" class="headerlink" title="内嵌结构体"></a>内嵌结构体</h3><p>结构体作为一种变量它可以放进另外一个结构体作为一个字段来使用，这种<strong>内嵌结构体</strong>的形式在 Go 语言里称之为<strong>「组合」</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Point struct {
    x int
    y int
}

func (p Point) show() {
    fmt.Println(p.x, p.y)
}

type Circle struct {
    loc    Point
    Radius int
}

func main() {
    var c = Circle{
        loc: Point{
            x: 100,
            y: 100,
        },
        Radius: 50,
    }
    fmt.Printf(&quot;%+v\n&quot;, c)
    fmt.Printf(&quot;%+v\n&quot;, c.loc)
    fmt.Printf(&quot;%d %d\n&quot;, c.loc.x, c.loc.y)
    c.loc.show()
}

----------------
{loc:{x:100 y:100} Radius:50}
{x:100 y:100}
100 100
100 100
</code></pre>
<h3 id="匿名内嵌结构体"><a href="#匿名内嵌结构体" class="headerlink" title="匿名内嵌结构体"></a>匿名内嵌结构体</h3><p>还有一种特殊的内嵌结构体形式，<strong>内嵌的结构体不提供名称</strong>。这时<strong>外面的结构体将直接继承内嵌结构体所有的内部字段和方法</strong>，匿名的结构体字段将会自动获得<strong>以结构体类型的名字命名的字段名称</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Point struct {
    x int
    y int
}

func (p Point) show() {
    fmt.Println(p.x, p.y)
}

type Circle struct {
    Point // 匿名内嵌结构体
    Radius int
}

func main() {
    var c = Circle{
        Point: Point{
            x: 100,
            y: 100,
        },
        Radius: 50,
    }
    fmt.Printf(&quot;%+v\n&quot;, c)
    fmt.Printf(&quot;%+v\n&quot;, c.Point)
    fmt.Printf(&quot;%d %d\n&quot;, c.x, c.y) // 继承了字段
    fmt.Printf(&quot;%d %d\n&quot;, c.Point.x, c.Point.y)
    c.show() // 继承了方法
    c.Point.show()
}

-------
{Point:{x:100 y:100} Radius:50}
{x:100 y:100}
100 100
100 100
100 100
100 100
</code></pre>
<p>这里的<strong>继承</strong>仅仅是<strong>形式上的语法糖</strong>，<code>c.show()</code>转换成<strong>二进制代码</strong>后和<code>c.Point.show()</code>是<strong>等价的</strong>，<code>c.x</code>和<code>c.Point.x</code>也是<strong>等价的</strong>。</p>
<h3 id="Go-语言的结构体没有多态性"><a href="#Go-语言的结构体没有多态性" class="headerlink" title="Go 语言的结构体没有多态性"></a>Go 语言的结构体没有多态性</h3><p>Go 语言不是面向对象语言在于它的<strong>结构体明确不支持多态</strong>，外结构体的方法<strong>不能覆盖内部结构体的方法</strong>。</p>
<blockquote>
<p><strong>多态</strong>是指<strong>父类定义的方法可以调用子类实现的方法</strong>，不同的子类有不同的实现，从而<strong>给父类的方法带来了多样的不同行为</strong>。</p>
</blockquote>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Fruit struct{}

func (f Fruit) eat() {
    fmt.Println(&quot;eat fruit&quot;)
}

func (f Fruit) enjoy() {
    fmt.Println(&quot;smell first&quot;)
    f.eat()
    fmt.Println(&quot;clean finally&quot;)
}

type Apple struct {
    Fruit
}

func (a Apple) eat() {
    fmt.Println(&quot;eat apple&quot;)
}

type Banana struct {
    Fruit
}

func (b Banana) eat() {
    fmt.Println(&quot;eat banana&quot;)
}

func main() {
    var apple = Apple{}
    var banana = Banana{}
    apple.enjoy()
    banana.enjoy()
}

----------
smell first
eat fruit
clean finally
smell first
eat fruit
clean finally
</code></pre>
<p>可以看到，<code>enjoy</code>方法调用的<code>eat</code>方法还是 <strong>Fruit</strong> 自己的<code>eat</code>方法，它没能被外面的结构体方法覆盖掉，这意味着<strong>面向对象的代码习惯不能直接用到 Go 语言中</strong>。</p>
<h2 id="9-接口"><a href="#9-接口" class="headerlink" title="9. 接口"></a>9. 接口</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/2naJiu3GeNeT8gVyhMo1fA" target="_blank" rel="noopener">《快学 Go 语言》第 9 课 —— 接口</a></p>
</blockquote>
<p><strong>接口</strong>是一个对象的<strong>对外能力</strong>的展现，我们使用一个对象时，<strong>往往不需要知道一个对象的内部复杂实现</strong>，通过它暴露出来的接口，就知道了这个对象具备哪些能力以及如何使用这个能力。</p>
<p>Go 语言的接口类型非常特别，它的作用和 Java 语言的接口一样，但是在形式上有很大的差别。Java 语言需要在类的定义上显式实现了某些接口，才可以说这个类具备了接口定义的能力。但是 <strong>Go 语言的接口是隐式的</strong>，只要<strong>结构体上定义的方法在形式上（名称、参数和返回值）和接口定义的一样，那么这个结构体就自动实现了这个接口</strong>，我们就可以使用这个接口变量来指向结构体对象。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// 可以闻
type Smellable interface {
    smell(s string)
}

// 可以吃
type Eatable interface {
    eat(s string)
}

// 苹果既可以闻又可以吃
type Apple struct {
    name string
}

func (a Apple) smell(s string) {
    fmt.Println(s + &quot; can smell&quot;)
}

func (a Apple) eat(s string) {
    fmt.Println(s + &quot; can eat&quot;)
}

// 花只可以闻
type Flower struct {
    name string
}

func (f Flower) smell(s string) {
    fmt.Println(s + &quot; can smell&quot;)
}

func main() {
    var s1 Smellable
    var s2 Eatable
    var apple = Apple{
        name: &quot;Apple&quot;,
    }
    var flower = Flower{
        name: &quot;Flower&quot;,
    }
    s1 = apple
    s1.smell(apple.name)
    s1 = flower
    s1.smell(flower.name)
    s2 = apple
    s2.eat(apple.name)
}

--------------------
apple can smell
flower can smell
apple can eat
</code></pre>
<p><strong>Apple</strong> 结构体同时实现了<code>Smellable</code>和<code>Eatable</code>这两个接口，而 <strong>Flower</strong> 结构体只实现了<code>Smellable</code>接口。可以看到在 Go 语言中，无需使用类似于 Java 语言的 <strong>implements</strong> 关键字，结构体和接口就自动产生了关联。</p>
<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>如果一个接口里面<strong>没有定义任何方法</strong>，那么它就是<strong>空接口</strong>，任意结构体都隐式的实现了空接口。</p>
<p>Go 语言为了避免用户重复定义，自己内置了一个名为<code>interface{}</code>的<strong>空接口</strong>。空接口里没有方法，所以它也不具备任何能力，其作用相当于 Java 的 <strong>Object</strong> 类型，<strong>可以容纳任意对象</strong>，是一个<strong>万能容器</strong>。比如一个字典的 <strong>key</strong> 是字符串，但是希望 <strong>value</strong> 可以容纳任意类型的对象，类似于 Java 语言的 <strong>Map</strong> 类型，这时候就可以使用空接口类型<code>interface{}</code>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var user = map[string]interface{}{
        &quot;age&quot;:     30,
        &quot;address&quot;: &quot;Guangdong Guangzhou&quot;,
        &quot;married&quot;: true,
    }
    fmt.Println(user)
    // 类型转换语法
    var age = user[&quot;age&quot;].(int)
    var address = user[&quot;address&quot;].(string)
    var married = user[&quot;married&quot;].(bool)
    fmt.Println(age, address, married)
}

-------------
map[age:30 address:Guangdong Guangzhou married:true]
30 Guangdong Guangzhou true
</code></pre>
<p>因为 <strong>user</strong> 字典变量的类型是<code>map[string]interface{}</code>，从这个字典中直接读取得到的 <strong>value</strong> 类型是<code>interface{}</code>，所以需要通过<strong>类型转换</strong>才能得到期望的变量。</p>
<h3 id="接口变量的本质"><a href="#接口变量的本质" class="headerlink" title="接口变量的本质"></a>接口变量的本质</h3><p>可以将 Go 语言中的接口看成一个<strong>特殊的容器</strong>：这个容器只能容纳一个对象，只有实现了这个接口类型的对象才可以放进去。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-interface.jpg" alt="Go 语言中的接口变量" title>
                </div>
                <div class="image-caption">Go 语言中的接口变量</div>
            </figure>
<p>查看 Go 语言的源码发现，<strong>接口变量</strong>也是由<strong>结构体</strong>来定义的。这个结构体包含<strong>两个指针字段</strong>，所以接口变量的内存占用是 <strong>2 个机器字</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;unsafe&quot;

func main() {
    var s interface{}
    fmt.Println(unsafe.Sizeof(s))
    var arr = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Println(unsafe.Sizeof(arr))
    s = arr
    fmt.Println(unsafe.Sizeof(s))
}

----------
16
80
16
</code></pre>
<h3 id="用接口来模拟多态"><a href="#用接口来模拟多态" class="headerlink" title="用接口来模拟多态"></a>用接口来模拟多态</h3><p><strong>接口</strong>是一种<strong>特殊的容器</strong>，可以容纳多种不同的对象。那么只要这些对象都同样<strong>实现了接口定义的方法</strong>，再<strong>将容纳的对象替换成另一个对象</strong>，就可以<strong>模拟实现多态</strong>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
)

type Fruitable interface {
    eat()
}

type Fruit struct {
    Name string // 属性变量
    Fruitable   // 匿名内嵌接口变量
}

func (f Fruit) want() {
    fmt.Printf(&quot;I like &quot;)
    f.eat() // 外结构体会自动继承匿名内嵌变量的方法
}

type Apple struct{}

func (a Apple) eat() {
    fmt.Println(&quot;eating apple&quot;)
}

type Banana struct{}

func (b Banana) eat() {
    fmt.Println(&quot;eating banana&quot;)
}

func main() {
    var f1 = Fruit{&quot;Apple&quot;, Apple{}}
    var f2 = Fruit{&quot;Banana&quot;, Banana{}}
    f1.want()
    f2.want()
}

---------
I like eating apple
I like eating banana
</code></pre>
<p>使用这种方式模拟多态本质上是通过组合<strong>属性变量 Name</strong> 和<strong>接口变量 Fruitable</strong> 来做到的。<strong>属性变量</strong>是<strong>对象的数据</strong>，而<strong>接口变量</strong>是<strong>对象的功能</strong>，将它们组合到一块就形成了一个完整的多态性结构体。</p>
<h3 id="接口的组合继承"><a href="#接口的组合继承" class="headerlink" title="接口的组合继承"></a>接口的组合继承</h3><p>接口的定义也支持组合继承：</p>
<pre><code class="lang-go">type Smellable interface {
    smell()
}

type Eatable interface {
    eat()
}

type Fruitable interface {
    Smellable
    Eatable
}
</code></pre>
<p>这时 <strong>Fruitable</strong> 接口就自动包含了<code>smell()</code>和<code>eat()</code>两个方法，和下面的定义是等价的：</p>
<pre><code class="lang-go">type Fruitable interface {
    smell()
    eat()
}
</code></pre>
<h3 id="接口变量的赋值"><a href="#接口变量的赋值" class="headerlink" title="接口变量的赋值"></a>接口变量的赋值</h3><p><strong>变量的赋值</strong>本质上是一次<strong>内存浅拷贝</strong>：<strong>切片</strong>的赋值是<strong>拷贝了切片头</strong>，<strong>字符串</strong>的赋值是拷贝了<strong>字符串的头部</strong>，而<strong>数组</strong>的赋值则是直接<strong>拷贝了整个数组</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Rect struct {
    Width  int
    Height int
}

func main() {
    var a interface{}
    var r = Rect{50, 50}
    a = r

    var rx = a.(Rect)
    r.Width = 100
    r.Height = 100
    fmt.Println(rx)
}

------
{50 50}
</code></pre>
<p>可以根据上面的输出结果推断出<strong>结构体的内存发生了复制</strong>，这是因为<strong>赋值</strong><code>a = r</code>和<strong>类型转换</strong><code>rx = a.(Rect)</code>两者都发生了数据内存的赋值——<strong>浅拷贝</strong>。</p>
<h3 id="指向指针的接口变量"><a href="#指向指针的接口变量" class="headerlink" title="指向指针的接口变量"></a>指向指针的接口变量</h3><p>将上面的例子改成指针，将<strong>接口变量</strong>指向<strong>结构体指针</strong>，就会得到不一样的结果：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type Rect struct {
    Width  int
    Height int
}

func main() {
    var a interface{}
    var r = Rect{50, 50}
    a = &amp;r // 指向了结构体指针

    var rx = a.(*Rect)
    r.Width = 100
    r.Height = 100
    fmt.Println(rx)
}

-------
&amp;{100 100}
</code></pre>
<p>可以看到指针变量 <strong>rx</strong> 指向的内存和变量 <strong>r</strong> 的内存是同一份，因为在类型转换的过程中只发生了<strong>指针变量的内存复制</strong>，而<strong>指针变量指向的内存是共享</strong>的。</p>
<h2 id="10-错误和异常"><a href="#10-错误和异常" class="headerlink" title="10. 错误和异常"></a>10. 错误和异常</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/2hFl-3HEpzMrqLuaxrAiwQ" target="_blank" rel="noopener">《快学 Go 语言》第 10 课 —— 错误和异常</a></p>
</blockquote>
<h3 id="错误接口"><a href="#错误接口" class="headerlink" title="错误接口"></a>错误接口</h3><p>Go 语言规定<strong>凡是实现了错误接口的对象</strong>都是<strong>错误对象</strong>，这个错误接口只定义了一个方法：</p>
<pre><code class="lang-go">type error interface {
    Error() string
}
</code></pre>
<p>编写一个错误对象很简单：<strong>写一个结构体，然后挂在</strong><code>Error</code><strong>方法里</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

type SomeError struct {
    Reason string
}

func (s SomeError) Error() string {
    return s.Reason
}

func main() {
    var err error = SomeError{&quot;something happened&quot;}
    fmt.Println(err)
}

---------------
something happened
</code></pre>
<p>Go 语言内置了一个<strong>通用错误类型</strong>，在 <strong>errors</strong> 包里面。这个包还提供了一个<code>New()</code>函数来方便的创建一个通用错误：</p>
<pre><code class="lang-go">var err = errors.New(&quot;something happened&quot;)
</code></pre>
<p>还可以使用 <strong>fmt</strong> 包提供的<code>Errorf</code>函数来<strong>给错误字符串定制一些参数</strong>：</p>
<pre><code class="lang-go">var thing = &quot;something&quot;
var err = fmt.Errorf(&quot;%s happened&quot;, thing)
</code></pre>
<h3 id="错误处理首体验"><a href="#错误处理首体验" class="headerlink" title="错误处理首体验"></a>错误处理首体验</h3><p>在 <strong>Java 语言</strong>中，如果遇到 <strong>I/O</strong> 问题通常会<strong>抛出</strong><code>IOException</code><strong>类型的异常</strong>。然而在 <strong>Go 语言</strong>中，它不会抛出异常，而是<strong>以返回值的形式来通知上层逻辑来处理错误</strong>。</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    // 打开文件
    var f, err = os.Open(&quot;quick.go&quot;)
    if err != nil {
        // 文件不存在、权限等原因
        fmt.Println(&quot;open file failed reason: &quot; + err.Error())
        return
    }
    // 推迟到函数尾调用，确保文件会关闭
    defer f.Close()
    // 存储文件内容
    var content = []byte{}
    // 临时的缓冲，按块读取，一次最多读取 100 字节
    var buf = make([]byte, 100)
    for {
        // 读文件，将读到的内容填充到缓冲
        n, err := f.Read(buf)
        if n &gt; 0 {
            // 将读到的内容聚合起来
            content = append(content, buf[:n]...)
        }
        if err != nil {
            // 遇到流结束或者其它错误
            break
        }
    }
    // 输出文件内容
    fmt.Println(string(content))
}

-------
package main

import &quot;os&quot;
import &quot;fmt&quot;
.....
</code></pre>
<h3 id="体验-Redis-的错误处理"><a href="#体验-Redis-的错误处理" class="headerlink" title="体验 Redis 的错误处理"></a>体验 Redis 的错误处理</h3><p>首先需要使用<code>go get</code>指令下载 <strong>redis</strong> 包：</p>
<pre><code class="lang-bash">go get github.com/go-redis/redis
</code></pre>
<p>下面实现一个小功能：获取 Redis 中两个整数值，然后相乘，再存入 Redis 中：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;strconv&quot;
import &quot;github.com/go-redis/redis&quot;

func main() {
    // 定义客户端对象，内部包含一个连接池
    var client = redis.NewClient(&amp;redis.Options{
        Addr: &quot;localhost:6379&quot;,
    })

    // 定义三个重要的整数变量值，默认都是零
    var val1, val2, val3 int

    // 获取第一个值
    valstr1, err := client.Get(&quot;value1&quot;).Result()
    if err == nil {
        val1, err = strconv.Atoi(valstr1)
        if err != nil {
            fmt.Println(&quot;value1 not a valid integer&quot;)
            return
        }
    } else if err != redis.Nil {
        fmt.Println(&quot;redis access error reason:&quot; + err.Error())
        return
    }

    // 获取第二个值
    valstr2, err := client.Get(&quot;value2&quot;).Result()
    if err == nil {
        val2, err = strconv.Atoi(valstr2)
        if err != nil {
            fmt.Println(&quot;value1 not a valid integer&quot;)
            return
        }
    } else if err != redis.Nil {
        fmt.Println(&quot;redis access error reason:&quot; + err.Error())
        return
    }

    // 保存第三个值
    val3 = val1 * val2
    ok, err := client.Set(&quot;value3&quot;, val3, 0).Result()
    if err != nil {
        fmt.Println(&quot;set value error reason:&quot; + err.Error())
        return
    }
    fmt.Println(ok)
}

------
OK
</code></pre>
<ul>
<li>Go 语言中<strong>不轻易使用异常语句</strong>，所以对于<strong>任何可能出错的地方</strong>都需要<strong>判断返回值的错误信息</strong></li>
<li><strong>字符串的零值是空串而不是 nil</strong>，需要通过返回值的错误信息来判断。<code>redis.Nil</code>就是客户端专门为 <strong>key 不存在</strong>这种情况而定义的<strong>错误对象</strong></li>
</ul>
<h3 id="异常与捕捉"><a href="#异常与捕捉" class="headerlink" title="异常与捕捉"></a>异常与捕捉</h3><p>Go 语言提供了 <strong>panic</strong> 和 <strong>recover</strong> 全局函数让我们可以抛出异常、捕获异常，类似于 <strong>try</strong>、<strong>throw</strong>、<strong>catch</strong>语句，但是又很不一样。比如 <strong>panic</strong> 函数可以抛出<strong>任意对象</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

var negErr = fmt.Errorf(&quot;negative number&quot;)

func main() {
    fmt.Println(fact(5))
    fmt.Println(fact(10))
    fmt.Println(fact(15))
    fmt.Println(fact(-20))
}

func fact(a int) int {
    if a &lt;= 0 {
        panic(negErr)
    }
    var result = 1
    for i := 1; i &lt;= a; i++ {
        result *= i
    }
    return result
}

-------
120
3628800
1307674368000
panic: negative number

goroutine 1 [running]:
main.fact(0xffffffffffffffec, 0x1)
    C:/Users/abel1/go/src/hello/quickgo.go:16 +0x7e
main.main()
    C:/Users/abel1/go/src/hello/quickgo.go:11 +0x15e

Process finished with exit code 2
</code></pre>
<p>上面的代码抛出了<code>negErr</code>，直接导致了程序崩溃，程序最后打印了<strong>异常堆栈信息</strong>。下面我们可以使用 <strong>recover</strong> 函数来保护它，需要结合 <strong>defer</strong> 语句一起使用，这样可以<strong>确保</strong><code>recover()</code><strong>逻辑在程序异常时也可以得到调用</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

var negErr = fmt.Errorf(&quot;negative number&quot;)

func main() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(&quot;error catched&quot;, err)
        }
    }()
    fmt.Println(fact(5))
    fmt.Println(fact(10))
    fmt.Println(fact(15))
    fmt.Println(fact(-20))
}

func fact(a int) int {
    if a &lt;= 0 {
        panic(negErr)
    }
    var result = 1
    for i := 1; i &lt;= a; i++ {
        result *= i
    }
    return result
}

-------
120
3628800
1307674368000
error catched negative number

Process finished with exit code 0
</code></pre>
<blockquote>
<p>可以看到程序<strong>成功捕获了异常</strong>，并且<strong>不再崩溃</strong>，但<strong>异常点后面的逻辑也不会再继续执行了</strong>，</p>
</blockquote>
<p>我们经常还需要对<code>recover()</code>返回的结果进行判断，以<strong>挑选出我们愿意处理的异常对象类型</strong>。对于那些不愿意处理的，可以选择<strong>再次抛出，让上层来处理</strong>：</p>
<pre><code class="lang-go">defer func() {
    if err := recover(); err != nil {
        if err == negErr {
            fmt.Println(&quot;error catched&quot;, err)
        } else {
            panic(err)  // rethrow
        }
    }
}()
</code></pre>
<blockquote>
<p><strong>Go 语言官方</strong>表态<strong>不要轻易使用 panic recover</strong>，除非你真的无法预料中间可能会发生的错误，或者它能非常显著地简化你的代码。<strong>除非逼不得已，否则不要使用它</strong>。</p>
</blockquote>
<h3 id="多个-defer-语句"><a href="#多个-defer-语句" class="headerlink" title="多个 defer 语句"></a>多个 defer 语句</h3><p>有时我们需要<strong>在一个函数里使用多次 defer 语句</strong>。例如拷贝文件，需要同时打开源文件和目标文件，那就需要调用两次<code>defer f.Close</code>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
)

func main() {
    fsrc, err := os.Open(&quot;source.txt&quot;)
    if err != nil {
        fmt.Println(&quot;open source file failed&quot;)
        return
    }
    defer fsrc.Close()
    fdes, err := os.Open(&quot;target.txt&quot;)
    if err != nil {
        fmt.Println(&quot;open target file failed&quot;)
        return
    }
    defer fdes.Close()
    fmt.Println(&quot;do something here&quot;)
}

------
open source file failed

Process finished with exit code 0
</code></pre>
<blockquote>
<p>需要注意的是 <strong>defer 语句的执行顺序</strong>和<strong>代码编写的顺序</strong>是<strong>相反的</strong>，也就是说<strong>最先 defer 的语句最后执行</strong>。</p>
</blockquote>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;os&quot;

func main() {
    fsrc, err := os.Open(&quot;source.txt&quot;)
    if err != nil {
        fmt.Println(&quot;open source file failed&quot;)
        return
    }
    defer func() {
        fmt.Println(&quot;close source file&quot;)
        fsrc.Close()
    }()

    fdes, err := os.Open(&quot;target.txt&quot;)
    if err != nil {
        fmt.Println(&quot;open target file failed&quot;)
        return
    }
    defer func() {
        fmt.Println(&quot;close target file&quot;)
        fdes.Close()
    }()
    fmt.Println(&quot;do something here&quot;)
}

--------
do something here
close target file
close source file

Process finished with exit code 0
</code></pre>
<h2 id="11-协程"><a href="#11-协程" class="headerlink" title="11. 协程"></a>11. 协程</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/shsV8Eef2K_ccgcmfKVSJA" target="_blank" rel="noopener">《快学 Go 语言》第 11 课 —— 千军万马跑协程</a></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-routine.jpg" alt="协程与通道" title>
                </div>
                <div class="image-caption">协程与通道</div>
            </figure>
<p>Go 语言里<strong>协程</strong>被称为<code>goroutine</code>，<strong>通道</strong>被称为<code>channel</code>。</p>
<h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>Go 语言里<strong>创建一个协程</strong>非常简单：<strong>使用</strong><code>go</code><strong>关键词加上一个函数调用</strong>就可以了。</p>
<p>Go 语言会<strong>启动一个新的协程</strong>，函数调用将成为这个<strong>协程的入口</strong>。</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    fmt.Println(&quot;run in main goroutine&quot;)
    go func() {
        fmt.Println(&quot;run in child goroutine&quot;)
        go func() {
            fmt.Println(&quot;run in grand child goroutine&quot;)
            go func() {
                fmt.Println(&quot;run in grand grand child goroutine&quot;)
            }()
        }()
    }()
    time.Sleep(time.Second)
    fmt.Println(&quot;main goroutine will quit&quot;)
}

------
run in main goroutine
run in child goroutine
run in grand child goroutine
run in grand grand child goroutine
main goroutine will quit

Process finished with exit code 0
</code></pre>
<blockquote>
<p>在 Go 语言里<strong>只有一个主协程</strong>，其它都是它的子协程，<strong>子协程之间是平行关系</strong>。</p>
</blockquote>
<h3 id="子协程异常退出"><a href="#子协程异常退出" class="headerlink" title="子协程异常退出"></a>子协程异常退出</h3><p><strong>子协程的异常退出会将异常传播到主协程</strong>，直接会导致主协程也跟着挂掉，进而导致程序崩溃。</p>
<p>为了保护子协程的安全，通常我们会<strong>在协程的入口函数开头增加</strong><code>recover()</code><strong>语句来恢复协程内部发生的异常</strong>，阻断它传播到主协程导致程序崩溃：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    fmt.Println(&quot;run in main goroutine&quot;)
    go func() {
        fmt.Println(&quot;run in child goroutine&quot;)
        go func() {
            fmt.Println(&quot;run in grand child goroutine&quot;)
            go func() {
                fmt.Println(&quot;run in grand grand child goroutine&quot;)
                defer func() {
                    if err := recover(); err != nil {
                        // log error
                        fmt.Println(&quot;wtf error happen!&quot;)
                    }
                }()
                panic(&quot;wtf&quot;)
            }()
        }()
    }()
    time.Sleep(time.Second)
    fmt.Println(&quot;main goroutine will quit&quot;)
}

------
run in main goroutine
run in child goroutine
run in grand child goroutine
run in grand grand child goroutine
wtf error happen!
main goroutine will quit

Process finished with exit code 0
</code></pre>
<h3 id="协程的本质"><a href="#协程的本质" class="headerlink" title="协程的本质"></a>协程的本质</h3><p><strong>Go 语言中的协程</strong>有如下特点：</p>
<ul>
<li>一个进程内部可以运行多个线程，而<strong>每个线程又可以运行多个协程</strong></li>
<li><strong>线程要负责对协程进行调度</strong>，保证每个协程都有机会得到执行</li>
<li>当一个<strong>协程睡眠</strong>时，它要<strong>将线程的运行权让给其他协程来运行</strong>，而不能持续霸占这个线程</li>
<li>同一个线程内部<strong>最多只会有一个协程正在运行</strong></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/process-thread.jpg" alt="同一个线程内部最多只会有一个协程正在运行" title>
                </div>
                <div class="image-caption">同一个线程内部最多只会有一个协程正在运行</div>
            </figure>
<blockquote>
<p><strong>线程的调度</strong>是由<strong>操作系统</strong>负责的，调度算法运行在<strong>内核态</strong>。而<strong>协程的调用</strong>是由 <strong>Go 语言的运行时</strong>负责的，调度算法运行在<strong>用户态</strong>。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-routine-status.jpg" alt="Go 语言协程的三种状态" title>
                </div>
                <div class="image-caption">Go 语言协程的三种状态</div>
            </figure>
<p><strong>协程</strong>可以简化为<strong>三种状态</strong>：</p>
<ul>
<li><strong>运行态</strong>：同一个线程中<strong>最多只会存在一个处于运行态的协程</strong></li>
<li><strong>就绪态</strong>：就绪态的协程是指那些<strong>具备了运行能力但是还没有得到运行机会的协程</strong>，它们随时会被调度到运行态</li>
<li><strong>休眠态</strong>：休眠态的协程<strong>还不具备运行能力</strong>，它们是在<strong>等待某些条件的发生</strong>，比如 I/O 操作的完成、睡眠时间的结束等</li>
</ul>
<p><strong>操作系统对线程的调度是抢占式的</strong>，也就是说单个线程的死循环不会影响其它线程的执行，每个线程的连续运行受到时间片的限制。</p>
<p><strong>Go 语言运行时对协程的调度并不是抢占式的</strong>。如果单个协程通过死循环霸占了线程的执行权，那这个线程就没有机会去运行其它协程了，可以说这个线程假死了。</p>
<p><strong>每个线程都会包含多个就绪态的协程形成了一个就绪队列</strong>。Go 语言<strong>运行时调度器</strong>采用了<code>work-stealing</code>算法，当某个线程空闲时，也就是该线程上所有的协程都在休眠（或者一个协程都没有），它就会去其它线程的就绪队列上去偷一些协程来运行。<strong>正常情况下，运行时会尽量平均分配工作任务</strong>。</p>
<h3 id="设置线程数"><a href="#设置线程数" class="headerlink" title="设置线程数"></a>设置线程数</h3><p><strong>默认情况下</strong>，Go 运行时会将<strong>线程数</strong>会被设置为<strong>机器 CPU 逻辑核心数</strong>。同时它内置的<code>runtime</code>包提供了<code>GOMAXPROCS(n int)</code>函数允许我们<strong>动态调整线程数</strong>。</p>
<blockquote>
<p>如果参数<code>n &lt;=0</code>，就不会产生修改效果，等价于<strong>读取当前的线程数</strong></p>
</blockquote>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
)

func main() {
    // 读取默认的线程数
    fmt.Println(runtime.GOMAXPROCS(0))
    // 设置线程数为 10
    runtime.GOMAXPROCS(10)
    // 读取当前的线程数
    fmt.Println(runtime.GOMAXPROCS(0))
}

------
4
10

Process finished with exit code 0
</code></pre>
<p><strong>获取当前的协程数量</strong>可以使用 <strong>runtime</strong> 包提供的<code>NumGoroutine()</code>方法：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

func main() {
    fmt.Println(runtime.NumGoroutine())
    for i := 0; i &lt; 10; i++ {
        go func() {
            for {
                time.Sleep(time.Second)
            }
        }()
    }
    fmt.Println(runtime.NumGoroutine())
}

------
1
11

Process finished with exit code 0
</code></pre>
<h3 id="协程的应用"><a href="#协程的应用" class="headerlink" title="协程的应用"></a>协程的应用</h3><p>在日常互联网应用中，<strong>Go 语言的协程</strong>主要应用在 <strong>HTTP API 应用、消息推送系统、聊天系统</strong>等。</p>
<h2 id="12-通道"><a href="#12-通道" class="headerlink" title="12. 通道"></a>12. 通道</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/eZTFa-8drmkZUXsvHycorQ" target="_blank" rel="noopener">《快学 Go 语言》第 12 课 —— 神秘的地下通道</a></p>
</blockquote>
<p><strong>不同的并行协程之间交流的方式</strong>有两种，一种是通过<strong>共享变量</strong>，另一种是通过<strong>队列</strong>。</p>
<p><strong>Go 语言鼓励使用队列的形式来交流</strong>，它单独为<strong>协程之间的队列数据交流</strong>定制了特殊的语法——<strong>通道</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-routine.jpg" alt="协程与通道" title>
                </div>
                <div class="image-caption">协程与通道</div>
            </figure>
<p><strong>通道是协程的输入和输出</strong>。作为<strong>协程的输出</strong>，通道是一个<strong>容器</strong>，它可以<strong>容纳数据</strong>。作为<strong>协程的输入</strong>，通道是一个<strong>生产者</strong>，它可以<strong>向协程提供数据</strong>。</p>
<p><strong>通道作为容器是有限定大小的</strong>，满了就写不进去，空了就读不出来。</p>
<p>通道还有它自己的类型，它可以<strong>限定进入通道的数据的类型</strong>。</p>
<h3 id="创建通道"><a href="#创建通道" class="headerlink" title="创建通道"></a>创建通道</h3><p>创建通道只有一种语法，那就是<code>make</code><strong>全局函数</strong>，提供<strong>第一个类型参数</strong>限定通道可以容纳的<strong>数据类型</strong>，再提供<strong>第二个整数参数</strong>作为<strong>通道的容器大小</strong>。</p>
<pre><code class="lang-go">// 缓冲型通道，里面只能放整数
var bufferedChannel = make(chan int, 1024)
// 非缓冲型通道
var unbufferedChannel = make(chan int)
</code></pre>
<p><strong>大小参数是可选的</strong>，如果不填，那这个<strong>通道的容量为零</strong>，叫做<strong>「非缓冲型通道」</strong>。</p>
<blockquote>
<p><strong>非缓冲型通道</strong>必须<strong>确保有协程正在尝试读取当前通道</strong>，否则<strong>写操作就会阻塞</strong>直到有其它协程来从通道中读东西。</p>
</blockquote>
<p><strong>非缓冲型通道</strong>总是处于<strong>既满又空</strong>的状态。与之对应的<strong>有限定大小的通道</strong>就是<strong>缓冲型通道</strong>。</p>
<blockquote>
<p>在 Go 语言里<strong>不存在无界通道</strong>，每个通道都是<strong>有限定最大容量的</strong></p>
</blockquote>
<h3 id="读写通道"><a href="#读写通道" class="headerlink" title="读写通道"></a>读写通道</h3><p>Go 语言为<strong>通道的读写</strong>设计了特殊的<strong>箭头语法糖</strong><code>&lt;-</code>，把箭头写在通道变量的<strong>右边</strong>就是<strong>写通道</strong>，把箭头写在通道的<strong>左边</strong>就是<strong>读通道</strong>。需要注意的是，<strong>一次只能读写一个元素</strong>。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var ch chan int = make(chan int, 4)
    for i := 0; i &lt; cap(ch); i++ {
        ch &lt;- i // 写通道
    }
    for len(ch) &gt; 0 {
        fmt.Printf(&quot;current len: %d, cap: %d\n&quot;, len(ch), cap(ch))
        var value int = &lt;-ch // 读通道
        fmt.Printf(&quot;value: %d\n&quot;, value)
    }
}

------
current len: 4, cap: 4
value: 0
current len: 3, cap: 4
value: 1
current len: 2, cap: 4
value: 2s
current len: 1, cap: 4
value: 3

Process finished with exit code 0
</code></pre>
<p><strong>通道作为容器</strong>，可以像切片一样，使用<code>cap()</code>和<code>len()</code>全局函数获得<strong>通道的容量</strong>和<strong>当前内部的元素个数</strong>。</p>
<blockquote>
<p>通道一般作为<strong>不同的协程交流的媒介</strong>，不过<strong>在同一个协程里也是可以使用的</strong></p>
</blockquote>
<h3 id="读写阻塞"><a href="#读写阻塞" class="headerlink" title="读写阻塞"></a>读写阻塞</h3><p><strong>通道满了，写操作就会阻塞，协程就会进入睡眠</strong>，直到有其它协程读通道挪出了空间，协程才会被唤醒。如果有多个协程的写操作都阻塞了，<strong>一个读操作只会唤醒一个协程</strong>。</p>
<p><strong>通道空了，读操作就会阻塞，协程也会进入睡眠</strong>，直到有其它协程写通道装进了数据才会被唤醒。如果有多个协程的读操作阻塞了，<strong>一个写操作也只会唤醒一个协程</strong>。</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

func send(ch chan int) {
    for {
        var value = rand.Intn(100)
        ch &lt;- value
        fmt.Printf(&quot;send %d\n&quot;, value)
    }
}

func recv(ch chan int) {
    for {
        value := &lt;-ch
        fmt.Printf(&quot;recv %d\n&quot;, value)
        time.Sleep(time.Second)
    }
}

func main() {
    var ch = make(chan int, 1)
    // 子协程循环读
    go recv(ch)
    // 主协程循环写
    send(ch)
}

------
send 81
send 87
recv 81
recv 87
send 47
recv 47
send 59
...
</code></pre>
<h3 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h3><p><strong>Go 语言的通道</strong>不但<strong>支持读写操作</strong>，还<strong>支持关闭</strong>。<strong>读取</strong>一个<strong>已经关闭的通道</strong>会立即返回<strong>通道类型的「零值」</strong>，而<strong>写入</strong>一个<strong>已经关闭的通道</strong>会<strong>抛出异常</strong>。</p>
<blockquote>
<p>如果通道里的元素是<strong>整型</strong>的，<strong>读操作不能通过返回值来确定通道是否关闭</strong></p>
</blockquote>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var ch = make(chan int, 4)
    ch &lt;- 1
    ch &lt;- 2
    close(ch)

    value := &lt;-ch
    fmt.Println(value)
    value = &lt;-ch
    fmt.Println(value)
    value = &lt;-ch
    fmt.Println(value)
}

------
1
2
0

Process finished with exit code 0
</code></pre>
<p>还可以使用<code>for range</code>语法取代箭头操作符<code>&lt;-</code>来<strong>遍历通道</strong>。当<strong>通道空了</strong>，循环会<strong>暂停阻塞</strong>。当<strong>通道关闭</strong>时，<strong>阻塞停止，循环也跟着结束了</strong>。当循环结束时，我们就知道通道已经关闭了。</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var ch = make(chan int, 4)
    ch &lt;- 1
    ch &lt;- 2
    close(ch)

    // for range 遍历通道
    for value := range ch {
        fmt.Println(value)
    }
}

------
1
2

Process finished with exit code 0
</code></pre>
<p>如果将上面关闭通道的语句注释掉，使用<code>for range</code>语法遍历通道就会报错：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func main() {
    var ch = make(chan int, 4)
    ch &lt;- 1
    ch &lt;- 2
    // close(ch)

    // for range 遍历通道
    for value := range ch {
        fmt.Println(value)
    }
}

------
1
2
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
main.main.func1(0xc00007e000)
    C:/Users/abel1/go/src/hello/quickgo.go:13 +0xa1
main.main()
    C:/Users/abel1/go/src/hello/quickgo.go:17 +0xa1

Process finished with exit code 2
</code></pre>
<blockquote>
<p><strong>通道</strong>如果<strong>没有显式关闭</strong>，当它不再被程序使用的时候，会<strong>自动关闭被垃圾回收掉</strong>。不过优雅的程序应该<strong>将通道看成资源</strong>，<strong>显式关闭每个不再使用的资源</strong>是一种良好的习惯</p>
</blockquote>
<h3 id="通道写安全"><a href="#通道写安全" class="headerlink" title="通道写安全"></a>通道写安全</h3><p><strong>写通道</strong>时一定要<strong>确保通道没有被关闭</strong>，否则会<strong>抛出异常</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

// 写通道
func send(ch chan int) {
    i := 0
    for {
        i++
        ch &lt;- i
    }
}

// 读通道
func recv(ch chan int) {
    value := &lt;-ch
    fmt.Println(value)
    value = &lt;-ch
    fmt.Println(value)
    close(ch)
}

func main() {
    var ch = make(chan int, 4)
    go recv(ch)
    send(ch)
}

------
1
2
panic: send on closed channel

goroutine 1 [running]:
main.send(0xc00007e000)
    C:/Users/abel1/go/src/hello/quickgo.go:10 +0x4b
main.main()
    C:/Users/abel1/go/src/hello/quickgo.go:26 +0x6d

Process finished with exit code 2
</code></pre>
<p><strong>确保通道写安全</strong>的最好方式是<strong>由负责写通道的协程自己来关闭通道</strong>，读通道的协程不要去关闭通道：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func send(ch chan int) {
    ch &lt;- 1
    ch &lt;- 2
    ch &lt;- 3
    ch &lt;- 4
    close(ch)
}

func recv(ch chan int) {
    for v := range ch {
        fmt.Println(v)
    }
}

func main() {
    var ch = make(chan int, 1)
    go send(ch)
    recv(ch)
}

------
1
2
3
4

Process finished with exit code 0
</code></pre>
<p>这样可以应对<strong>单写多读</strong>的场景。不过在<strong>多写单读</strong>的场景下，任意一个读写通道的协程都不可以随意关闭通道，否则会导致其它写通道协程抛出异常。</p>
<p>这个时候就需要使用<strong>内置</strong><code>sync</code><strong>包提供的</strong><code>WaitGroup</code><strong>对象</strong>，使用计数来等待指定事件完成，即<strong>等待所有的写通道协程都结束运行后才关闭通道</strong>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func send(ch chan int, wg *sync.WaitGroup) {
    defer wg.Done() // 计数值减 1
    i := 0
    for i &lt; 4 {
        i++
        ch &lt;- i
    }
}

func recv(ch chan int) {
    for value := range ch {
        fmt.Println(value)
    }
}

func main() {
    var ch = make(chan int, 4)
    var wg = new(sync.WaitGroup)
    wg.Add(2)       // 增加计数值
    go send(ch, wg) // 写
    go send(ch, wg) // 写
    go recv(ch)
    // Wait() 阻塞等待所有的写通道协程结束
    // 待计数值变成零，Wait() 才会返回
    wg.Wait()
    // 关闭通道
    close(ch)
    time.Sleep(time.Second)
}

------
1
2
3
4
1
2
3
4

Process finished with exit code 0
</code></pre>
<h3 id="多路通道"><a href="#多路通道" class="headerlink" title="多路通道"></a>多路通道</h3><p>当消费者有<strong>多个消费来源</strong>时，只要有一个来源生产了数据，消费者就可以读这个数据进行消费。这时候可以<strong>将多个来源通道的数据汇聚到目标通道</strong>，然后<strong>统一在目标通道进行消费</strong>。</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

// 每隔一段时间产生一个数
func send(ch chan int, gap time.Duration) {
    i := 0
    for {
        i++
        ch &lt;- i
        time.Sleep(gap)
    }
}

// 将多个原通道内容拷贝到单一的目标通道
func collect(source chan int, target chan int) {
    for v := range source {
        target &lt;- v
    }
}

// 从目标通道消费数据
func recv(ch chan int) {
    for v := range ch {
        fmt.Printf(&quot;receive %d\n&quot;, v)
    }
}

func main() {
    var ch1 = make(chan int) // 原通道 1
    var ch2 = make(chan int) // 原通道 2
    var ch3 = make(chan int) // 目标通道
    go send(ch1, time.Second)
    go send(ch2, 2*time.Second)
    go collect(ch1, ch3)
    go collect(ch2, ch3)
    recv(ch3)
}

------
receive 1
receive 1
receive 2
receive 2
receive 3
receive 4
receive 3
receive 5
receive 6
receive 4
receive 7
receive 8
receive 5
receive 9
receive 10
receive 6
...
</code></pre>
<p>但是这种形式比较繁琐：一来<strong>需要单独编写</strong><code>collect()</code><strong>汇聚函数</strong>，二来<strong>一旦多路通道的规模很大</strong>，就<strong>需要为每一种消费来源都单独启动一个汇聚协程</strong>。好在 Go 语言为这种使用场景提供了<strong>「多路复用」语法糖</strong>——<code>select</code>语句，它可以<strong>同时管理多个通道的读写</strong>：如果所有通道都不能读写，它就<strong>整体阻塞</strong>，只要有一个通道可以读写，它就会继续：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

// 每隔一段时间产生一个数
func send(ch chan int, gap time.Duration) {
    i := 0
    for {
        i++
        ch &lt;- i
        time.Sleep(gap)
    }
}

// 从目标通道消费数据
func recv(ch1 chan int, ch2 chan int) {
    for {
        select {
            case v := &lt;-ch1:
                fmt.Printf(&quot;recv %d from ch1\n&quot;, v)
            case v := &lt;-ch2:
                fmt.Printf(&quot;recv %d from ch2\n&quot;, v)
        }
    }
}

func main() {
    var ch1 = make(chan int)
    var ch2 = make(chan int)
    go send(ch1, time.Second)
    go send(ch2, time.Second * 2)
    recv(ch1, ch2)
}

------
recv 1 from ch2
recv 1 from ch1
recv 2 from ch1
recv 2 from ch2
recv 3 from ch1
recv 4 from ch1
recv 3 from ch2
recv 5 from ch1
recv 6 from ch1
recv 4 from ch2
recv 7 from ch1
...
</code></pre>
<p>可以观察到向<code>ch2</code>写数据的生产者<code>go send(ch2, time.Second * 2)</code>要更慢一些。</p>
<p>上面是<strong>多路复用</strong><code>select</code><strong>语句</strong>的<strong>读通道形式</strong>，下面是它的<strong>写通道形式</strong>，只要有一个通道能写进去，它就会<strong>打破阻塞</strong>：</p>
<pre><code class="lang-go">select {
    case ch1 &lt;- v:
        fmt.Printf(&quot;Send %d to ch1\n&quot;, v)
    case ch2 &lt;- v:
        fmt.Printf(&quot;Send %d to ch2\n&quot;, v)
}
</code></pre>
<blockquote>
<p>关于<strong>如何在多路复用时关闭通道</strong>，可以参考 <a href="https://studygolang.com/articles/16699" target="_blank" rel="noopener">多路复用 channel 的时候，如何优雅的关闭通道 | Go 语言中文网</a></p>
</blockquote>
<h3 id="非阻塞读写"><a href="#非阻塞读写" class="headerlink" title="非阻塞读写"></a>非阻塞读写</h3><p>前面讲的读写都是阻塞读写，<strong>Go 语言还提供了通道的非阻塞读写</strong>：当通道空时，读操作不会阻塞，当通道满时，写操作也不会阻塞。</p>
<p><strong>非阻塞读写</strong>需要<strong>依靠</strong><code>select</code><strong>语句的</strong><code>default</code><strong>分支</strong>。当<code>select</code>语句所有通道都不可读写时，如果定义了<code>default</code>分支，那就会执行<code>default</code>分支逻辑，这样就起到了不阻塞的效果。</p>
<p>下面演示一个<strong>单生产者多消费者</strong>的场景。<strong>生产者同时向两个通道写数据，写不进去就丢弃</strong>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func send(ch1 chan int, ch2 chan int) {
    i := 0
    for {
        i++
        select {
        case ch1 &lt;- i:
            fmt.Printf(&quot;send ch1 %d\n&quot;, i)
        case ch2 &lt;- i:
            fmt.Printf(&quot;send ch2 %d\n&quot;, i)
        default:
        }
    }
}

func recv(ch chan int, gap time.Duration, name string) {
    for v := range ch {
        fmt.Printf(&quot;receive %s %d\n&quot;, name, v)
        time.Sleep(gap)
    }
}

func main() {
    // 无缓冲通道
    var ch1 = make(chan int)
    var ch2 = make(chan int)
    // 两个消费者的休眠时间不一样，名称不一样
    go recv(ch1, time.Second, &quot;ch1&quot;)
    go recv(ch2, time.Second * 2, &quot;ch2&quot;)
    send(ch1, ch2)
}

------
send ch1 429
send ch2 430
receive ch1 429
receive ch2 430
send ch1 10062541
receive ch1 10062541
send ch2 20457524
receive ch2 20457524
send ch1 20467243
receive ch1 20467243
send ch1 30294965
receive ch1 30294965
send ch2 40021595
receive ch2 40021595
send ch1 40041927
receive ch1 40041927
send ch1 49448528
receive ch1 49448528
send ch2 58807676
receive ch2 58807676
...
</code></pre>
<p>可以看到<strong>很多数据被丢弃了</strong>，消费者读到的数据是<strong>不连续的</strong>。</p>
<p>将<code>select</code>语句里面的<code>default</code>分支去掉，再运行一次：</p>
<pre><code class="lang-go">send ch2 1
send ch1 2
receive ch1 2
receive ch2 1
receive ch1 3
send ch1 3
receive ch2 4
send ch2 4
receive ch1 5
send ch1 5
receive ch1 6
send ch1 6
receive ch2 7
send ch2 7
receive ch1 8
send ch1 8
receive ch1 9
send ch1 9
receive ch2 10
...
</code></pre>
<p>可以看到消费者读到的数据都连续了，写通道又恢复为阻塞的。</p>
<blockquote>
<p><code>select</code><strong>语句的</strong><code>default</code><strong>分支</strong>非常关键，它<strong>决定了通道读写操作是否阻塞</strong></p>
</blockquote>
<h3 id="通道内部结构"><a href="#通道内部结构" class="headerlink" title="通道内部结构"></a>通道内部结构</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/channel-struct.jpg" alt="Go 语言中通道的内部结构" title>
                </div>
                <div class="image-caption">Go 语言中通道的内部结构</div>
            </figure>
<p>Go 语言的<strong>通道内部结构</strong>是一个<strong>循环数组</strong>，通过<strong>读写偏移量</strong>来<strong>控制元素发送和接收</strong>。它为了保证<strong>线程安全</strong>，内部会有一个<strong>全局锁</strong>来<strong>控制并发</strong>。对于<strong>发送和接收操作</strong>都会有一个<strong>队列</strong>来<strong>容纳处于阻塞状态的协程</strong>。Go 语言中通道的源码位于<code>$GOROOT/src/runtime/chan.go</code>：</p>
<pre><code class="lang-go">type hchan struct {
    qcount   uint           // 通道有效元素个数
    dataqsiz uint           // 通道容量，循环数组总长度
    buf      unsafe.Pointer // 数组地址
    elemsize uint16 // 内部元素的大小
    closed   uint32 // 是否已关闭，0 或者 1
    elemtype *_type // 内部元素类型信息
    sendx    uint   // 循环数组的写偏移量
    recvx    uint   // 循环数组的读偏移量
    recvq    waitq  // 阻塞在读操作上的协程队列
    sendq    waitq  // 阻塞在写操作上的协程队列

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G&#39;s status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex // 全局锁
}
</code></pre>
<p>这个<strong>循环队列</strong>和 <strong>Java 语言内置的</strong><code>ArrayBlockingQueue</code><strong>结构</strong>如出一辙，所以可以从这个数据结构中得出结论：<strong>队列</strong>在本质上是使用<strong>共享变量加锁</strong>的方式来实现的，<strong>共享变量才是并行交流的本质</strong>。</p>
<h2 id="13-并发与安全"><a href="#13-并发与安全" class="headerlink" title="13. 并发与安全"></a>13. 并发与安全</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/_eB53Vq_dimKSIthR_PllQ" target="_blank" rel="noopener">《快学 Go 语言》第 13 课 —— 并发与安全</a></p>
</blockquote>
<p>并发编程<strong>不同的协程共享数据的方式</strong>除了<strong>通道</strong>之外还有就是<strong>共享变量</strong>。虽然 <strong>Go 语言官方推荐使用通道</strong>的方式来共享数据，但是<strong>通过变量来共享才是基础</strong>，因为通道在底层也是通过共享变量的方式来实现的。通道的内部数据结构包含一个数组，<strong>对通道的读写就是对内部数组的读写</strong>。</p>
<p>并发环境下<strong>共享读写变量</strong>必须<strong>使用锁来控制数据结构的安全</strong>。Go 语言内置了<code>sync</code>包，里面包含了我们平时需要经常使用的<strong>互斥锁对象</strong><code>sync.Nutex</code>。</p>
<blockquote>
<p><strong>Go 语言内置的字典不是线程安全的</strong>，可以<strong>使用互斥锁对象来保护字典</strong>，让它变成线程安全的</p>
</blockquote>
<h3 id="线程不安全的字典"><a href="#线程不安全的字典" class="headerlink" title="线程不安全的字典"></a>线程不安全的字典</h3><blockquote>
<p><strong>Go 语言</strong>从<code>1.9</code>版本之后<strong>自带线程安全的字典</strong><code>sync.map</code>，主要操作有：<code>Store</code>、<code>LoadOrStore</code>、<code>Load</code>、<code>Delete</code>、<code>Range</code></p>
</blockquote>
<p>Go 语言内置了数据结构<strong>「竞态检查」</strong>工具来帮我们<strong>检查程序中是否存在线程不安全的代码</strong>。关于 <strong>Go 语言</strong>的<strong>竞态检测器</strong>，可以参考 <a href="https://studygolang.com/articles/1058" target="_blank" rel="noopener">Go 的竞态检测器 | Go 语言中文网</a>。例如下面这段代码：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;

func write(d map[string]int) {
    d[&quot;fruit&quot;] = 2
}

func read(d map[string]int) {
    fmt.Println(d[&quot;fruit&quot;])
}

func main() {
    d := map[string]int{}
    go read(d)
    write(d)
}
</code></pre>
<p><strong>读、写</strong>分别是<strong>两个协程</strong>，存在明显的<strong>安全隐患</strong>，运行<strong>竞态检查指令</strong><code>go run -race quickgo.go</code>观察输出结果：</p>
<pre><code class="lang-powershell">C:\Users\abel1\go\src\hello&gt;go run -race quickgo.go
==================
WARNING: DATA RACE
Read at 0x00c000052240 by goroutine 6:
  runtime.mapaccess1_faststr()
      C:/Go/src/runtime/map_faststr.go:12 +0x0
  main.read()
      C:/Users/abel1/go/src/hello/quickgo.go:10 +0x64

Previous write at 0x00c000052240 by main goroutine:
  runtime.mapassign_faststr()
      C:/Go/src/runtime/map_faststr.go:190 +0x0
  main.main()
      C:/Users/abel1/go/src/hello/quickgo.go:6 +0x8f

Goroutine 6 (running) created at:
  main.main()
      C:/Users/abel1/go/src/hello/quickgo.go:15 +0x60
==================
==================
WARNING: DATA RACE
Read at 0x00c0000422f8 by goroutine 6:
  main.read()
      C:/Users/abel1/go/src/hello/quickgo.go:10 +0x77

Previous write at 0x00c0000422f8 by main goroutine:
  main.main()
      C:/Users/abel1/go/src/hello/quickgo.go:6 +0xa4

Goroutine 6 (running) created at:
  main.main()
      C:/Users/abel1/go/src/hello/quickgo.go:15 +0x60
==================
2
Found 2 data race(s)
exit status 66
</code></pre>
<p><strong>竞态检查工具</strong>是<strong>基于运行时代码</strong>检查，而不是通过代码静态分析来完成的。这意味着那些<strong>没有机会运行到的代码逻辑中如果存在安全隐患，它是检查不出来的</strong>。</p>
<h3 id="线程安全的字典"><a href="#线程安全的字典" class="headerlink" title="线程安全的字典"></a>线程安全的字典</h3><p>让<strong>字典</strong>变的<strong>线程安全</strong>，就需要使用<strong>互斥锁</strong>对字典的<strong>所有读写操作</strong>进行<strong>保护</strong>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type SafeDict struct {
    data  map[string]int
    mutex *sync.Mutex
}

func NewSafeDict(data map[string]int) *SafeDict {
    return &amp;SafeDict{
        data:  data,
        mutex: &amp;sync.Mutex{},
    }
}

func (d *SafeDict) Len() int {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    return len(d.data)
}

func (d *SafeDict) Put(key string, value int) (int, bool) {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    old_value, ok := d.data[key]
    d.data[key] = value
    return old_value, ok
}

func (d *SafeDict) Get(key string) (int, bool) {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    old_value, ok := d.data[key]
    return old_value, ok
}

func (d *SafeDict) Delete(key string) (int, bool) {
    d.mutex.Lock()
    defer d.mutex.Unlock()
    old_value, ok := d.data[key]
    if ok {
        delete(d.data, key)
    }
    return old_value, ok
}

func write(d *SafeDict, key string, value int) {
    d.Put(key, value)
}

func read(d *SafeDict, key string) {
    fmt.Println(d.Get(key))
}

func main() {
    d := NewSafeDict(map[string]int{
        &quot;apple&quot;: 2,
        &quot;peach&quot;: 3,
    })
    go read(d, &quot;peach&quot;)
    write(d, &quot;peach&quot;, 10)
    time.Sleep(time.Second)
}

------
10 true

Process finished with exit code 0
</code></pre>
<p>再次使用<strong>竞态检查工具</strong>运行上面的代码，发现<strong>没有之前的警告输出</strong>，说明<code>Get()</code>和<code>Put()</code>方法已经做到了<strong>协程安全</strong>，但是<strong>还不能说明</strong><code>Delete()</code><strong>方法是否安全</strong>，因为它<strong>没有机会得到运行</strong>。</p>
<h3 id="避免锁复制"><a href="#避免锁复制" class="headerlink" title="避免锁复制"></a>避免锁复制</h3><p>需要注意的是，<code>sync.Mutex</code>是一个<strong>结构体对象</strong>，这个对象在使用的过程中要<strong>避免被复制（浅拷贝）</strong>。复制将会导致锁被「分裂」了，起不到保护的作用。所以在平时的使用中要<strong>尽量使用它的指针类型</strong>。</p>
<h3 id="使用匿名锁字段"><a href="#使用匿名锁字段" class="headerlink" title="使用匿名锁字段"></a>使用匿名锁字段</h3><p>我们知道<strong>外部结构体可以自动继承匿名内部结构体的所有方法</strong>。如果<strong>将锁字段匿名</strong>，就可以<strong>简化代码</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;sync&quot;

type SafeDict struct {
    data  map[string]int
    *sync.Mutex
}

func NewSafeDict(data map[string]int) *SafeDict {
    return &amp;SafeDict{data, &amp;sync.Mutex{}}
}

func (d *SafeDict) Len() int {
    d.Lock()
    defer d.Unlock()
    return len(d.data)
}

func (d *SafeDict) Put(key string, value int) (int, bool) {
    d.Lock()
    defer d.Unlock()
    old_value, ok := d.data[key]
    d.data[key] = value
    return old_value, ok
}

func (d *SafeDict) Get(key string) (int, bool) {
    d.Lock()
    defer d.Unlock()
    old_value, ok := d.data[key]
    return old_value, ok
}

func (d *SafeDict) Delete(key string) (int, bool) {
    d.Lock()
    defer d.Unlock()
    old_value, ok := d.data[key]
    if ok {
        delete(d.data, key)
    }
    return old_value, ok
}

func write(d *SafeDict) {
    d.Put(&quot;banana&quot;, 5)
}

func read(d *SafeDict) {
    fmt.Println(d.Get(&quot;banana&quot;))
}

func main() {
    d := NewSafeDict(map[string]int{
        &quot;apple&quot;: 2,
        &quot;pear&quot;:  3,
    })
    go read(d)
    write(d)
}
</code></pre>
<h3 id="使用读写锁"><a href="#使用读写锁" class="headerlink" title="使用读写锁"></a>使用读写锁</h3><p>日常应用中，<strong>大多数并发数据结构</strong>都是<strong>读多写少</strong>的，对于读多写少的场合，可以<strong>将互斥锁换成读写锁</strong>，可以有效<strong>提升性能</strong>。<strong>读写锁</strong><code>sync.RWMutex</code>提供了四个常用方法，分别是：<strong>写加锁</strong><code>Lock()</code>、<strong>写释放锁</strong><code>Unlock()</code>、<strong>读加锁</strong><code>RLock()</code>和<strong>读释放锁</strong><code>RUnlock()</code>。</p>
<blockquote>
<p><strong>写锁</strong>是<strong>排他锁</strong>，加写锁时会<strong>阻塞其它协程再加读锁和写锁</strong>。<strong>读锁</strong>是<strong>共享锁</strong>，加读锁还可以<strong>允许其它协程再加读锁</strong>，但是会<strong>阻塞加写锁</strong>。另外，<strong>读写锁</strong>在<strong>写并发高</strong>的情况下<strong>性能退化为普通的互斥锁</strong></p>
</blockquote>
<p>将上面代码中<code>SafeDict</code>的<strong>互斥锁改造成读写锁</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;sync&quot;

type SafeDict struct {
    data  map[string]int
    *sync.RWMutex
}

func NewSafeDict(data map[string]int) *SafeDict {
    return &amp;SafeDict{data, &amp;sync.RWMutex{}}
}

func (d *SafeDict) Len() int {
    d.RLock()
    defer d.RUnlock()
    return len(d.data)
}

func (d *SafeDict) Put(key string, value int) (int, bool) {
    d.Lock()
    defer d.Unlock()
    old_value, ok := d.data[key]
    d.data[key] = value
    return old_value, ok
}

func (d *SafeDict) Get(key string) (int, bool) {
    d.RLock()
    defer d.RUnlock()
    old_value, ok := d.data[key]
    return old_value, ok
}

func (d *SafeDict) Delete(key string) (int, bool) {
    d.Lock()
    defer d.Unlock()
    old_value, ok := d.data[key]
    if ok {
        delete(d.data, key)
    }
    return old_value, ok
}

func write(d *SafeDict) {
    d.Put(&quot;banana&quot;, 5)
}

func read(d *SafeDict) {
    fmt.Println(d.Get(&quot;banana&quot;))
}

func main() {
    d := NewSafeDict(map[string]int{
        &quot;apple&quot;: 2,
        &quot;pear&quot;:  3,
    })
    go read(d)
    write(d)
}
</code></pre>
<h2 id="14-魔术变性指针"><a href="#14-魔术变性指针" class="headerlink" title="14. 魔术变性指针"></a>14. 魔术变性指针</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/A4r6JGls6ijMLtdSDVWp8w" target="_blank" rel="noopener">《快学 Go 语言》第 14 课 —— 魔术变性指针</a></p>
</blockquote>
<p>使用 Go 语言内置的<code>unsafe</code>包可以<strong>直接操纵指定内存地址的内存</strong>。</p>
<h3 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h3><p><code>Pointer</code>代表着<strong>变量的内存地址</strong>，可以将<strong>任意变量的地址</strong>转换成<code>Pointer</code>类型，也可以将<code>Pointer</code>类型转换成<strong>任意的指针类型</strong>，它是不同指针类型之间<strong>互转的中间类型</strong>。另外，<code>Pointer</code>本身也是一个<strong>整型的值</strong>。</p>
<pre><code class="lang-go">type Pointer int
</code></pre>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/unsafe-pointer.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="指针的加减运算"><a href="#指针的加减运算" class="headerlink" title="指针的加减运算"></a>指针的加减运算</h3><p>在 Go 语言中，<strong>编译器禁止</strong><code>Pointer</code><strong>类型直接进行加减运算</strong>。如果要进行运算，需要将<code>Pointer</code>类型转换为<code>uintptr</code>类型进行加减，然后再将<code>uintptr</code>转换成<code>Pointer</code>类型。<code>uintptr</code>其实也是一个<strong>整型</strong>：</p>
<pre><code class="lang-go">type uintptr int
</code></pre>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/uintptr.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

type Rect struct {
    Width  int
    Height int
}

func main() {
    var r = Rect{50, 50}
    // *Rect =&gt; Pointer =&gt; *int =&gt; int
    var width = *(*int)(unsafe.Pointer(&amp;r))
    // *Rect =&gt; Pointer =&gt; uintptr =&gt; Pointer =&gt; *int =&gt; int
    var height = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;r)) + uintptr(8)))
    fmt.Println(width, height)
}

------
50 50

Process finished with exit code 0
</code></pre>
<p>上面的代码使用<code>unsafe</code>包来<strong>读取结构体的内容</strong>，下面尝试<strong>修改结构体的值</strong>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

type Rect struct {
    Width  int
    Height int
}

func main() {
    var r = Rect{50, 50}
    // *Rect =&gt; Pointer =&gt; *int =&gt; int
    var pwidth = (*int)(unsafe.Pointer(&amp;r))
    // *Rect =&gt; Pointer =&gt; uintptr =&gt; Pointer =&gt; *int =&gt; int
    var pheight = (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;r)) + unsafe.Offsetof(r.Height)))
    *pwidth = 100
    *pheight = 200
    fmt.Println(r.Width, r.Height)
}

------
100 200

Process finished with exit code 0
</code></pre>
<p>注意可以<strong>使用</strong><code>unsafe.Offsetof(r.Height)</code><strong>替换</strong><code>uintptr(8)</code>，直接得到<strong>字段在结构体内的偏移量</strong>。</p>
<h3 id="切片的内部结构"><a href="#切片的内部结构" class="headerlink" title="切片的内部结构"></a>切片的内部结构</h3><p><strong>Go 语言</strong>的切片分为<strong>切片头</strong>和<strong>内部数组</strong>两部分，使用<code>unsafe</code>包来验证一下<strong>切片的内部数据结构</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;unsafe&quot;

func main() {
    // head = {address, 10, 10}
    // body = [1,2,3,4,5,6,7,8,9,10]
    var s = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    var address = (**[10]int)(unsafe.Pointer(&amp;s))
    var len = (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + uintptr(8)))
    var cap = (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + uintptr(16)))
    fmt.Println(address, *len, *cap)
    var body = **address
    for i := 0; i &lt; *len; i++ {
        fmt.Printf(&quot;%d &quot;, body[i])
    }
}

------
0xc000044400 10 10
1 2 3 4 5 6 7 8 9 10 
Process finished with exit code 0
</code></pre>
<p>需要注意的是<code>address</code>是一个<strong>二级指针变量</strong>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/address-ptr.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="字符串与切片的高效转换"><a href="#字符串与切片的高效转换" class="headerlink" title="字符串与切片的高效转换"></a>字符串与切片的高效转换</h3><p><strong>字节切片和字符串之间的转换</strong>需要<strong>复制内存</strong>，而<code>unsafe</code>包则提供了另一种<strong>高效的转换方法</strong>，让转换前后的字符串和字节切片<strong>共享内部存储</strong>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/string-slice-unsafe.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p><strong>字符串</strong>和<strong>字节切片</strong>的不同点在于<strong>头部</strong>，字符串的头部 2 个<code>int</code>字节，切片的头部 3 个<code>int</code>字节</p>
</blockquote>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;unsafe&quot;

func main() {
    fmt.Println(bytes2str(str2bytes(&quot;hello&quot;)))
}

func str2bytes(s string) []byte {
    var strhead = *(*[2]int)(unsafe.Pointer(&amp;s))
    var slicehead [3]int
    slicehead[0] = strhead[0]
    slicehead[1] = strhead[1]
    slicehead[2] = strhead[1]
    return *(*[]byte)(unsafe.Pointer(&amp;slicehead))
}

func bytes2str(bs []byte) string {
    return *(*string)(unsafe.Pointer(&amp;bs))
}

------
hello

Process finished with exit code 0
</code></pre>
<blockquote>
<p><strong>注意</strong>：通过这种方式转换得到的字节切片<strong>切记不能修改</strong>，因为其<strong>底层字节数组是共享的</strong>，修改会<strong>破坏字符串的只读规则</strong>。另外<strong>只可以用作临时的局部变量</strong>，因为被共享的字节数组随时可能会被回收</p>
</blockquote>
<h3 id="深入接口变量的赋值"><a href="#深入接口变量的赋值" class="headerlink" title="深入接口变量的赋值"></a>深入接口变量的赋值</h3><blockquote>
<p>可参考<a href="https://mp.weixin.qq.com/s/A4r6JGls6ijMLtdSDVWp8w" target="_blank" rel="noopener">原文</a>，此处略</p>
</blockquote>
<p><strong>接口类型</strong>和<strong>结构体类型</strong>似乎是两个不同的世界。只有<strong>接口类型之间的赋值和转换</strong>会<strong>共享数据</strong>，其它情况都会<strong>复制数据</strong>。其它情况包括<strong>结构体之间的赋值，结构体转接口，接口转结构体</strong>。</p>
<p><strong>不同接口变量之间的转换</strong>本质上只是<strong>调整了</strong>接口变量内部的<strong>类型指针</strong>，<strong>数据指针并不会发生改变</strong>。</p>
<h2 id="15-反射"><a href="#15-反射" class="headerlink" title="15. 反射"></a>15. 反射</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/j_eE_AJp01JCLWO52bPSlw" target="_blank" rel="noopener">《快学 Go 语言》第 15 课 —— 反射</a></p>
</blockquote>
<h3 id="反射的目标"><a href="#反射的目标" class="headerlink" title="反射的目标"></a>反射的目标</h3><ol>
<li><strong>获取变量的类型信息</strong>：例如这个类型的<strong>名称</strong>、<strong>占用字节数</strong>、所有的<strong>方法列表</strong>、所有的<strong>内部字段结构</strong>、<strong>底层存储类型</strong>等</li>
<li><strong>动态修改变量的内部字段值</strong>：例如 <strong>JSON 的反序列化</strong></li>
</ol>
<h3 id="reflect-kind"><a href="#reflect-kind" class="headerlink" title="reflect.kind"></a>reflect.kind</h3><p>Go 语言的<code>reflect</code>包定义了十几种<strong>内置的「元类型」</strong>，每一种元类型都有一个<strong>整数编号</strong>，这个编号使用<code>reflect.Kind</code>类型表示。<strong>不同的结构体</strong>是不同的类型，但是它们都是<strong>同一个元类型</strong><code>Struct</code>。<strong>包含不同子元素的切片</strong>也是不同的类型，但是它们都是<strong>同一个元类型</strong><code>Slice</code>。</p>
<p><code>$GOROOT/src/reflect/type.go</code>中部分源码如下：</p>
<pre><code class="lang-go">// A Kind represents the specific kind of type that a Type represents.
// The zero Kind is not a valid kind.
type Kind uint

const (
    Invalid Kind = iota // 不存在的无效类型
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr // 指针的整数类型，对指针进行整数运算时使用
    Float32
    Float64
    Complex64
    Complex128
    Array // 数组类型
    Chan // 通道类型
    Func  // 函数类型
    Interface  // 接口类型
    Map // 字典类型
    Ptr // 指针类型
    Slice // 切片类型
    String // 字符串类型
    Struct // 结构体类型
    UnsafePointer // unsafe.Pointer 类型
)
</code></pre>
<h3 id="反射的基础代码"><a href="#反射的基础代码" class="headerlink" title="反射的基础代码"></a>反射的基础代码</h3><p><code>reflect</code>包提供了<strong>两个基础反射方法</strong>，分别是<code>TypeOf()</code>和<code>ValueOf()</code>方法，分别用于<strong>获取变量的类型和值</strong>：</p>
<pre><code class="lang-go">func TypeOf(v interface{}) Type
func ValueOf(v interface{}) Value
</code></pre>
<p>对结构体变量进行反射：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

type Rect struct {
    Width  int
    Height int
}

func main() {
    var s int = 42
    fmt.Println(reflect.TypeOf(s))
    fmt.Println(reflect.ValueOf(s))
    var r = Rect{200, 100}
    fmt.Println(reflect.TypeOf(r))
    fmt.Println(reflect.ValueOf(r))
}

------
int
42
main.Rect
{200 100}

Process finished with exit code 0
</code></pre>
<p>这两个方法的<strong>参数是</strong><code>interface{}</code><strong>类型</strong>，所以调用时<strong>编译器</strong>首先会<strong>将目标变量转换成</strong><code>interface{}</code><strong>类型</strong>。<strong>接口类型</strong>包含<strong>两个指针</strong>，一个<strong>指向类型</strong>，一个<strong>指向值</strong>。上面两个方法的作用就是<strong>将接口变量进行解剖</strong>从而<strong>分离出类型和值</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-interface.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li><code>TypeOf()</code>方法<strong>返回变量的类型信息</strong>得到的是一个类型为<code>reflect.Type</code>的变量</li>
<li><code>ValueOf()</code>方法<strong>返回变量的值信息</strong>得到的是一个类型为<code>reflect.Value</code>的变量</li>
</ul>
<h3 id="reflect-Type"><a href="#reflect-Type" class="headerlink" title="reflect.Type"></a>reflect.Type</h3><p>它是一个<strong>接口类型</strong>，里面定义了非常多的方法用于<strong>获取和这个类型相关的一切信息</strong>：</p>
<pre><code class="lang-go">type Type interface {
  ...
  Method(i int) Method  // 获取挂在类型上的第 i&#39;th 个方法
  ...
  NumMethod() int  // 该类型上总共挂了几个方法
  Name() string // 类型的名称
  PkgPath() string // 所在包的名称
  Size() uintptr // 占用字节数
  String() string // 该类型的字符串形式
  Kind() Kind // 元类型
  ...
  Bits() // 占用多少位
  ChanDir() // 通道的方向
  ...
  Elem() Type // 数组，切片，通道，指针，字典(key)的内部子元素类型
  Field(i int) StructField // 获取结构体的第 i&#39;th 个字段
  ...
  In(i int) Type  // 获取函数第 i&#39;th 个参数类型
  Key() Type // 字典的 key 类型
  Len() int // 数组的长度
  NumIn() int // 函数的参数个数
  NumOut() int // 函数的返回值个数
  Out(i int) Type // 获取函数 第 i&#39;th 个返回值类型
  common() *rtype // 获取类型结构体的共同部分
  uncommon() *uncommonType // 获取类型结构体的不同部分
}
</code></pre>
<p><strong>所有的类型结构体</strong>都包含一个<strong>共同的部分信息</strong>，这部分信息<strong>使用</strong><code>rtype</code><strong>结构体描述</strong>，<code>rtype</code>实现了<code>Type</code>接口的所有方法：</p>
<pre><code class="lang-go">// 基础类型 rtype 实现了 Type 接口
type rtype struct {
  size uintptr // 占用字节数
  ptrdata uintptr
  hash uint32 // 类型的hash值
  ...
  kind uint8 // 元类型
  ...
}

// 切片类型
type sliceType struct {
  rtype
  elem *rtype // 元素类型
}

// 结构体类型
type structType struct {
  rtype
  pkgPath name  // 所在包名
  fields []structField  // 字段列表
}

...
</code></pre>
<h3 id="reflect-Value"><a href="#reflect-Value" class="headerlink" title="reflect.Value"></a>reflect.Value</h3><p>不同于<code>reflect.Type</code>的复杂，<code>reflect.Value</code>是一个<strong>非常简单的结构体</strong>：</p>
<pre><code class="lang-go">type Value struct {
  typ *rtype // 变量的类型结构体
  ptr unsafe.Pointer // 数据指针
  flag uintptr // 标志位
}
</code></pre>
<p>来看一个简单的例子：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
)

func main() {
    type SomeInt int
    var s SomeInt = 42
    var t = reflect.TypeOf(s)
    var v = reflect.ValueOf(s)
    // reflect.ValueOf(s).Type() 等价于 reflect.TypeOf(s)
    fmt.Println(t == v.Type())
    fmt.Println(v.Kind() == reflect.Int) // 元类型
    // 将 Value 还原成原来的变量
    var is = v.Interface()
    fmt.Println(is.(SomeInt))
}

------
true
true
42

Process finished with exit code 0
</code></pre>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/var-type-value.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p><code>Value</code>结构体虽然简单，但是其附带的方法非常多，主要是用来<strong>方便用户读写</strong><code>ptr</code><strong>字段指向的数据内存</strong>。使用<code>Value</code>结构体提供的方法要比<code>unsafe</code>包更加<strong>简单直接</strong>：</p>
<pre><code class="lang-go">func (v Value) SetLen(n int)  // 修改切片的 len 属性
func (v Value) SetCap(n int) // 修改切片的 cap 属性
func (v Value) SetMapIndex(key, val Value) // 修改字典 kv
func (v Value) Send(x Value) // 向通道发送一个值
func (v Value) Recv() (x Value, ok bool) // 从通道接受一个值
// Send 和 Recv 的非阻塞版本
func (v Value) TryRecv() (x Value, ok bool)
func (v Value) TrySend(x Value) bool
// 获取切片、字符串、数组的具体位置的值进行读写
func (v Value) Index(i int) Value
// 根据名称获取结构体的内部字段值进行读写
func (v Value) FieldByName(name string) Value
// 将接口变量装成数组，一个是类型指针，一个是数据指针
func (v Value) InterfaceData() [2]uintptr
// 根据名称获取结构体的方法进行调用
// Value 结构体的数据指针 ptr 可以指向方法体
func (v Value) MethodByName(name string) Value
...
</code></pre>
<h3 id="Go-语言官方的反射三大定律"><a href="#Go-语言官方的反射三大定律" class="headerlink" title="Go 语言官方的反射三大定律"></a>Go 语言官方的反射三大定律</h3><ol>
<li>Reflection goes from <strong>interface value</strong> to <strong>reflection object</strong>.</li>
<li>Reflection goes from <strong>reflection object</strong> to <strong>interface value</strong>.</li>
<li>To <strong>modify a reflection object</strong>, the value must be <strong>settable</strong>.</li>
</ol>
<p><strong>第一条定律</strong>的意思是<strong>反射将接口变量转换成反射对象</strong><code>Type</code><strong>和</strong><code>Value</code>：</p>
<pre><code class="lang-go">func TypeOf(v interface{}) Type
func ValueOf(v interface{}) Value
</code></pre>
<p><strong>第二条定律</strong>的意思是<strong>可以通过反射对象</strong><code>Value</code><strong>还原成原先的接口变量</strong>，指的就是<code>Value</code>结构体提供的<code>Interface</code>方法：</p>
<pre><code class="lang-go">func (v Value) Interface() interface{}
</code></pre>
<blockquote>
<p><strong>注意</strong>：<code>v.Interface</code>得到的是一个<strong>接口变量</strong>，还需要<strong>经过一次造型</strong>才能<strong>还原成原先的变量</strong></p>
</blockquote>
<p><strong>第三条定律</strong>的意思是<strong>值类型的变量不可以通过反射来修改</strong>，因为在反射之前，传参的时候需要<strong>将值变量转换成接口变量</strong>，值内容会被<strong>浅拷贝</strong>，所以<code>reflect</code>包直接<strong>禁止了通过反射来修改值类型的变量</strong>：</p>
<pre><code class="lang-go">package main

import &quot;reflect&quot;

func main() {
    var s int = 42
    var v = reflect.ValueOf(s)
    v.SetInt(43)
}

------
panic: reflect: reflect.Value.SetInt using unaddressable value

goroutine 1 [running]:
reflect.flag.mustBeAssignable(0x82)
    C:/Go/src/reflect/value.go:234 +0x15e
reflect.Value.SetInt(0x47b4a0, 0xc00004c000, 0x82, 0x2b)
    C:/Go/src/reflect/value.go:1472 +0x36
main.main()
    C:/Users/abel1/go/src/hello/routine.go:8 +0xc7

Process finished with exit code 2
</code></pre>
<p>可以看到当尝试<strong>通过反射来修改整型变量时</strong>，程序直接<strong>抛出了异常</strong>。而<strong>通过反射来修改指针变量指向的值</strong>还是<strong>可行的</strong>：</p>
<pre><code class="lang-go">panic: reflect: reflect.Value.SetInt using unaddressable value

goroutine 1 [running]:
reflect.flag.mustBeAssignable(0x82)
    C:/Go/src/reflect/value.go:234 +0x15e
reflect.Value.SetInt(0x47b4a0, 0xc00004c000, 0x82, 0x2b)
    C:/Go/src/reflect/value.go:1472 +0x36
main.main()
    C:/Users/abel1/go/src/hello/routine.go:8 +0xc7

Process finished with exit code 2

------
43

Process finished with exit code 0
</code></pre>
<p><strong>结构体</strong>也是<strong>值类型</strong>，也必须<strong>通过指针类型来修改</strong>。下面尝试<strong>使用反射来动态修改结构体内部字段的值</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import &quot;reflect&quot;

type Rect struct {
    Width int
    Height int
}

func SetRectAttr(r *Rect, name string, value int) {
    var v = reflect.ValueOf(r)
    var field = v.Elem().FieldByName(name)
    field.SetInt(int64(value))
}

func main() {
    var r = Rect{50, 100}
    SetRectAttr(&amp;r, &quot;Width&quot;, 100)
    SetRectAttr(&amp;r, &quot;Height&quot;, 200)
    fmt.Println(r)
}

-----
{100 200}

Process finished with exit code 0
</code></pre>
<h2 id="16-包管理-GOPATH-和-Vendor"><a href="#16-包管理-GOPATH-和-Vendor" class="headerlink" title="16. 包管理 GOPATH 和 Vendor"></a>16. 包管理 GOPATH 和 Vendor</h2><blockquote>
<p>摘自<img src="/2019/01/04/quickgo-notes/wechat.svg"><a href="https://mp.weixin.qq.com/s/JS9dbanrly21vbFRZiRoIg" target="_blank" rel="noopener">《快学 Go 语言》第 16 课 —— 包管理 GOPATH 和 Vendor</a></p>
</blockquote>
<h3 id="系统包路径"><a href="#系统包路径" class="headerlink" title="系统包路径"></a>系统包路径</h3><p><strong>Go 语言</strong>有很多<strong>内置包</strong>，内置包的使用需要用户手工<code>import</code>进来。Go 语言的内置包都是<strong>已经编译好的「包对象」</strong>，使用时编译器<strong>不需要进行二次编译</strong>：</p>
<pre><code class="lang-bash">// go sdk 安装路径
&gt; go env GOROOT
/usr/local/go

&gt; go env GOOS
darwin

&gt; go env GOARCH
amd64

&gt; ls /usr/local/go/darwin_amd64
total 22264
drwxr-xr-x   4 root  wheel      136 11  3 05:11 archive
-rw-r--r--   1 root  wheel   169564 11  3 05:06 bufio.a
-rw-r--r--   1 root  wheel   177058 11  3 05:06 bytes.a
drwxr-xr-x   7 root  wheel      238 11  3 05:11 compress
drwxr-xr-x   5 root  wheel      170 11  3 05:11 container
-rw-r--r--   1 root  wheel    93000 11  3 05:06 context.a
drwxr-xr-x  21 root  wheel      714 11  3 05:11 crypto
-rw-r--r--   1 root  wheel    24002 11  3 05:02 crypto.a
...
</code></pre>
<h3 id="全局管理-GOPATH"><a href="#全局管理-GOPATH" class="headerlink" title="全局管理 GOPATH"></a>全局管理 GOPATH</h3><p>Go 语言的<code>GOPATH</code>路径下存放了<strong>全局的第三方依赖包</strong>，当我们在代码里面<code>import</code>某个第三方包时，编译器都会到<code>GOPATH</code>路径下面来寻找。</p>
<pre><code class="lang-bash">&gt; go env GOPATH
/Users/qianwp/go
</code></pre>
<p><code>GOPATH</code>下有三个重要的<strong>子目录</strong>，分别是：</p>
<ul>
<li><code>src</code>：存放<strong>第三方包的源代码</strong></li>
<li><code>pkg</code>：存放<strong>编译好的第三方包对象</strong></li>
<li><code>bin</code>：存放第三方包提供的<strong>二进制可执行文件</strong></li>
</ul>
<blockquote>
<p>当我们<strong>导入第三方包</strong>时，编译器<strong>优先寻找已经编译好的包对象</strong>，如果没有包对象，就会去源码目录<strong>寻找相应的源码</strong>来编译。<strong>使用包对象的编译速度会明显快于使用源码</strong></p>
</blockquote>
<h3 id="友好的包路径"><a href="#友好的包路径" class="headerlink" title="友好的包路径"></a>友好的包路径</h3><p>可以使用<code>go get</code>指令直接去相应的网站上<strong>拉取包代码</strong>，默认使用 <strong>HTTPS 协议</strong>下载代码仓库，可以使用<code>-insecure</code>参数切换到 <strong>HTTP 协议</strong>。</p>
<pre><code class="lang-go">import &quot;github.com/go-redis/redis&quot;
import &quot;golang.org/x/net&quot;
import &quot;gopkg.in/mgo.v2&quot;
import &quot;myhost.com/user/repo&quot; // 个人提供的仓库
</code></pre>
<h3 id="编写第一个模块"><a href="#编写第一个模块" class="headerlink" title="编写第一个模块"></a>编写第一个模块</h3><p>现在尝试编写<strong>第一个 Go 语言算法模块</strong><code>mathy</code>，提供两个方法：<code>Fib</code>用来计算<strong>斐波那契数</strong>，<code>Fact</code>用来计算<strong>阶乘</strong>：</p>
<pre><code class="lang-bash">&gt; mkdir -p $GOPATH/src/github.com/abelsu7/mathy
&gt; cd $GOPATH/src/github.com/abelsu7/mathy
</code></pre>
<p>然后创建<code>mathy.go</code>文件：</p>
<pre><code class="lang-go">package mathy

//  函数名大写，其它的包才可以看的见
func Fib(n int) int64 {
    if n &lt;= 1 {
        return 1
    }
    var s = make([]int64, n+1)
    s[0] = 1
    s[1] = 1
    for i := 2; i &lt;= n; i++ {
        s[i] = s[i-1] + s[i-2]
    }
    return s[n]
}

func Fact(n int) int64 {
    if n &lt;= 1 {
        return 1
    }
    var s int64 = 1
    for i := 2; i &lt;= n; i++ {
        s *= int64(i)
    }
    return s
}
</code></pre>
<p>之后去<strong>其他的任意空目录</strong>下编写<code>main.go</code>文件来使用<code>mathy</code>，但是<strong>不能在当前目录</strong>，因为<strong>同一个目录只能有同一个包名</strong>：</p>
<pre><code class="lang-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/abelsu7/mathy&quot;
)

func main() {
    fmt.Println(mathy.Fib(10))
    fmt.Println(mathy.Fact(10))
}

------
89
3628800

Process finished with exit code 0
</code></pre>
<p>将代码<strong>推送到 Github 上</strong>，之后在<strong>任意 GO 语言环境下</strong>使用<code>go get github.com/abelsu7/mathy</code>即可<strong>将代码拉取到</strong><code>$GOPATH/src/</code><strong>目录下</strong>。</p>
<h3 id="替换导入包名"><a href="#替换导入包名" class="headerlink" title="替换导入包名"></a>替换导入包名</h3><pre><code class="lang-go">import pmathy &quot;github.com/pyloque/mathy&quot;
import omathy &quot;github.com/other/mathy&quot;
</code></pre>
<h3 id="无名导入"><a href="#无名导入" class="headerlink" title="无名导入"></a>无名导入</h3><p>Go 语言还支持一种罕见的导入语法可以<strong>将其它包的所有类型变量都导入到当前的文件中</strong>，在使用相关类型变量时<strong>可以省去包名前缀</strong>：</p>
<pre><code class="lang-go">package main

import &quot;fmt&quot;
import . &quot;github.com/pyloque/mathy&quot;

func main() {
  fmt.Println(Fib(10))
  fmt.Println(Fact(10))
}
</code></pre>
<h3 id="go-get-build-install"><a href="#go-get-build-install" class="headerlink" title="go get/build/install"></a>go get/build/install</h3><p>Go 提供了<strong>三个比较的常用的指令</strong><code>go get</code>、<code>go build</code>、<code>go install</code>用来进行<strong>全局的包管理</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/go-get-install-build.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li><code>go build</code>：<strong>仅编译</strong>。如果当前包里有<code>main</code>包，就会<strong>生成二进制文件</strong>。如果没有<code>main</code>包，则仅仅用来<strong>检查编译是否可以通过</strong>，编译完成后会<strong>丢弃所有临时包对象</strong>。如果指定<code>-i</code>参数，则会<strong>将编译成功的第三方依赖包对象安装到</strong><code>$GOPATH/pkg</code>目录</li>
<li><code>go install</code>：<strong>先编译，再安装</strong>。将编译成的包对象安装到<code>$GOPATH</code>的<code>pkg</code>目录中，将编译成的可执行文件安装到<code>$GOPATH</code>的<code>bin</code>目录中。如果指定<code>-i</code>参数，还会安装编译成功的第三方依赖包对象</li>
<li><code>go get</code>：<strong>下载代码、编译和安装</strong>。<strong>安装内容</strong>包括<strong>包对象和可执行文件</strong>，但是<strong>不包括依赖包</strong></li>
</ul>
<blockquote>
<p>使用<code>go run</code>指令时如果<strong>发现程序启动了很久</strong>，就可以考虑<strong>先执行</strong><code>go build -i</code><strong>指令</strong>，<strong>将编译成功的依赖包都安装到</strong><code>$GOPATH/pkg</code>，这样再次运行<code>go run</code>指令就会快很多</p>
</blockquote>
<h3 id="局部管理-Vendor"><a href="#局部管理-Vendor" class="headerlink" title="局部管理 Vendor"></a>局部管理 Vendor</h3><p><strong>多版本依赖</strong>有一个专业的名称叫<strong>「钻石型」依赖</strong>。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/diamond.jpg" alt="钻石型依赖" title>
                </div>
                <div class="image-caption">钻石型依赖</div>
            </figure>
<p>为了解决这个问题，<strong>Go 1.6</strong> 引入了 <strong>Vendor 机制</strong>，就是<strong>在当前项目的目录下增加</strong><code>vendor</code><strong>子目录</strong>，将自己项目依赖的所有第三方包放到<code>vendor</code>目录里。这样当你导入第三方包的时候，<strong>优先去</strong><code>vendor</code><strong>目录里找你需要的第三方包</strong>。如果没有，再去<code>$GOPATH</code>全局路径下找。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/01/04/quickgo-notes/vendor.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>使用 Vendor 有一个限制，那就是你<strong>不能将 Vendor 里面依赖的类型暴露到外面去</strong>，Vendor 里面的依赖包提供的功能<strong>仅限于当前项目使用</strong>，这就是 Vendor 的<strong>「隔离沙箱」</strong>。正是因为这个沙箱才使得项目里可以存在因为依赖传递导致的<strong>同一个依赖包的多个版本</strong></p>
</blockquote>
<div><strong>🚩推荐阅读</strong>（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）<ul><li><a href="https://abelsu7.top/2019/11/01/using-gogs-as-git-server/">使用 Gogs 自建 Git 服务</a></li><li><a href="https://abelsu7.top/2019/10/31/go-gin-swagger/">在 Gin 中使用 swaggo 自动生成 RESTful API 文档</a></li><li><a href="https://abelsu7.top/2019/10/24/go-build-compress-using-upx/">使用 upx 压缩 go build 打包的可执行文件</a></li><li><a href="https://abelsu7.top/2019/10/24/go-cross-compile/">Go 程序的交叉编译、选择性编译</a></li><li><a href="chunlife.top/2019/06/19/转载《Go语言interface底层实现》/">转载《Go语言interface底层实现》</a></li><li><a href="www.chunlife.top/2019/06/19/转载《Go语言interface底层实现》/">转载《Go语言interface底层实现》</a></li></ul></div>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-09-01T13:04:11.631Z" itemprop="dateUpdated">2019-09-01 21:04:11</time>
</span><br>


        
        文章发布地址：<a href="/2019/01/04/quickgo-notes/" target="_blank" rel="external">https://abelsu7.top/2019/01/04/quickgo-notes/</a>
        
    </div>
    
    <footer>
        <a href="https://abelsu7.top">
            <img src="/img/fong.jpg" alt="Abel Su">
            Abel Su
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书/">读书</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://abelsu7.top/2019/01/04/quickgo-notes/&title=《《快学 Go 语言》笔记》 — Keep Coding&pic=https://abelsu7.top/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://abelsu7.top/2019/01/04/quickgo-notes/&title=《《快学 Go 语言》笔记》 — Keep Coding&source=
快学 Go 语言 - 老钱 | 知乎专栏《快学 Go 语言》最新内容大全代码在线运行 - 在线工具


                
       ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://abelsu7.top/2019/01/04/quickgo-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《《快学 Go 语言》笔记》 — Keep Coding&url=https://abelsu7.top/2019/01/04/quickgo-notes/&via=https://abelsu7.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://abelsu7.top/2019/01/04/quickgo-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/01/08/centos7-notes/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">《CentOS 7 系统管理与运维实战》笔记</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/01/03/6-commands-to-shutdown-linux/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">重启或关闭 Linux 系统的 6 个终端命令</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment v" id="vcomments"></div>
    <!-- <div class="comment" id="comment"></div> -->
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
    <!-- <script src="//t1.aixinxi.net/o_1c3n4pim01nl3jg91b6l1kjtkvsa.js"></script> -->
    <!-- <script src="/js/Valine.min.js"></script> -->
    <!-- <script src="https://cdnjs.cat.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script> -->
    <script src="//cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            av: AV,
            // el: '#comments',
            el: '#vcomments',
            emoticon_url: 'https://abelsu7.top/alu', //表情图片网址
            emoticon_list: ["赞一个.png","坐等.png","长草.png","阴暗.png","邪恶.png","小眼睛.png","想一想.png","献黄瓜.png","献花.png","喜极而泣.png","无语.png","无所谓.png","无奈.png","投降.png","深思.png","期待.png","狂汗.png","蜡烛.png","看不见.png","惊喜.png","击掌.png","欢呼.png","得意.png","不出所料.png","观察.png"],//表情图片文件名
            // notify: 'false' == 'false',
            // verify: 'false' == 'false',
            // notify: 'false',
            // verify: 'false',
            notify: false,
            verify: false,
            appId: "aP2YQo0mfrRpTLrLb1bchILb-gzGzoHsz",
            appKey: "Cp82umQdGScRRFUYLmob6yyK",
            avatar: "mp",
            placeholder: "Write a comment",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->











</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        感谢支持！
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-item switch">切换</span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


            <p>
                
                    <span>
                        <a href="/atom.xml" target="_blank" class="rss" title="rss">
                            <i class="icon icon-lg icon-rss"></i>
                        </a>
                    </span>
                    
                        <span>
                            博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a>
                        </span>
            </p>
    </div>
    <div class="bottom">
        <p>
            <span>
                Abel Su &copy;
                    
                        2018 -
                            
                                2019
            </span>
            <span>
                
                    <a href="http://beian.miit.gov.cn/" target="_blank">
                        粤ICP备16068788号-2
                    </a>
                    <br>
                    
                        Power by
                        <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
                        <a href="https://github.com/abelsu7/hexo-theme-indigo-plus" target="_blank">indigo plus</a>
                        <p>Hosted by <a href="https://pages.github.com" target="_blank" style="font-weight: bold">Github Pages</a></p>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>
<a href="javascript:;" id="gobottom" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-comments"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://abelsu7.top/2019/01/04/quickgo-notes/&title=《《快学 Go 语言》笔记》 — Keep Coding&pic=https://abelsu7.top/img/fong.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://abelsu7.top/2019/01/04/quickgo-notes/&title=《《快学 Go 语言》笔记》 — Keep Coding&source=
快学 Go 语言 - 老钱 | 知乎专栏《快学 Go 语言》最新内容大全代码在线运行 - 在线工具


                
       ..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://abelsu7.top/2019/01/04/quickgo-notes/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《《快学 Go 语言》笔记》 — Keep Coding&url=https://abelsu7.top/2019/01/04/quickgo-notes/&via=https://abelsu7.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://abelsu7.top/2019/01/04/quickgo-notes/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACOElEQVR42u3a0U7DMAxG4b7/Sw+JK6Sx9Px2i6hzcjUNmuYLknEcHwcer+/x6fufP33/hvzm+zjuGDJkyHgsg0y3fj2ZM11DTJUhQ8YGjHWQ/RRAO5GQzEzWJkOGDBlpQFwvpfNZhgwZMtKAu6bWkj8ZMmTIWDNIAkeOtbVk8YKSnAwZMkYz0ouBv/x84/2GDBkyHsJ4NQZ/Zf9S4WQlMmTIGM2oJXZ8ibzonyajB+n7kCFDxiAGKWyt27zSsNvZiJOtlyFDxgYM/hgJqZ2SWfHfgAwZMkYzam0WnUvNtKgXt6bJkCFjBKN2Ydlh80tKErJbfRwyZMh4COOOZdUuAPiBNsDIkCFjECMtmXWK++nhlmyTDBkyZjNqB9HO9SRPCteJ6S9/BxkyZAxlpIV4Er/5YbhW+j9JOmXIkDGUkQbKeIfCIM7D7tGJ9zJkyHgIIw2vvF0M7R/ejmKGK0OGjBGM2sVAWg7j4LRUJ0OGjH0YxYyyffRNSScrlCFDxgaMtDksbYbgx9RagJYhQ8Y+jKsK+rVAzMt/QSeIDBkyxjFQH1n4bCdBDFJMGTJkjGakoY0fL9NWsMt6RmTIkDGI8QoHSelI0OQHVJQmypAhYzQjDXPpotMZagFdhgwZOzA6QbaW8KWzoXlkyJCxAYMfVvmC0tnSxg4ZMmTIuLbNonORgHJbGTJkyMBLJEleLZSjZgsZMmSMZtTaTzvH2v5bZMiQsQ+jdjGQlvh5QY0/dcH9hgwZMv474wsPRJNhHYJ2xwAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.jsdelivr.net/npm/node-waves@0.7.6/src/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="/js/prism.min.js?v=1.7.2"></script>
<script src="/js/prism-vim.min.js?v=1.7.2"></script>
</body>
</html>
